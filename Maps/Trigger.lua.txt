-- #region Mods and Includes
local ArcadeCore = GameModules["Arcade/Core"] -- Maybe be required
local ExtensionFunction = GameModules["Mods/ExtensionFunctionMod"]
local InventoryMod = GameModules["Mods/InventoryMod"]
local EnemyMod = GameModules["Mods/EnemyMod"]
local RoomMod = GameModules["Mods/NewRoomMod"]
local CameraMod = GameModules["Mods/CameraMod"]
local UtilClassMod = GameModules["Mods/UtilClassMod"]
local PlayerMod = GameModules["Mods/PlayerMod"]
local UiUtilMod = GameModules["Mods/UiUtilMod"]
local SkillTreeMod = GameModules["Mods/SkillTreeMod"]
local PerksMod = GameModules["Mods/PerksMod"]
local SaveMod = GameModules["Mods/SaveMod"]

InventoryMod.VectorDistance = ExtensionFunction.VectorDistance
InventoryMod.SaveInventorySlotData = SaveMod.SaveInventorySlotData
InventoryMod.GetInventorySlotData = SaveMod.GetInventorySlotData
InventoryMod.ClearInventorySlotData = SaveMod.ClearInventorySlotData
InventoryMod.SaveInventoryIcon = SaveMod.SaveInventoryIcon
InventoryMod.GetInventoryIcon = SaveMod.GetInventoryIcon
InventoryMod.ClearInventoryIcon = SaveMod.ClearInventoryIcon
InventoryMod.HasInventoryIconData = SaveMod.HasInventoryIconData
InventoryMod.GetSkillValue = SkillTreeMod.GetSkillValue
InventoryMod.SkillNames = SkillTreeMod.SkillNames
InventoryMod.Perks = PerksMod.Perks
InventoryMod.PerkNames = PerksMod.PerkNames
local Inventory = InventoryMod.Inventory
local InventorySlot = InventoryMod.InventorySlot
local InventoryCollectibles = InventoryMod.InventoryCollectibles
local InventoryIconDisplay = InventoryMod.InventoryIconDisplay
local InventoryCollectiblesList = InventoryMod.InventoryCollectiblesList
local InventoryCollectibleNames = InventoryMod.InventoryCollectibleNames
local CollectibleDropped = InventoryMod.CollectibleDropped
local InventoryCollectibleBaseString = InventoryMod.InventoryCollectibleBaseString
local CollectiblesUIManager = InventoryMod.CollectiblesUIManager

EnemyMod.VectorDistance = ExtensionFunction.VectorDistance
EnemyMod.VectorSubtract = ExtensionFunction.VectorSubtract
EnemyMod.VectorLerp = ExtensionFunction.VectorLerp
EnemyMod.LerpAngleDeg = ExtensionFunction.LerpAngleDeg
EnemyMod.NormalizeUnitRotation = ExtensionFunction.NormalizeUnitRotation
EnemyMod.ShuffleTable = ExtensionFunction.ShuffleTable
EnemyMod.WalkableTextureId = RoomMod.WalkableTextureId
EnemyMod.GetSkillValue = SkillTreeMod.GetSkillValue
EnemyMod.SkillNames = SkillTreeMod.SkillNames
EnemyMod.Perks = PerksMod.Perks
EnemyMod.PerkNames = PerksMod.PerkNames
local EnemyHobGoblin = EnemyMod.EnemyHobGoblin
local EnemyGoblinChef = EnemyMod.EnemyGoblinChef
local EnemyGoblin = EnemyMod.EnemyGoblin
local EnemyGoblinSapper = EnemyMod.EnemyGoblinSapper
local EnemyOoze = EnemyMod.EnemyOoze
local EnemySiegeTower = EnemyMod.EnemySiegeTower
local EnemyGoblinMiner = EnemyMod.EnemyGoblinMiner

RoomMod.EnemyHobGoblin = EnemyHobGoblin
RoomMod.EnemyGoblinChef = EnemyGoblinChef
RoomMod.EnemyGoblin = EnemyGoblin
RoomMod.EnemyGoblinSapper = EnemyGoblinSapper
RoomMod.EnemyOoze = EnemyOoze
RoomMod.EnemySiegeTower = EnemySiegeTower
RoomMod.EnemyGoblinMiner = EnemyGoblinMiner
RoomMod.InventoryCollectiblesList = InventoryCollectiblesList
RoomMod.split = ExtensionFunction.split
RoomMod.IsEqual = ExtensionFunction.IsEqual
RoomMod.ToBoolean = ExtensionFunction.ToBoolean
RoomMod.ArrayHasValue = ExtensionFunction.ArrayHasValue
RoomMod.VectorDistance = ExtensionFunction.VectorDistance
RoomMod.ShuffleTable = ExtensionFunction.ShuffleTable
RoomMod.SaveRoomData = SaveMod.SaveRoomData
RoomMod.GetRoomData = SaveMod.GetRoomData
RoomMod.ClearRoomData = SaveMod.ClearRoomData
RoomMod.SaveItemDrops = SaveMod.SaveItemDrops
RoomMod.GetItemDrops = SaveMod.GetItemDrops
RoomMod.ClearItemDrops = SaveMod.ClearItemDrops
local RoomGenerator = RoomMod.RoomGenerator
local RoomEnemies = RoomMod.RoomEnemies
local MiniMap = RoomMod.MiniMap
local RoomItemDrops = RoomMod.ItemDrops

local Camera = CameraMod.Camera
local Fader = UiUtilMod.Fader

SkillTreeMod.IsEqual = ExtensionFunction.IsEqual
SkillTreeMod.split = ExtensionFunction.split
SkillTreeMod.ToBoolean = ExtensionFunction.ToBoolean
SkillTreeMod.SaveSkillTree = SaveMod.SaveSkillTree
SkillTreeMod.GetSkillTree = SaveMod.GetSkillTree
SkillTreeMod.ClearSkillTree = SaveMod.ClearSkillTree
local SkillDisplay = SkillTreeMod.SkillDisplay

PerksMod.SavePerks = SaveMod.SavePerks
PerksMod.LoadPerks = SaveMod.LoadPerks
PerksMod.ClearPerks = SaveMod.ClearPerks
PerksMod.split = ExtensionFunction.split
PerksMod.ShuffleTable = ExtensionFunction.ShuffleTable
PerksMod.ToBoolean = ExtensionFunction.ToBoolean
local PerkDisplay = PerksMod.PerkDisplay

PlayerMod.VectorSubtract = ExtensionFunction.VectorSubtract
PlayerMod.NormalizeUnitRotation = ExtensionFunction.NormalizeUnitRotation
PlayerMod.GetSkillValue = SkillTreeMod.GetSkillValue
PlayerMod.SkillNames = SkillTreeMod.SkillNames
PlayerMod.Perks = PerksMod.Perks
PlayerMod.PerkNames = PerksMod.PerkNames
PlayerMod.SavePlayerData = SaveMod.SavePlayerData
PlayerMod.GetPlayerData = SaveMod.GetPlayerData
PlayerMod.ClearPlayerData = SaveMod.ClearPlayerData
local Player = PlayerMod.Player

local Rect = UtilClassMod.Rect
-- #endregion Mods and Includes

local mod = {}


-- #region Constants
local WORLD_WIDTH = 30
local WORLD_HEIGHT = 30
local GAME_LOOP_RATE = 0.0625
local CENTER_POSITIONS_MAX_COUNT = 10

local LEFT = "L"
local RIGHT = "R"
local TOP = "T"
local BOTTOM = "B"
local LAST_DIRECTION = "LastDirection"

local DEBUG_UNIT = "__DebugMarkerUnit"
local SPAWN_MARKER_UNIT = "__SpawnMarkerUnit"

local EXIT_DOORWAY = "_DungeonDoorway"
local EXIT_DOORWAY_OPEN = "_DungeonDoorway_Open"
local EXIT_LEFT_ROTATION = -90
local EXIT_RIGHT_ROTATION = 90
local EXIT_TOP_ROTATION = 0
local EXIT_BOTTOM_ROTATION = -180

local PLAYER_COLLISION_BEHAVIOUR = "_CollisionDetection_PlayerCharacter"
local PLAYER_INVINCIBLE_BEHAVIOUR = "_PlayerCharacter_Damage_Invincible"
local PLAYERCHARACTER_MISSILE_REACHED = "_PlayerCharacter_Missile_Reached"
local PLAYERCHARACTER_DAMAGED = "_PlayerCharacter_Damaged"
local PLAYER_NAME_RANGED = "_PlayerCharacter_Ranged"
local PLAYER_NAME_MELEE = "_PlayerCharacter_Melee"

-- Enemy
local ENEMY_STUNNED_BEHAVIOUR = "_Enemy_Stunned"
local GOBLIN_MINER_MISSILE_BEHAVIOUR = "_Enemy_GoblinMiner_Missile_Reached"

-- Rooms
local BEGINNING_ROOM_NAME = "StartingBase"
local BEGINNING_ROOM_MARKER = -1
local BEGINNING_ROOM_PATH = "Mods/StartingBase"
local DOOR_OPEN_ANIM = "_Room_Exit_Open"
local DOOR_CLOSE_ANIM = "_Room_Exit_Close"
local ROOM_EXIT_DOOR = "_Room_Exit"
local ROOM_NAME = "RoomName"

-- Coins
local COIN_COLLECTION_TIME = 0.75
local COIN_SPAWN_RADIUS = 0.5
local COIN_UNIT = "_Coin"
local COIN_COLLECT_ABILITY = "_CoinCollect"

-- #endregion Constants

-- Public Variables
-- Player
local PlayerDamageFlashCount = 1
local PlayerDamageFlashTimer = 0.15
local UseMeleePlayer = true
-- Fader
local FadeOutDelay = 0.1
-- Private Variables
-- Rooms
local m_roomGenerator
local m_roomEnemies
local m_roomItemDrops
local m_roomLevel = 1
local m_isBeginningRoom = false
local m_nextRoomTransitionActive = false
local m_doorOpenAnimPlayed = false
local m_roomEnemiesCleared = false
-- Player
local m_player
local m_leftSpawn
local m_rightSpawn
local m_topSpawn
local m_bottomSpawn
-- Player Health and Damage
local m_playerInvincibilityTimer = 0
local m_playerDamageUiFlashCount = 0
local m_playerDamageUiFlashTimer = 0
local m_playerDamageUiIsFlashOn = false
-- Helm Of Valor
local m_helmOfValorTimeRemaining = 0
local m_helmOfValorActive = false
local m_playerHasHelmOfValor = false
-- Camera
local m_camera
-- UI
local m_uiRoot
local m_uiBottomLayer
local m_uiMiddleLayer
local m_uiTopLayer
local m_topStackUi
local m_damageDisplay
local m_playerGoldDisplay
local m_miniMap
-- Inventory
local m_inventory
local m_collectiblesUi
local m_inventoryIconDisplay
-- Scene Transition
local m_fader
local m_sceneTransitionActive = false
-- Skill Tree
local m_skillDisplay
-- Perks
local m_perkDisplay
local m_perkSelecting = false
local m_perkChest
-- Room Coins
local m_droppedCoins = {}
local m_coinTimer = 0

-- #region LifeCycle Functions
function mod.Start(spawnPositionLeft, spawnPositionRight, spawnPositionTop, spawnPositionBottom)
    math.randomseed(os.time())

    m_leftSpawn = spawnPositionLeft
    m_rightSpawn = spawnPositionRight
    m_topSpawn = spawnPositionTop
    m_bottomSpawn = spawnPositionBottom

    -- Fader
    m_fader = Fader:new()
    m_sceneTransitionActive = true
    m_fader:StartFadeOut(
        FadeOutDelay, 
        function()
            m_player:ShowPlayerUI()
            m_sceneTransitionActive = false
        end
    )

    CreateBaseUIElements()
    CreatePlayerDamageDisplay()
    CreatePlayerGoldDisplay()
    ArcadeCore.HideDefaultUi()
    CreateDebugUI()
    CreateCollectiblesUI()

    -- This must be called before Perks as Perks depends on Skills
    m_skillDisplay = SkillDisplay:new(m_uiTopLayer)
    m_skillDisplay.hexGenerator:AddCallback(SkillUnlockedCallback)

    CreateInventoryUI() -- Inventory depends on Skill Tree
    LoadAndSetupPerks() -- Perks depends on Skill Tree
    SpawnPlayerAndSetPosition()
    m_camera = Camera:new(m_player:GetPlayerUnit())
    m_player:SetPlayerCamera(m_camera)
    LoadInventoryFromSave() -- Load Inventory later as Player is required to apply effects
    CheckAndSpawnEntryDoor() -- This should be done later as the Player is required to be moved on the doorway
    CheckAndSpawnExitDoor()
    SpawnEnemiesAndCloseDoors()
    CheckAndSpawnPerks()
    CheckAndActivatePerkRoom()

    m_miniMap = MiniMap:new(m_uiMiddleLayer, m_roomGenerator)
    if m_isBeginningRoom then
        m_miniMap:DisableMiniMap()
    else
        m_miniMap:UpdateMiniMap()
    end

    if m_isBeginningRoom then
        local goldAmount = SaveMod.GetBaseGold()

        if goldAmount == nil then
            goldAmount = 0
        end

        m_player:ForceSetPlayerGold(goldAmount)
    end
    
    -- Add Triggers At The End...
    DCEI.TriggerAddJoystickEvent(
        function()
            if m_sceneTransitionActive then
                return
            end

            local axes = DCEI.TriggeringJoystickAxes
            if m_player ~= nil then
                m_player:HandleJoystickMoved(axes)
            end
        end
    )
    DCEI.TriggerAddJoystickReleaseEvent(
        function()
            if m_sceneTransitionActive then
                return
            end

            if m_player ~= nil then
                m_player:HandleJoystickReleased()
            end
        end
    )
    DCEI.TriggerAddJoystickButtonEvent(0, 
        function()
            if m_sceneTransitionActive then
                return
            end

            local buttonId = DCEI.TriggeringJoystickButtonId
            local buttonEvent = DCEI.TriggeringJoystickButtonEventType
            
            if m_player ~= nil then
                m_player:HandleJoystickButtonClicked(buttonId, buttonEvent, m_roomEnemies)
            end
        end, 
        { icon = "icon_enhance_crusader_zeal" }
    )
    DCEI.TriggerAddJoystickButtonEvent(1, 
        function()
            if m_sceneTransitionActive then
                return
            end

            local buttonId = DCEI.TriggeringJoystickButtonId
            local buttonEvent = DCEI.TriggeringJoystickButtonEventType
            
            if m_player ~= nil then
                m_player:HandleJoystickButtonClicked(buttonId, buttonEvent, m_roomEnemies)
            end
        end, 
        { icon = "icon_enhance_stoneguard_bash" }
    )
    DCEI.TriggerAddJoystickButtonEvent(2, 
        function()
            if m_sceneTransitionActive then
                return
            end

            local buttonId = DCEI.TriggeringJoystickButtonId
            local buttonEvent = DCEI.TriggeringJoystickButtonEventType

            if m_player ~= nil then
                m_player:HandleJoystickButtonClicked(buttonId, buttonEvent, m_roomEnemies)
            end
        end, 
        { icon = "icon_spell_angelic_host" }
    )

    DCEI.TriggerAddUnitDiedEvent(DCEI.UnitAny, HandleUnitDied)
    DCEI.TriggerAddBehaviorAddEvent(DCEI.UnitAny, HandleBehaviourAdded)
    DCEI.TriggerAddUnitSelectedEvent(DCEI.UnitAny, HandleUnitSelected)

    DCEI.TriggerAddTimerEventPeriodicIndefinite(Update, GAME_LOOP_RATE)
end

function Update()

    if m_sceneTransitionActive then
        m_fader:Update(GAME_LOOP_RATE)

        -- Update the camera to set the final state earlier
        if m_player ~= nil and m_player:GetPlayerUnit() ~= nil then
            m_camera:Update(GAME_LOOP_RATE)
        end

        return
    end

    UpdateCoinsCollection(GAME_LOOP_RATE)
    UpdatePerkChestCollection()
    UpdatePlayerHealth(GAME_LOOP_RATE) -- Update Health first otherwise the Player will have current health as LastFramePlayerHealth
    
    if m_player ~= nil then
        m_player:Update(GAME_LOOP_RATE)
        local playerGoldAmount = m_player:GetPlayerGold()
        DCEI.SetText(m_playerGoldDisplay,  tostring(playerGoldAmount))

        local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
        m_collectiblesUi:Update(GAME_LOOP_RATE, m_perkDisplay, playerPosition)
    end

    if m_roomEnemies ~= nil and m_player ~= nil then
        m_roomEnemies:UpdateEnemies(GAME_LOOP_RATE, m_player:GetPlayerUnit())
        
        local enemy = m_roomEnemies:GetActiveNearestEnemy(m_player:GetPlayerUnit())
        m_player:LookTowardsEnemy(enemy)
    end

    UpdatePlayerDamageUI(GAME_LOOP_RATE)
    m_inventory:UpdateSlots(GAME_LOOP_RATE)
    m_inventoryIconDisplay:Update(GAME_LOOP_RATE)
    m_perkDisplay:Update(GAME_LOOP_RATE)

    if m_player ~= nil and m_player:GetPlayerUnit() ~= nil then
        m_camera:Update(GAME_LOOP_RATE)
    end

    if m_playerHasHelmOfValor then
        if not m_helmOfValorActive then
            m_helmOfValorTimeRemaining = m_helmOfValorTimeRemaining - GAME_LOOP_RATE

            if m_helmOfValorTimeRemaining <= 0 then
                m_helmOfValorActive = true
                DCEI.ApplyBehavior(m_player:GetPlayerUnit(), PerksMod.Perks[PerksMod.PerkNames.HelmOfValor].valueAlt)
            end
        end
    end

    if not m_doorOpenAnimPlayed then
        if m_roomEnemies ~= nil then
            if m_roomEnemies:IsRoomClear() then
                m_doorOpenAnimPlayed = true
                m_roomEnemiesCleared = true

                if not m_isBeginningRoom then
                    m_roomGenerator:MarkRoomAtPlayerPositionClear()
                end

                if m_perkSelecting then
                    m_roomGenerator:MarkChallengeRoomCleared()
                end

                ActivateDoorOpenAnimations()
                CollectCoins()
            end
        else
            -- This will generally trigger on Merchant Rooms
            -- Does not matter if it triggers on already cleared rooms
            if not m_isBeginningRoom then
                m_roomGenerator:MarkRoomAtPlayerPositionVisited()
            end

            m_doorOpenAnimPlayed = true
            m_roomEnemiesCleared = true
            ActivateDoorOpenAnimations()
        end
    end
end

-- #endregion LifeCycle Functions

-- #region Event Functions

-- #region Unit Events
function HandleUnitDied()
    if m_sceneTransitionActive then
        return
    end

    local unit = DCEI.TriggeringUnit

    -- Just go through all rooms and trigger it
    -- The correct one will automatically trigger

    local unitName = DCEI.UnitName(unit)
    if unitName == PLAYER_NAME_RANGED or unitName == PLAYER_NAME_MELEE and not m_nextRoomTransitionActive then
        UpdatePlayerBaseGold()
        
        m_player:ClearData(true)
        m_player:Destroy()
        m_player = nil

        m_nextRoomTransitionActive = true
        m_sceneTransitionActive = true
        m_fader:StartFadeIn(
            0, 
            function()
                DisplayGameOverSequence(false)
            end
        )

    elseif m_roomEnemies ~= nil then
        local unitPosition = DCEI.GetUnitPosition2D(unit)
        local goldAmount = m_roomEnemies:RemoveDeadEnemy(unit)

        if goldAmount ~= -1 then
            for i = 1, goldAmount do
                local randomRadius = math.random() * COIN_SPAWN_RADIUS
                local randomAngle = math.random(0, 360)

                local xPosition = math.sin(math.rad(randomAngle)) * randomRadius + unitPosition.x
                local yPosition = math.cos(math.rad(randomAngle)) * randomRadius + unitPosition.y

                local coinUnit = DCEI.CreateUnit(1, 1, COIN_UNIT, xPosition, yPosition)
                table.insert(m_droppedCoins, coinUnit)

                DCEI.LogMessage("Creating Coin")
            end


            -- Redemption
            local hasRedemptionPerk = m_perkDisplay:HasPerk(PerksMod.PerkNames.Redemption)
            local playerInvincibleCount = DCEI.UnitBehaviorStackCount(m_player:GetPlayerUnit(), PLAYER_INVINCIBLE_BEHAVIOUR)

            if hasRedemptionPerk and playerInvincibleCount > 0 then
                local maxHealth = DCEI.GetMaxHealth(m_player:GetPlayerUnit())
                local value = PerksMod.Perks[PerksMod.PerkNames.Redemption].value
                local healthIncrease = maxHealth * value

                DCEI.AddHealth(m_player:GetPlayerUnit(), healthIncrease)
                DCEI.ApplyBehavior(m_player:GetPlayerUnit(), PerksMod.Perks[PerksMod.PerkNames.Redemption].valueAlt)
            end

            -- Adenaline Rush
            if m_player ~= nil then
                m_player:CheckAdenalineRush()
            end
        end
    end
end

function HandleBehaviourAdded()
    if m_sceneTransitionActive then
        return
    end

    local behaviourName = DCEI.TriggeringBehaviorName
    local unit = DCEI.TriggeringUnit
    local unitName = DCEI.UnitName(unit)

    if behaviourName == PLAYER_COLLISION_BEHAVIOUR then
        if unitName == ROOM_EXIT_DOOR then
            if m_nextRoomTransitionActive or not m_roomEnemiesCleared then
                return
            end

            m_nextRoomTransitionActive = true
            m_sceneTransitionActive = true
            m_player:HidePlayerUI()

            SaveNextRoomData()
            m_fader:StartFadeIn(
                0,
                function()
                    DisplayGameOverSequence(true)
                end
            )

        elseif unitName == EXIT_DOORWAY and m_isBeginningRoom then
            if m_nextRoomTransitionActive or not m_roomEnemiesCleared then
                return
            end

            m_nextRoomTransitionActive = true
            m_sceneTransitionActive = true
            m_player:HidePlayerUI()

            local playerGold = m_player:GetPlayerGold()
            SaveMod.SaveBaseGold(playerGold)
            m_player:ForceSetPlayerGold(0)

            SaveNextRoomData()
            m_fader:StartFadeIn(
                0,
                function()
                    DisplayGameOverSequence(true)
                end
            )

        elseif unitName == EXIT_DOORWAY then
            if m_roomGenerator.currentPlayerRow == m_roomGenerator.exitRoomRow and m_roomGenerator.currentPlayerColumn == m_roomGenerator.exitRoomColumn then
                if m_nextRoomTransitionActive or not m_roomEnemiesCleared then
                    return
                end

                m_nextRoomTransitionActive = true
                m_sceneTransitionActive = true
                m_player:HidePlayerUI()

                m_fader:StartFadeIn(0, UpdateCollisionWithExitDoor)
            end
        end

    elseif behaviourName == PlayerMod.PlayerConcussionBlow then  -- This behaviour can also be used to detect which enemy was hit
        
        -- Poison Orb
        if m_perkDisplay:HasPerk(PerksMod.PerkNames.PoisonOrb) then
            DCEI.ApplyBehavior(unit, PerksMod.Perks[PerksMod.PerkNames.PoisonOrb].value)
        end

        -- Knockback
        if m_perkDisplay:HasPerk(PerksMod.PerkNames.Knockback) and m_roomEnemies ~= nil then
            local perk = PerksMod.Perks[PerksMod.PerkNames.Knockback]
            local canHaveKnockback = DCEI.UnitBehaviorStackCount(unit, perk.valueValidation)
            
            if canHaveKnockback > 0 then
                DCEI.LogMessage("Has Knockback Behaviour")
                DCEI.ApplyBehavior(unit, perk.value)

                local unitPosition = DCEI.GetUnitPosition2D(unit)

                local playerRotation = DCEI.GetUnitRotationEuler(m_player:GetPlayerUnit())
                local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
                local yRotation = ExtensionFunction.NormalizeUnitRotation(playerRotation)

                local xPosition = math.sin(math.rad(yRotation)) * perk.valueAlt + unitPosition.x
                local yPosition = math.cos(math.rad(yRotation)) * perk.valueAlt + unitPosition.y

                DCEI.CreateEffect(perk.valueLaunch, unit, xPosition, yPosition)

                local enemies = m_roomEnemies:GetRoomEnemies()
                for _, enemy in ipairs(enemies) do
                    if enemy:IsActive() and enemy:GetMainUnit() == unit then
                        enemy:FakeStunTimer(perk.valueTime)
                        break
                    end
                end
            end
        end

    elseif behaviourName == GOBLIN_MINER_MISSILE_BEHAVIOUR then
        DCEI.LogMessage("Miner Missile Reached")
        local missilePosition = DCEI.GetUnitPosition2D(unit)

        if m_roomEnemies ~= nil then
            m_roomEnemies:ForceSetUnitPosition(missilePosition)
        end

    elseif behaviourName == ENEMY_STUNNED_BEHAVIOUR then
        DCEI.LogMessage("Enemy Stun Behaviour Added")
        if m_roomEnemies ~= nil then
            m_roomEnemies:UpdateEnemyStunState(unit)
        end

    elseif behaviourName == PLAYERCHARACTER_DAMAGED then
        if unitName == PLAYER_NAME_MELEE or unitName == PLAYER_NAME_RANGED then
            if m_helmOfValorActive and m_playerHasHelmOfValor then
                DCEI.RemoveBehavior(m_player:GetPlayerUnit(), PerksMod.Perks[PerksMod.PerkNames.HelmOfValor].valueAlt)
                m_helmOfValorActive = false
                m_helmOfValorTimeRemaining = PerksMod.Perks[PerksMod.PerkNames.HelmOfValor].value

                m_perkDisplay:ActivatePerkRecharge(PerksMod.PerkNames.HelmOfValor, m_helmOfValorTimeRemaining, m_helmOfValorTimeRemaining)
            end
        end

    else
        if m_player ~= nil then
            m_player:HandleBehaviourAdded(behaviourName)
        end
    end
end

function HandleUnitSelected()
    if m_sceneTransitionActive then
        return
    end
    
    local unit = DCEI.TriggeringUnit
    local unitName = DCEI.UnitName(unit)

    DCEI.LogMessage("Selected Unit: " .. unitName)

    -- Add Collectibles to Inventory if successful. Then destroy the unit
    if string.match(unitName, InventoryCollectibleBaseString) then
        HandleInventoryUnitClicked(unit, unitName)

    elseif string.match(unitName, SkillTreeMod.MerchantMale) or string.match(unitName, SkillTreeMod.MerchantFemale) then
        HandleSkillTreeClick()

    end

    DCEI.DeselectUnit(unit)
end
-- #endregion Unit Events

-- #endregion Event Functions

-- #region Utility Fuctions

-- #region Common Game Spawn

function SpawnPlayerAndSetPosition()
    -- Load/Generate Room Data
    local roomType = SaveMod.GetRoomName()
    local roomLevel = SaveMod.GetRoomLevel()

    if roomLevel ~= nil then
        m_roomLevel = roomLevel
    else -- Save the new level if it does not exists...
        SaveMod.SaveMainMapRoomLevel(m_roomLevel)
    end

    if roomType == nil then -- This should be the beginning room
        DCEI.LogMessage("Beginning Room. Generating Rooms")

        m_roomGenerator = RoomGenerator:new(m_roomLevel)
        SkillUnlockedCallback(SkillTreeMod.SkillNames.Preplan)
        m_isBeginningRoom = true
    else
        DCEI.LogMessage("Loading Old Room Data")

        m_roomGenerator = RoomGenerator:LoadRoomStructure()
        m_isBeginningRoom = false
    end
    -- Load/Generate Room Data

    -- Spawn Player
    local playerType
    if UseMeleePlayer then
        playerType = 0
    else
        playerType = 1
    end

    local spawnPosition
    local spawnDirection = SaveMod.GetRoomLastDirection()

    if spawnDirection == LEFT then
        spawnPosition = m_leftSpawn
    elseif spawnDirection == RIGHT then
        spawnPosition = m_rightSpawn
    elseif spawnDirection == TOP then
        spawnPosition = m_topSpawn
    elseif spawnDirection == BOTTOM then
        spawnPosition = m_bottomSpawn
    else
        if m_leftSpawn ~= nil then
            spawnPosition = m_leftSpawn
        elseif m_rightSpawn ~= nil then
            spawnPosition = m_rightSpawn
        elseif m_topSpawn ~= nil then
            spawnPosition = m_topSpawn
        else
            spawnPosition = m_bottomSpawn
        end
    end

    -- Spawn Player
    m_player = Player:new(spawnPosition.x, spawnPosition.y, playerType, m_uiRoot, m_skillDisplay, m_perkDisplay)
    m_player:AddDashCallback(HandleDashTimerEnded)
    
    SpawnItemDrops()
end

function SpawnItemDrops()
    m_roomItemDrops = RoomItemDrops:new()
    local roomName
    local playerRow = BEGINNING_ROOM_MARKER
    local playerColumn = BEGINNING_ROOM_MARKER

    if m_isBeginningRoom then
        roomName = BEGINNING_ROOM_NAME
    else
        playerRow = m_roomGenerator.currentPlayerRow
        playerColumn = m_roomGenerator.currentPlayerColumn
        roomName = m_roomGenerator.roomMatrix[playerRow][playerColumn]
    end

    local roomItems = m_roomItemDrops:GetItemsInRoom(roomName, playerRow, playerColumn)
    for _, item in ipairs(roomItems) do
        local xPosition = item.xPosition
        local yPosition = item.yPosition
        local itemName = item.itemName

        local item = DCEI.CreateUnit(1, 1, itemName, xPosition, yPosition)
        DCEI.ApplyBehavior(item, CollectibleDropped)
        m_collectiblesUi:AddNewUI(m_uiRoot, item, itemName)
    end
end

function SpawnEnemiesAndCloseDoors()
    local playerRow = m_roomGenerator.currentPlayerRow
    local playerColumn = m_roomGenerator.currentPlayerColumn

    local exitRow = m_roomGenerator.exitRoomRow
    local exitColumn = m_roomGenerator.exitRoomColumn

    local spawnEnemies = true

    if m_isBeginningRoom then
        spawnEnemies = false
    end

    if not m_isBeginningRoom and not m_roomGenerator:IsPlayerRoomCleared() then
        if playerRow == exitRow and playerColumn == exitColumn and m_roomLevel == RoomMod.RoomLevelMax then
            m_roomEnemies = RoomEnemies:new(m_player:GetPlayerUnit(), m_roomGenerator, m_skillDisplay, m_roomLevel, true)
        else
            m_roomEnemies = RoomEnemies:new(m_player:GetPlayerUnit(), m_roomGenerator, m_skillDisplay, m_roomLevel, false)
        end
        ActivateDoorCloseAnimations()

    elseif not m_isBeginningRoom and m_roomGenerator:IsPlayerRoomCleared() then
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), PlayerMod.PlayerOutOfCombatSpeed)
    end
end

function ActivateDoorCloseAnimations()
    DCEI.LogMessage("Playing Close Door Animations")

    local roomDoors = DCEI.FindUnits(ROOM_EXIT_DOOR)
    DCEI.LogMessage("Total Doors: " .. #roomDoors)

    for _, door in ipairs(roomDoors) do
        DCEI.LogMessage("Casting Close Ability")
        DCEI.CastAbility(DOOR_CLOSE_ANIM, door, door)
    end
end

function ActivateDoorOpenAnimations()
    DCEI.LogMessage("Playing Open Door Animations")

    local roomDoors = DCEI.FindUnits(ROOM_EXIT_DOOR)
    DCEI.LogMessage("Total Doors: " .. #roomDoors)

    for _, door in ipairs(roomDoors) do
        DCEI.LogMessage("Casting Open Ability")
        DCEI.CastAbility(DOOR_OPEN_ANIM, door, door)
    end

    local playerRow = m_roomGenerator.currentPlayerRow
    local playerColumn = m_roomGenerator.currentPlayerColumn

    local spawnRoomRow = m_roomGenerator.spawnRoomRow
    local spawnRoomColumn = m_roomGenerator.spawnRoomColumn

    if playerRow ~= spawnRoomRow or playerColumn ~= spawnRoomColumn then
        local exitDoors = DCEI.FindUnits(EXIT_DOORWAY)
        for _, door in ipairs(exitDoors) do
            DCEI.ApplyBehavior(door, EXIT_DOORWAY_OPEN)
        end

    elseif m_isBeginningRoom then
        local exitDoors = DCEI.FindUnits(EXIT_DOORWAY)
        for _, door in ipairs(exitDoors) do
            DCEI.ApplyBehavior(door, EXIT_DOORWAY_OPEN)
        end
    end
end

-- #endregion Common Game Spawn

-- #region Doorways

function GetDoorsInDirection(doors, direction)
    local validDoors = {}

    for _, door in ipairs(doors) do
        local position = DCEI.GetUnitPosition2D(door)
        if position.x < RoomMod.GetMinDirectionPosition(true) and direction == LEFT then
            table.insert(validDoors, door)

        elseif position.x > RoomMod.GetMaxDirectionPosition(true) and direction == RIGHT then
            table.insert(validDoors, door)

        elseif position.y < RoomMod.GetMinDirectionPosition(false) and direction == BOTTOM then
            table.insert(validDoors, door)

        elseif position.y > RoomMod.GetMaxDirectionPosition(false) and direction == TOP then
            table.insert(validDoors, door)
        end
    end

    return validDoors
end

function GetNearestDoorFromCenter(validDoors)
    local nearestPosition = 999
    local nearestUnit = nil
    local worldCenter = DCEI.GetMapCenterPoint()

    for _, door in ipairs(validDoors) do
        local position = DCEI.GetUnitPosition2D(door)
        local distance = ExtensionFunction.VectorDistance(worldCenter, position)

        if distance < nearestPosition then
            nearestPosition = distance
            nearestUnit = door
        end
    end

    return nearestUnit
end

function CheckAndSpawnEntryDoor()
    local playerSpawnRow = m_roomGenerator.currentPlayerRow
    local playerSpawnColumn = m_roomGenerator.currentPlayerColumn

    local spawnRow = m_roomGenerator.spawnRoomRow
    local spawnColumn = m_roomGenerator.spawnRoomColumn

    if playerSpawnRow ~= spawnRow or playerSpawnColumn ~= spawnColumn or m_isBeginningRoom then
        return
    end

    local direction = m_roomGenerator.spawnRoomDoorDirection
    local roomExits = DCEI.FindUnits(ROOM_EXIT_DOOR)
    local validExits = GetDoorsInDirection(roomExits, direction)

    local validExit = GetNearestDoorFromCenter(validExits)
    local position = DCEI.GetUnitPosition2D(validExit)
    local newDoor = DCEI.CreateUnit(1, 1, EXIT_DOORWAY, position.x, position.y)

    if direction == LEFT then
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_LEFT_ROTATION, 0)
    elseif direction == RIGHT then
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_RIGHT_ROTATION, 0)
    elseif direction == TOP then
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_TOP_ROTATION, 0)
    else
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_BOTTOM_ROTATION, 0)
    end

    for _, exit in ipairs(validExits) do
        DCEI.RemoveUnit(exit)
    end

    local spawnDirection = SaveMod.GetRoomLastDirection()
    
    if spawnDirection == nil then
        spawnDirection = direction
        local spawnPosition

        if spawnDirection == LEFT then
            spawnPosition = m_leftSpawn
        elseif spawnDirection == RIGHT then
            spawnPosition = m_rightSpawn
        elseif spawnDirection == TOP then
            spawnPosition = m_topSpawn
        elseif spawnDirection == BOTTOM then
            spawnPosition = m_bottomSpawn
        end

        DCEI.SetUnitPosition2D(m_player:GetPlayerUnit(), spawnPosition.x, spawnPosition.y)
        DCEI.Move(m_player:GetPlayerUnit(), spawnPosition.x, spawnPosition.y)
    end
end

function CheckAndSpawnExitDoor()
    if m_isBeginningRoom then
        return
    end

    local playerSpawnRow = m_roomGenerator.currentPlayerRow
    local playerSpawnColumn = m_roomGenerator.currentPlayerColumn
    
    local exitRoomRow = m_roomGenerator.exitRoomRow
    local exitRoomColumn = m_roomGenerator.exitRoomColumn

    if playerSpawnRow ~= exitRoomRow or playerSpawnColumn ~= exitRoomColumn then
        return
    end

    local direction = m_roomGenerator.exitRoomDoorDirection
    local roomExits = DCEI.FindUnits(ROOM_EXIT_DOOR)
    local validExits = GetDoorsInDirection(roomExits, direction)

    local validExit = GetNearestDoorFromCenter(validExits)
    local position = DCEI.GetUnitPosition2D(validExit)
    local newDoor = DCEI.CreateUnit(1, 1, EXIT_DOORWAY, position.x, position.y)

    if direction == LEFT then
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_LEFT_ROTATION, 0)
    elseif direction == RIGHT then
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_RIGHT_ROTATION, 0)
    elseif direction == TOP then
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_TOP_ROTATION, 0)
    else
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_BOTTOM_ROTATION, 0)
    end

    for _, exit in ipairs(validExits) do
        DCEI.RemoveUnit(exit)
    end
end

function UpdateCollisionWithExitDoor()
    m_inventory:SaveInventory()
    m_inventoryIconDisplay:Save()
    m_player:SaveData()
    m_roomItemDrops:ClearData() -- Clear the data for the older dungeon

    m_roomLevel = m_roomLevel + 1
    if m_roomLevel > RoomMod.RoomLevelMax then
        UpdatePlayerBaseGold()

        m_roomGenerator:ClearSaveData()
        m_perkDisplay:Clear()

        SaveMod.ClearAllMainMapData()
        DCEI.Wait(1)
        DCEI.PlayLevel(BEGINNING_ROOM_PATH, BEGINNING_ROOM_NAME)

    else
        m_perkDisplay:ClearPerkMark()
        m_perkDisplay:SetPerkValue(PerksMod.PerkNames.HelmOfValor, m_helmOfValorTimeRemaining)
        m_perkDisplay:Save()

        m_roomGenerator:ClearSaveData()
        SaveMod.ClearItemDrops()
        
        m_roomGenerator = RoomGenerator:new(m_roomLevel)
        SkillUnlockedCallback(SkillTreeMod.SkillNames.Preplan)
        m_roomGenerator:SaveRoomStructure()
        
        local roomName = m_roomGenerator:GetRoomFromPlayerPosition()
        local roomPath = RoomMod.GetRoomPath(roomName)

        SaveMod.SaveAllMainMapData(roomName, m_roomLevel, nil)
        DCEI.Wait(1)
        DCEI.PlayLevel(roomPath, roomName)
    end
end

function GetRandomCenterPointOnMap(validPositions)
    local capturedPositions = {}

    local worldCenter = DCEI.GetMapCenterPoint()
    
    local currentX = math.floor(worldCenter.x)
    local currentY = math.floor(worldCenter.y)
    local initialDiff = 1

    while true do
        for i = currentX, currentX + initialDiff - 1 do
            local position = { x = i, y = currentY }
            if ExtensionFunction.ArrayHasPosition(validPositions, position) then
                table.insert(capturedPositions, position)
            end
        end
        currentX = currentX + initialDiff

        for i = currentY, currentY - initialDiff + 1, -1 do
            local position = { x = currentX, y = i }
            if ExtensionFunction.ArrayHasPosition(validPositions, position) then
                table.insert(capturedPositions, position)
            end
        end
        currentY = currentY - initialDiff

        initialDiff = initialDiff + 1

        for i = currentX, currentX - initialDiff + 1, -1 do
            local position = { x = i, y = currentY }
            if ExtensionFunction.ArrayHasPosition(validPositions, position) then
                table.insert(capturedPositions, position)
            end
        end
        currentX = currentX - initialDiff

        for i = currentY, currentY + initialDiff - 1 do
            local position = { x = currentX, y = i }
            if ExtensionFunction.ArrayHasPosition(validPositions, position) then
                table.insert(capturedPositions, position)
            end
        end
        currentY = currentY + initialDiff

        initialDiff = initialDiff + 1

        if currentX >= WORLD_WIDTH or currentY >= WORLD_HEIGHT or currentX <= 0 or currentY <= 0 then
            break
        end

        if #capturedPositions >= CENTER_POSITIONS_MAX_COUNT then
            break
        end
    end

    local randomIndex = math.random(1, #capturedPositions)
    local targetPosition = capturedPositions[randomIndex]

    return targetPosition
end

-- #endregion Doorways

-- #region GameOver State

function SaveNextRoomData()
    if not m_isBeginningRoom then
        DCEI.LogMessage("Saving Next Room Data")

        local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
        local direction = ""
        
        if playerPosition.x < RoomMod.GetMinDirectionPosition(true) then
            m_roomGenerator.currentPlayerColumn = m_roomGenerator.currentPlayerColumn - 1
            direction = RIGHT
        elseif playerPosition.x > RoomMod.GetMaxDirectionPosition(true) then
            m_roomGenerator.currentPlayerColumn = m_roomGenerator.currentPlayerColumn + 1
            direction = LEFT
        elseif playerPosition.y < RoomMod.GetMinDirectionPosition(false) then
            m_roomGenerator.currentPlayerRow = m_roomGenerator.currentPlayerRow + 1
            direction = TOP
        elseif playerPosition.y > RoomMod.GetMaxDirectionPosition(false) then
            m_roomGenerator.currentPlayerRow = m_roomGenerator.currentPlayerRow - 1
            direction = BOTTOM
        else
            DCEI.LogError("Invalid Bounds?!!")
        end

        SaveMod.SaveMainMapLastDirection(direction)
    else
        SaveMod.SaveMainMapLastDirection(nil)
    end

    -- Only Save when going into the new room
    m_roomGenerator:SaveRoomStructure()
    m_roomItemDrops:SaveData()
    m_inventory:SaveInventory() 
    m_inventoryIconDisplay:Save()
    m_player:SaveData()
    m_skillDisplay:SaveSkillTree()

    m_perkDisplay:SetPerkValue(PerksMod.PerkNames.HelmOfValor, m_helmOfValorTimeRemaining)
    m_perkDisplay:Save()
end

function DisplayGameOverSequence(playerWon)
    if m_player ~= nil then
        m_player:Destroy()
        m_player = nil
    end
    m_camera:UpdateTarget(nil)

    if playerWon then
        DCEI.LogMessage("X: " .. m_roomGenerator.currentPlayerColumn .. ", Y: " .. m_roomGenerator.currentPlayerRow)
        local roomName = m_roomGenerator:GetRoomFromPlayerPosition()
        local roomPath = RoomMod.GetRoomPath(roomName)

        SaveMod.SaveMainMapRoomName(roomName)
        DCEI.Wait(1)
        DCEI.PlayLevel(roomPath, roomName)
    else
        m_roomGenerator:ClearSaveData()
        m_inventory:ClearInventorySave()
        m_inventoryIconDisplay:Clear()
        m_roomItemDrops:ClearData()
        m_perkDisplay:Clear()

        SaveMod.ClearAllMainMapData()
        DCEI.Wait(1)
        DCEI.PlayLevel(BEGINNING_ROOM_PATH, BEGINNING_ROOM_NAME)
    end
end

-- #endregion GameOver State

-- #region Player Functions

function UpdatePlayerHealth(deltaTime)
    if m_player == nil then
        return
    end

    if m_player:GetPlayerUnit() == nil then
        return
    end

    local playerHealth = DCEI.GetHealthValue(m_player:GetPlayerUnit())
    local lastFramePlayerHealth = m_player:GetPlayerLastFrameHealth()

    -- Invulnerability
    local invincibilityTimer = PlayerMod.PlayerInvincibleTimer
    local skillStatus = m_skillDisplay.hexGenerator:GetSkillStatus(SkillTreeMod.SkillNames.Invulnerability)

    if skillStatus.isUnlocked then
        local value = SkillTreeMod.GetSkillValue(SkillTreeMod.SkillNames.Invulnerability, skillStatus.skillLevel)
        invincibilityTimer = invincibilityTimer + value
    end

    if lastFramePlayerHealth > playerHealth then
        m_camera:StartShakeWithUnit(1, 0)
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), PLAYER_INVINCIBLE_BEHAVIOUR)

        m_playerInvincibilityTimer = invincibilityTimer
        m_playerDamageUiFlashCount = PlayerDamageFlashCount
        m_playerDamageUiIsFlashOn = false

        -- Deflection
        local hasDeflectionPerk = m_perkDisplay:HasPerk(PerksMod.PerkNames.Deflection)
        if hasDeflectionPerk and m_roomEnemies ~= nil then
            local value = PerksMod.Perks[PerksMod.PerkNames.Deflection].value
            local roomEnemies = m_roomEnemies:GetRoomEnemies()
            local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
            local damageAmount = (lastFramePlayerHealth - playerHealth) * value
            
            for _, enemy in ipairs(roomEnemies) do
                if enemy:IsActive() then
                    local position = DCEI.GetUnitPosition2D(enemy:GetMainUnit())
                    local distanceFromPlayer = ExtensionFunction.VectorDistance(position, playerPosition)
                    local invincibleStack = DCEI.UnitBehaviorStackCount(enemy:GetMainUnit(), EnemyMod.EnemyInvincible)

                    if invincibleStack < 1 and distanceFromPlayer <= PlayerMod.PlayerDeflectionDistance then
                        ArcadeCore.DamageUnit(enemy:GetMainUnit(), damageAmount)
                        DCEI.ApplyBehaviorWithDuration(enemy:GetMainUnit(), EnemyMod.EnemyFlashBehviour, EnemyMod.EnemyFlashDuration, false)
                    end
                end
            end

            DCEI.ApplyBehavior(m_player:GetPlayerUnit(), PerksMod.Perks[PerksMod.PerkNames.Deflection].valueAlt)
        end

        -- Health Popup
        local healthDiff = lastFramePlayerHealth - playerHealth
        local position3d = DCEI.GetUnitPosition3D(m_player:GetPlayerUnit())
        local healthString = "<color=red>" .. tostring(math.floor(healthDiff)) .. "</color>"

        DCEI.ShowFloatingText(
            position3d, 
            healthString, 
            0.5, 0, 0.5, 
            {
                offset = {
                    up = 1.5,
                    right = 0,
                    front = 0
                }
            }
        )

    end

    if m_playerInvincibilityTimer > 0 then
        m_playerInvincibilityTimer = m_playerInvincibilityTimer - deltaTime

        if m_playerInvincibilityTimer <= 0 then
            DCEI.RemoveBehavior(m_player:GetPlayerUnit(), PLAYER_INVINCIBLE_BEHAVIOUR)
        end
    end
end

function HandleDashTimerEnded()
    local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())

    -- Forceful Landing
    local hasForcefulLanding = m_perkDisplay:HasPerk(PerksMod.PerkNames.ForcefulLanding)
    if hasForcefulLanding then
        local value = PerksMod.Perks[PerksMod.PerkNames.ForcefulLanding].value

        if m_roomEnemies ~= nil then
            m_roomEnemies:ForceStunEnemies(value, playerPosition, PlayerMod.PlayerLandStunDistance)
        end
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), PerksMod.Perks[PerksMod.PerkNames.ForcefulLanding].valueAlt)
    end

    -- Aggressive Landing
    local hasAgressiveLanding = m_perkDisplay:HasPerk(PerksMod.PerkNames.AggressiveLanding)
    if hasAgressiveLanding then
        local value = PerksMod.Perks[PerksMod.PerkNames.AggressiveLanding].value
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), PerksMod.Perks[PerksMod.PerkNames.AggressiveLanding].valueAlt)
        
        if m_roomEnemies ~= nil then
            local enemies = m_roomEnemies:GetRoomEnemies()
            for _, enemy in ipairs(enemies) do
                if enemy:IsActive() and ArcadeCore.UnitIsAlive(enemy:GetMainUnit()) then
                    local position = DCEI.GetUnitPosition2D(enemy:GetMainUnit())
                    local distanceFromPlayer = ExtensionFunction.VectorDistance(position, playerPosition)

                    if distanceFromPlayer <= PlayerMod.PlayerAggressiveLandDistance then
                        ArcadeCore.DamageUnit(enemy:GetMainUnit(), value)
                        DCEI.ApplyBehaviorWithDuration(enemy:GetMainUnit(), EnemyMod.EnemyFlashBehviour, EnemyMod.EnemyFlashDuration, false)
                    end
                end
            end
        end
    end
end

function CollectCoins()
    DCEI.LogMessage("Activating Coin Collection")

    -- If something else is required
    m_coinTimer = COIN_COLLECTION_TIME

    for _, unit in ipairs(m_droppedCoins) do
        DCEI.CastAbility(COIN_COLLECT_ABILITY, unit, m_player:GetPlayerUnit())
    end
end

function UpdateCoinsCollection(deltaTime)
    if m_coinTimer > 0 then
        m_coinTimer = m_coinTimer - deltaTime
        
        if m_coinTimer <= 0 then
            for _, oldUnits in ipairs(m_droppedCoins) do
                DCEI.RemoveUnit(oldUnits)
            end

            m_player:AddGold(#m_droppedCoins)
            DCEI.ApplyBehavior(m_player:GetPlayerUnit(), PlayerMod.PlayerCoinCollect)
            m_droppedCoins = {}

            DCEI.LogMessage("Destroyed Coin Units")
        end
    end
end

function UpdatePlayerBaseGold()
    local goldAmount = m_player:GetPlayerGold()
    local baseGold = SaveMod.GetBaseGold()

    if baseGold ~= nil then
        goldAmount = goldAmount + baseGold
    end

    SaveMod.SaveBaseGold(goldAmount)
    SaveMod.ForceClearPlayerGold()
end

-- #endregion Player Functions

-- #region UI Functions

function CreateBaseUIElements()
    m_uiRoot = DCEI.GetUiRoot()

    local bottomFrame = DCEI.NewFrame(m_uiRoot)
    local middleFrame = DCEI.NewFrame(m_uiRoot)
    local topFrame = DCEI.NewFrame(m_uiRoot)

    DCEI.SetMatchParent(bottomFrame, true, true)
    DCEI.SetMatchParent(middleFrame, true, true)
    DCEI.SetMatchParent(topFrame, true, true)

    m_uiBottomLayer = bottomFrame
    m_uiMiddleLayer = middleFrame
    m_uiTopLayer = topFrame

    local baseFrame = DCEI.NewHStack(m_uiMiddleLayer)
    DCEI.SetSpacing(baseFrame, 7)
    DCEI.SetLeftAlignmentInParent(baseFrame)
    DCEI.SetTopAlignmentInParent(baseFrame)
    DCEI.SetHorizontalOffsetInParent(baseFrame, 170)
    DCEI.SetVerticalOffsetInParent(baseFrame, -21)

    m_topStackUi = baseFrame
end

function CreateCollectiblesUI()
    m_collectiblesUi = CollectiblesUIManager:new(m_uiRoot)
end

function CreatePlayerDamageDisplay()
    local damageDisplay = DCEI.NewFrame(m_uiTopLayer)
    DCEI.SetMatchParent(damageDisplay, true, true)
    DCEI.SetBackgroundImage(damageDisplay, "ui_mask_blurry")
    DCEI.SetBackgroundImageColor(damageDisplay, 1, 1, 1, 0)

    m_damageDisplay = damageDisplay
end

function CreatePlayerGoldDisplay()
    local playerGoldStack = DCEI.NewHStack(m_uiMiddleLayer)
    DCEI.SetTopAlignmentInParent(playerGoldStack)
    DCEI.SetLeftAlignmentInParent(playerGoldStack)
    DCEI.SetPaddingTop(playerGoldStack, 21)
    DCEI.SetPaddingLeft(playerGoldStack, 21)
    DCEI.SetSpacing(playerGoldStack, 14)
    
    local playerGoldImage = DCEI.NewFrame(playerGoldStack)
    DCEI.SetMinSize(playerGoldImage, 50, 50)
    DCEI.SetBackgroundImage(playerGoldImage, "ui_ingame_coin")

    local playerGoldText = DCEI.NewText(playerGoldStack)
    DCEI.SetTextFontSize(playerGoldText, 30)
    DCEI.SetText(playerGoldText, 0)
    m_playerGoldDisplay = playerGoldText
end

function CreateDebugUI()
    local horizontalStack = DCEI.NewHStack(m_uiMiddleLayer)
    DCEI.SetTopAlignmentInParent(horizontalStack)
    DCEI.SetLeftAlignmentInParent(horizontalStack)
    DCEI.SetPaddingTop(horizontalStack, 21)
    DCEI.SetPaddingLeft(horizontalStack, 21)
    DCEI.SetSpacing(horizontalStack, 14)

    -- local characterButton = DCEI.NewButton(horizontalStack)
    -- DCEI.SetMinSize(characterButton, 50, 50)
    -- DCEI.SetBackgroundImage(characterButton, "icon_enhance_crusader_punish")
    -- DCEI.SetOnClickCallback(characterButton, HandleCharacterSwitch)

    -- local goldButton = DCEI.NewButton(horizontalStack)
    -- DCEI.SetMinSize(goldButton, 50, 54)
    -- DCEI.SetBackgroundImage(goldButton, "icon_affinity_gold")
    -- DCEI.SetOnClickCallback(goldButton, HandleGoldButtonClicked)

    -- local roomType = SaveMod.GetRoomName()
    -- if roomType == nil then
        -- Skill Tree
        -- local skillTreeButton = DCEI.NewButton(m_uiMiddleLayer)
        -- DCEI.SetMinSize(skillTreeButton, 50, 50)
        -- DCEI.SetBackgroundImage(skillTreeButton, "icon_enhance_repeater_bolashot")
        -- DCEI.SetOnClickCallback(skillTreeButton, HandleSkillTreeClick)
        -- DCEI.SetLeftAlignmentInParent(skillTreeButton)
        -- DCEI.SetTopAlignmentInParent(skillTreeButton)
        -- DCEI.SetHorizontalOffsetInParent(skillTreeButton, 21)
        -- DCEI.SetVerticalOffsetInParent(skillTreeButton, -250)

        -- Perks
        -- local perkButton = DCEI.NewButton(m_uiMiddleLayer)
        -- DCEI.SetMinSize(perkButton, 50, 50)
        -- DCEI.SetBackgroundImage(perkButton, "icon_enhance_leviathan_water_spout")
        -- DCEI.SetOnClickCallback(perkButton, HandlePerkButtonClicked)
        -- DCEI.SetLeftAlignmentInParent(perkButton)
        -- DCEI.SetTopAlignmentInParent(perkButton)
        -- DCEI.SetHorizontalOffsetInParent(perkButton, 100)
        -- DCEI.SetVerticalOffsetInParent(perkButton, -250)
    -- end
end

function UpdatePlayerDamageUI(deltaTime)
    if m_playerDamageUiFlashCount > 0 then
        m_playerDamageUiFlashTimer = m_playerDamageUiFlashTimer - deltaTime

        if m_playerDamageUiFlashTimer <= 0 then
            if m_playerDamageUiIsFlashOn then
                DCEI.SetBackgroundImageColor(m_damageDisplay, 1, 1, 1, 0) -- Hide the Image
                m_playerDamageUiFlashCount = m_playerDamageUiFlashCount - 1
            else
                DCEI.SetBackgroundImageColor(m_damageDisplay, 1, 0, 0, 1) -- Display a Red Image
            end

            m_playerDamageUiIsFlashOn = not m_playerDamageUiIsFlashOn

            if m_playerDamageUiFlashCount ~= 0 then
                m_playerDamageUiFlashTimer = PlayerDamageFlashTimer
            end
        end
    end
end

function HandleCharacterSwitch()
    local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
    
    m_player:Destroy()
    m_player = nil

    local playerType
    if UseMeleePlayer then
        playerType = 0
    else
        playerType = 1
    end
    
    m_player = Player:new(playerPosition.x, playerPosition.y, playerType, m_uiRoot, m_skillDisplay, m_perkDisplay)
    m_player:AddDashCallback(HandleDashTimerEnded)
    m_player:ShowPlayerUI()

    UseMeleePlayer = not UseMeleePlayer

    m_camera:UpdateTarget(m_player:GetPlayerUnit())
    m_player:SetPlayerCamera(m_camera)
end

function HandleGoldButtonClicked()
    if m_player ~= nil then
        m_player:AddGold(10)
        local maxHealth = DCEI.GetMaxHealth(m_player:GetPlayerUnit())
        DCEI.SetHealthValue(m_player:GetPlayerUnit(), maxHealth)
    end
end

function HandleSkillTreeClick()
    if m_skillDisplay ~= nil then
        m_skillDisplay:ShowSkillTree(m_player)
    end
end

function HandlePerkButtonClicked()
    if m_perkDisplay ~= nil then
        m_perkDisplay:ShowRandomPerks(m_player, m_roomGenerator)
    end
end

-- #endregion

-- #region Inventory Functions

function HandleInventoryUnitClicked(unit, unitName)
    if m_player == nil then
        DCEI.LogError("Player does not exist")
        return
    end

    local behaviourStack = DCEI.UnitBehaviorStackCount(unit, CollectibleDropped)
    local usedGold = false
    local itemCost

    if behaviourStack == 0 then
        local playerGold = m_player:GetPlayerGold()
        itemCost = InventoryCollectibles[unitName].itemCost

        -- Old Customer
        if m_perkDisplay:HasPerk(PerksMod.PerkNames.OldCustomer) then
            local value = PerksMod.Perks[PerksMod.PerkNames.OldCustomer].value
            local discountAmount = itemCost * value

            itemCost = itemCost - math.floor(discountAmount)
        end

        if playerGold < itemCost then
            DCEI.LogMessage("Item Name: " .. unitName .. ", Item Gold: " .. itemCost)
            DCEI.LogMessage("Not enough gold to buy!!!")
            return
        end

        usedGold = true
    end

    local success = m_inventory:CheckAndAddItemToSlot(unitName)
    if success then
        if not usedGold then
            local unitPosition = DCEI.GetUnitPosition2D(unit)
            local roomName
            local playerRow = BEGINNING_ROOM_MARKER
            local playerColumn = BEGINNING_ROOM_MARKER

            if m_isBeginningRoom then
                roomName = BEGINNING_ROOM_NAME
            else
                playerRow = m_roomGenerator.currentPlayerRow
                playerColumn = m_roomGenerator.currentPlayerColumn
                roomName = m_roomGenerator.roomMatrix[playerRow][playerColumn]
            end

            m_roomItemDrops:RemoveItemFromList(unitName, unitPosition.x, unitPosition.y, roomName, playerRow, playerColumn)

        else
            local row = m_roomGenerator.currentPlayerRow
            local column = m_roomGenerator.currentPlayerColumn

            m_roomGenerator:MarkMerchantItemAsBought(row, column, unitName)
            m_player:UseGold(itemCost)
        end

        DCEI.RemoveUnit(unit)
    else
        DCEI.LogError("Inventory is full!!!")
    end
end

function CreateInventoryUI()
    local horizontalStack = DCEI.NewHStack(m_uiMiddleLayer)
    DCEI.SetBottomAlignmentInParent(horizontalStack)
    DCEI.SetPaddingBottom(horizontalStack, 21)

    local inventoryItems = {}
    
    for i = 1, InventoryMod.InventoryMaxSlots do
        local inventoryItem = InventorySlot:new(
            "btn_yellow_invert", 
            "btn_grey_invert", 
            horizontalStack, 
            HandleInventorySlotClicked,
            HandleInventoryItemDropped
        )
        table.insert(inventoryItems, inventoryItem)
    end

    local inventory = Inventory:new(inventoryItems, m_skillDisplay)
    m_inventory = inventory
end

function LoadInventoryFromSave()
    -- This must be done after the player is created as the behaviours will be added to the player
    m_inventory:LoadInventory()
    
    m_inventoryIconDisplay = InventoryIconDisplay:new(m_topStackUi)
    local inventoryIcons = m_inventoryIconDisplay:GetCurrentIcons()

    for _, item in ipairs(inventoryIcons) do
        local itemName = item.itemName
        
        if itemName == InventoryCollectibleNames.CatalystPotion then
            local behaviourName = InventoryCollectibles[itemName].itemBehaviourName
            DCEI.ApplyBehaviorWithDuration(m_player:GetPlayerUnit(), behaviourName, item.currentRechargeTime, false)

        elseif itemName == InventoryCollectibleNames.SpeedPotion then
            local behaviourName = InventoryCollectibles[itemName].itemBehaviourName
            DCEI.ApplyBehaviorWithDuration(m_player:GetPlayerUnit(), behaviourName, item.currentRechargeTime, false)

        end
    end
end

function HandleInventoryItemDropped(itemName, inventorySlot)
    if itemName == "" then
        DCEI.LogMessage("Slot Already Empty")
        return
    end

    DropInventoryItemToWorld(itemName)

    inventorySlot:DropInventoryItem()
end

function HandleInventorySlotClicked(itemName, inventorySlot)
    if m_player == nil then
        return
    end

    if itemName == "" or itemName == nil then
        DCEI.LogMessage("Empty Inventory Slot")
        return
    end

    DCEI.LogMessage("Selected Item: " .. itemName)

    if itemName == InventoryCollectibleNames.HealthPotion then
        local healthAmount = InventoryCollectibles[itemName].value
        local potionBehaviour = InventoryCollectibles[itemName].itemBehaviourName

        -- Alchemist (Health Potion)
        if m_perkDisplay:HasPerk(PerksMod.PerkNames.Alchemist) then
            local value = PerksMod.Perks[PerksMod.PerkNames.Alchemist].value
            local buffedAmount = healthAmount * value

            healthAmount = healthAmount + buffedAmount
        end

        DCEI.LogMessage("Adding Player Health: " .. healthAmount)
        DCEI.AddHealth(m_player:GetPlayerUnit(), healthAmount)
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), potionBehaviour)
        
        inventorySlot:UseItem()
        
    elseif itemName == InventoryCollectibleNames.Bomb then
        local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
        local bombUnitName = InventoryCollectibles[itemName].itemBombName

        DCEI.LogMessage("Deploying Bomb...")
        DCEI.CreateUnit(0, 0, bombUnitName, playerPosition.x, playerPosition.y)

        inventorySlot:UseItem()

    elseif itemName == InventoryCollectibleNames.CatalystPotion then
        local duration = InventoryCollectibles[itemName].value
        local behaviourName = InventoryCollectibles[itemName].itemBehaviourName

        -- Alchemist (Catalyst Potion)
        if m_perkDisplay:HasPerk(PerksMod.PerkNames.Alchemist) then
            local value = PerksMod.Perks[PerksMod.PerkNames.Alchemist].value
            local buffedAmount = duration * value

            duration = duration + buffedAmount
        end

        DCEI.ApplyBehaviorWithDuration(m_player:GetPlayerUnit(), behaviourName, duration, false)
        m_inventoryIconDisplay:AddIconDisplay(itemName, duration, duration)

        inventorySlot:UseItem()

    elseif itemName == InventoryCollectibleNames.SpeedPotion then
        local duration = InventoryCollectibles[itemName].value
        local behaviourName = InventoryCollectibles[itemName].itemBehaviourName

        -- Alchemist (Catalyst Potion)
        if m_perkDisplay:HasPerk(PerksMod.PerkNames.Alchemist) then
            local value = PerksMod.Perks[PerksMod.PerkNames.Alchemist].value
            local buffedAmount = duration * value

            duration = duration + buffedAmount
        end

        DCEI.ApplyBehaviorWithDuration(m_player:GetPlayerUnit(), behaviourName, duration, false)
        m_inventoryIconDisplay:AddIconDisplay(itemName, duration, duration)

        inventorySlot:UseItem()

    else
        DropInventoryItemToWorld(itemName)

        inventorySlot:DropInventoryItem()
    end
end

function DropInventoryItemToWorld(itemName)
    if itemName == "" or itemName == nil then
        return
    end

    local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
    local item = DCEI.CreateUnit(1, 1, itemName, playerPosition.x, playerPosition.y)
    DCEI.ApplyBehavior(item, CollectibleDropped)

    local roomName
    local playerRow = BEGINNING_ROOM_MARKER
    local playerColumn = BEGINNING_ROOM_MARKER

    if m_isBeginningRoom then
        roomName = BEGINNING_ROOM_NAME
    else
        playerRow = m_roomGenerator.currentPlayerRow
        playerColumn = m_roomGenerator.currentPlayerColumn
        roomName = m_roomGenerator.roomMatrix[playerRow][playerColumn]
    end

    m_roomItemDrops:AddItemToList(itemName, playerPosition.x, playerPosition.y, roomName, playerRow, playerColumn)
    m_collectiblesUi:AddNewUI(m_uiRoot, item, itemName)
end

-- #endregion Inventory Functions

-- #region Skill Tree Functions

function SkillUnlockedCallback(skillName)
    local skillStatus = m_skillDisplay.hexGenerator:GetSkillStatus(skillName)
    if not skillStatus.isUnlocked then
        return
    end

    DCEI.LogMessage("Main Callback. Skill: " .. skillName)
    local value = SkillTreeMod.GetSkillValue(skillName, skillStatus.skillLevel)

    if skillName == SkillTreeMod.SkillNames.Preplan then
        local exitRoomRow = m_roomGenerator.exitRoomRow
        local exitRoomColumn = m_roomGenerator.exitRoomColumn

        m_roomGenerator:MarkRoomAtPositionVisited(exitRoomRow, exitRoomColumn)
        m_roomGenerator:PrintRoomVisitedMatrix()
        DCEI.LogMessage("Exit Room Unlocked")

    elseif skillName == SkillTreeMod.SkillNames.Arsenal then
        m_perkDisplay:ClearPerkMark()
        m_perkDisplay:Save()
    end
end

-- #endregion Skill Tree Functions

-- #region Perk Functions

function LoadAndSetupPerks()
    m_perkDisplay = PerkDisplay:new(m_uiTopLayer, m_topStackUi)
    m_perkDisplay:AddCallback(HandlePerkActivatedCallback)
end

function CheckAndSpawnPerks()
    if m_isBeginningRoom then
        -- Arsenal
        local arsenalStatus = m_skillDisplay.hexGenerator:GetSkillStatus(SkillTreeMod.SkillNames.Arsenal)
        if not arsenalStatus.isUnlocked then
            m_perkDisplay:MarkPerkDisplayed()
            m_perkDisplay:Save()
        end

        m_perkDisplay:SetPerkValue(PerksMod.PerkNames.HelmOfValor, m_helmOfValorTimeRemaining)
    end

    if not m_isBeginningRoom and not m_perkDisplay:GetDisplayedInRound() then
        m_perkDisplay:ShowRandomPerks(m_player, m_roomGenerator)
    end

    if m_player == nil then
        return
    end

    for _, perkName in pairs(PerksMod.PerkNames) do
        if not m_perkDisplay:HasPerk(perkName) then
            goto continue
        end

        -- Swift Hands
        if perkName == PerksMod.PerkNames.SwiftHands then
            DCEI.ApplyBehavior(m_player:GetPlayerUnit(), PerksMod.Perks[perkName].value)

        -- Helm Of Valor
        elseif perkName == PerksMod.PerkNames.HelmOfValor then
            m_playerHasHelmOfValor = true
            m_helmOfValorActive = false

            local helmOfValorTimer = m_perkDisplay:GetPerkValue(PerksMod.PerkNames.HelmOfValor)
            if helmOfValorTimer ~= nil then
                m_helmOfValorTimeRemaining = helmOfValorTimer
                m_perkDisplay:ActivatePerkRecharge(perkName, m_helmOfValorTimeRemaining, PerksMod.Perks[PerksMod.PerkNames.HelmOfValor].value)
            else
                m_helmOfValorTimeRemaining = 0
            end

        end

        ::continue::
    end
end

function CheckAndActivatePerkRoom()
    if m_isBeginningRoom then
        return
    end

    local roomName = SaveMod.GetRoomName()

    if RoomMod.IsSecretRoom(roomName) and not m_roomGenerator.challengeRoomCleared then
        local spawnUnit = DCEI.FindUnit(SPAWN_MARKER_UNIT)
        local spawnPosition = DCEI.GetUnitPosition2D(spawnUnit)
        m_perkChest = DCEI.CreateUnit(1, 1, PerksMod.PerkChest, spawnPosition.x, spawnPosition.y)
    end
end

function HandlePerkActivatedCallback(perkName)
    if m_player == nil then
        return
    end

    -- Swift Hands
    if perkName == PerksMod.PerkNames.SwiftHands then
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), PerksMod.Perks[perkName].value)

    -- Helm of Valor
    elseif perkName == PerksMod.PerkNames.HelmOfValor then
        m_playerHasHelmOfValor = true
        m_helmOfValorActive = false
        m_helmOfValorTimeRemaining = 0

    end

    if m_perkSelecting then
        DCEI.TriggerAddTimerEventElapsed(
            function()
                ActivateChallengeRoom()
            end,
            PerksMod.PerkDelayedEnemySpawn
        )
    end
end

function UpdatePerkChestCollection()
    if m_perkChest == nil then
        return
    end

    local unitPosition = DCEI.GetUnitPosition2D(m_perkChest)
    local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())

    local distance = ExtensionFunction.VectorDistance(unitPosition, playerPosition)
    if distance > PerksMod.PerkChestDistance or m_perkSelecting then
        return
    end

    if m_perkDisplay ~= nil then
        m_perkSelecting = true
        DCEI.CastAbilityAtPosition(PerksMod.PerkChestOpen, m_perkChest, unitPosition.x, unitPosition.y)

        DCEI.TriggerAddTimerEventElapsed(
            function()
                m_perkDisplay:ShowRandomPerks(m_player, m_roomGenerator)
            end,
            PerksMod.PerkChestWaitTime
        )

        DCEI.TriggerAddTimerEventElapsed(
            function()
                DCEI.RemoveUnit(m_perkChest)
                m_perkChest = nil
            end,
            PerksMod.PerkChestWaitTime + PerksMod.PerkChestDestroyTime
        )
    else
        DCEI.LogError("Perk Display Not Initialized!!!")
    end
end

function ActivateChallengeRoom()
    ActivateDoorCloseAnimations()

    DCEI.RemoveBehavior(m_player:GetPlayerUnit(), PlayerMod.PlayerOutOfCombatSpeed)
    m_roomEnemies = RoomEnemies:newChallengeRoom(m_player:GetPlayerUnit(), m_roomGenerator, m_skillDisplay, m_roomLevel)
    
    m_doorOpenAnimPlayed = false
    m_roomEnemiesCleared = false
end

-- #endregion Perk Functions

-- #endregion Utility Fuctions

-- This function should be run before Start...
function mod.ActivateMerchantRooms()
    local spawnUnits = DCEI.FindUnits(SPAWN_MARKER_UNIT)
    local row = m_roomGenerator.currentPlayerRow
    local column = m_roomGenerator.currentPlayerColumn

    local items = m_roomGenerator:GetMerchantRoomData(row, column)
    if items == nil then
        DCEI.LogError("Invalid Merchant Room!!!")
        return
    end
    
    for i, unit in ipairs(spawnUnits) do
        local unitPosition = DCEI.GetUnitPosition2D(unit)
        DCEI.RemoveUnit(unit)
        
        local item = items[i]
        if not item.bought then
            local itemInstance = DCEI.CreateUnit(1, 1, item.itemName, unitPosition.x, unitPosition.y)
            m_collectiblesUi:AddNewUI(m_uiRoot, itemInstance, item.itemName)
        end
    end
end

mod.SpawnMarkerUnit = SPAWN_MARKER_UNIT
mod.RoomName = ROOM_NAME

return mod