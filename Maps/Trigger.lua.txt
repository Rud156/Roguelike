-- #region Mods and Includes
local ArcadeCore = GameModules["Arcade/Core"] -- Maybe be required
local ExtensionFunction = GameModules["Mods/ExtensionFunctionMod"]
local InventoryMod = GameModules["Mods/InventoryMod"]
local EnemyMod = GameModules["Mods/EnemyMod"]
local RoomMod = GameModules["Mods/NewRoomMod"]
local CameraMod = GameModules["Mods/CameraMod"]
local UtilClassMod = GameModules["Mods/UtilClassMod"]
local PlayerMod = GameModules["Mods/PlayerMod"]
local UiUtilMod = GameModules["Mods/UiUtilMod"]
local SkillTreeMod = GameModules["Mods/SkillTreeMod"]
local SaveMod = GameModules["Mods/SaveMod"]

InventoryMod.VectorDistance = ExtensionFunction.VectorDistance
InventoryMod.SaveInventorySlotData = SaveMod.SaveInventorySlotData
InventoryMod.GetInventorySlotData = SaveMod.GetInventorySlotData
InventoryMod.ClearInventorySlotData = SaveMod.ClearInventorySlotData
local Inventory = InventoryMod.Inventory
local InventorySlot = InventoryMod.InventorySlot
local InventoryCollectibles = InventoryMod.InventoryCollectibles
local InventoryCollectiblesName = InventoryMod.InventoryCollectiblesName
local CollectiblesUIManager = InventoryMod.CollectiblesUIManager

EnemyMod.VectorDistance = ExtensionFunction.VectorDistance
EnemyMod.VectorSubtract = ExtensionFunction.VectorSubtract
EnemyMod.VectorLerp = ExtensionFunction.VectorLerp
EnemyMod.LerpAngleDeg = ExtensionFunction.LerpAngleDeg
EnemyMod.NormalizeUnitRotation = ExtensionFunction.NormalizeUnitRotation
EnemyMod.ShuffleTable = ExtensionFunction.ShuffleTable
EnemyMod.WalkableTextureId = RoomMod.WalkableTextureId
local EnemyHobGoblin = EnemyMod.EnemyHobGoblin
local EnemyGoblinChef = EnemyMod.EnemyGoblinChef
local EnemyGoblin = EnemyMod.EnemyGoblin
local EnemyGoblinSapper = EnemyMod.EnemyGoblinSapper
local EnemyOoze = EnemyMod.EnemyOoze
local EnemyGoblinMiner = EnemyMod.EnemyGoblinMiner

RoomMod.EnemyHobGoblin = EnemyHobGoblin
RoomMod.EnemyGoblinChef = EnemyGoblinChef
RoomMod.EnemyGoblin = EnemyGoblin
RoomMod.EnemyGoblinSapper = EnemyGoblinSapper
RoomMod.EnemyOoze = EnemyOoze
RoomMod.EnemyGoblinMiner = EnemyGoblinMiner
RoomMod.InventoryCollectiblesName = InventoryCollectiblesName
RoomMod.split = ExtensionFunction.split
RoomMod.IsEqual = ExtensionFunction.IsEqual
RoomMod.ToBoolean = ExtensionFunction.ToBoolean
RoomMod.ArrayHasValue = ExtensionFunction.ArrayHasValue
RoomMod.VectorDistance = ExtensionFunction.VectorDistance
RoomMod.ShuffleTable = ExtensionFunction.ShuffleTable
RoomMod.SaveRoomData = SaveMod.SaveRoomData
RoomMod.GetRoomData = SaveMod.GetRoomData
RoomMod.ClearRoomData = SaveMod.ClearRoomData
RoomMod.SaveItemDrops = SaveMod.SaveItemDrops
RoomMod.GetItemDrops = SaveMod.GetItemDrops
RoomMod.ClearItemDrops = SaveMod.ClearItemDrops
local RoomGenerator = RoomMod.RoomGenerator
local RoomEnemies = RoomMod.RoomEnemies
local MiniMap = RoomMod.MiniMap
local RoomItemDrops = RoomMod.ItemDrops

local Camera = CameraMod.Camera
local Fader = UiUtilMod.Fader

SkillTreeMod.IsEqual = ExtensionFunction.IsEqual
SkillTreeMod.split = ExtensionFunction.split
SkillTreeMod.ToBoolean = ExtensionFunction.ToBoolean
SkillTreeMod.SaveSkillTree = SaveMod.SaveSkillTree
SkillTreeMod.GetSkillTree = SaveMod.GetSkillTree
SkillTreeMod.ClearSkillTree = SaveMod.ClearSkillTree
local SkillDisplay = SkillTreeMod.SkillDisplay

PlayerMod.VectorSubtract = ExtensionFunction.VectorSubtract
PlayerMod.NormalizeUnitRotation = ExtensionFunction.NormalizeUnitRotation
PlayerMod.GetSkillValue = SkillTreeMod.GetSkillValue
PlayerMod.SkillNames = SkillTreeMod.SkillNames
PlayerMod.SavePlayerData = SaveMod.SavePlayerData
PlayerMod.GetPlayerData = SaveMod.GetPlayerData
PlayerMod.ClearPlayerData = SaveMod.ClearPlayerData
local Player = PlayerMod.Player

local Rect = UtilClassMod.Rect
-- #endregion Mods and Includes

local mod = {}


-- #region Constants
local WORLD_WIDTH = 30
local WORLD_HEIGHT = 30
local GAME_LOOP_RATE = 0.0625
local CENTER_POSITIONS_MAX_COUNT = 10

local LEFT = "L"
local RIGHT = "R"
local TOP = "T"
local BOTTOM = "B"
local LAST_DIRECTION = "LastDirection"

local MERCHANT_MALE = "__SpawnMerchantMaleUnit"
local MERCHANT_FEMALE = "__SpawnMerchantFemaleUnit"

local DEBUG_UNIT = "__DebugMarkerUnit"
local SPAWN_MARKER_UNIT = "__SpawnMarkerUnit"

local EXIT_DOORWAY = "_DungeonDoorway"
local EXIT_DOORWAY_OPEN = "_DungeonDoorway_Open"
local EXIT_LEFT_ROTATION = -90
local EXIT_RIGHT_ROTATION = 90
local EXIT_TOP_ROTATION = 0
local EXIT_BOTTOM_ROTATION = -180

local PLAYER_COLLISION_BEHAVIOUR = "_CollisionDetection_PlayerCharacter"
local PLAYER_INVINCIBLE_BEHAVIOUR = "_PlayerCharacter_Damage_Invincible"
local PLAYERCHARACTER_MISSILE_REACHED = "_PlayerCharacter_Missile_Reached"
local PLAYERCHARACTER_DAMAGED = "_PlayerCharacter_Damaged"
local PLAYER_NAME_RANGED = "_PlayerCharacter_Ranged"
local PLAYER_NAME_MELEE = "_PlayerCharacter_Melee"

-- Enemy
local ENEMY_STUNNED_BEHAVIOUR = "_Enemy_Stunned"
local GOBLIN_MINER_MISSILE_BEHAVIOUR = "_Enemy_GoblinMiner_Missile_Reached"

-- Collectibles
local COLLECTIBLE_STRING = "_Collectible"
local COLLECTIBLE_BOOTS_OF_SPEED = "_Collectible_Boots_Of_Speed"
local COLLECTIBLE_HAMMER_OF_ATTACK = "_Collectible_Hammer_Of_Attack"
local COLLECTIBLE_POTION = "_Collectible_Potion"
local COLLECTIBLE_BOMB = "_Collectible_Bomb"
local COLLECTIBLE_DROPPED_BEHAVIOUR = "_Collectible_Dropped"

local COLLECTIBLE_HELM_OF_VALOR = "_Collectible_Helm_Of_Valor"
local COLLECTIBLE_HELM_OF_VALOR_TIMER = 10

-- Rooms
local BEGINNING_ROOM_NAME = "StartingBase"
local BEGINNING_ROOM_MARKER = -1
local BEGINNING_ROOM_PATH = "Mods/StartingBase"
local DOOR_OPEN_ANIM = "_Room_Exit_Open"
local DOOR_CLOSE_ANIM = "_Room_Exit_Close"
local ROOM_EXIT_DOOR = "_Room_Exit"
local ROOM_NAME = "RoomName"
local ROOM_LEVEL_STRING = "RoomLevel"
local ROOM_LEVEL_MAX = 3

-- #endregion Constants

-- Public Variables
-- Player
local PlayerInvincibleTimer = 3
local PlayerDamageFlashCount = 1
local PlayerDamageFlashTimer = 0.15
local UseMeleePlayer = true
-- Fader
local FadeOutDelay = 0.1
-- Private Variables
-- Rooms
local m_roomGenerator
local m_roomEnemies
local m_roomItemDrops
local m_roomLevel = 1
local m_isBeginningRoom = false
local m_nextRoomTransitionActive = false
local m_doorOpenAnimPlayed = false
local m_roomEnemiesCleared = false
-- Player
local m_player
local m_leftSpawn
local m_rightSpawn
local m_topSpawn
local m_bottomSpawn
-- Player Health and Damage
local m_playerInvincibilityTimer = 0
local m_playerDamageUiFlashCount = 0
local m_playerDamageUiFlashTimer = 0
local m_playerDamageUiIsFlashOn = false
-- Helm Of Valor
local m_helmOfValorTimeRemaining = 0
local m_helmOfValorActive = false
local m_helmOfValorInInventory = false
-- Camera
local m_camera
-- UI
local m_uiRoot
local m_uiBottomLayer
local m_uiMiddleLayer
local m_uiTopLayer
local m_inventory
local m_damageDisplay
local m_playerGoldDisplay
local m_miniMap
local m_collectiblesUi
-- Random
local m_randomSeed
-- Scene Transition
local m_fader
local m_sceneTransitionActive = false
-- Skill Tree
local m_skillDisplay

-- #region LifeCycle Functions
function mod.Start(spawnPositionLeft, spawnPositionRight, spawnPositionTop, spawnPositionBottom)
    local randomSeed = os.time()
    DCEI.LogMessage("Random Seed: " .. randomSeed)
    math.randomseed(randomSeed)
    m_randomSeed = randomSeed

    m_leftSpawn = spawnPositionLeft
    m_rightSpawn = spawnPositionRight
    m_topSpawn = spawnPositionTop
    m_bottomSpawn = spawnPositionBottom

    -- Fader
    m_fader = Fader:new()
    m_sceneTransitionActive = true
    m_fader:StartFadeOut(
        FadeOutDelay, 
        function()
            m_player:ShowPlayerUI()
            m_sceneTransitionActive = false
        end
    )

    CreateBaseUIElements()
    CreatePlayerDamageDisplay()
    CreatePlayerGoldDisplay()
    ArcadeCore.HideDefaultUi()
    CreateInventoryUI()
    CreateDebugUI()
    CreateCollectiblesUI()

    m_skillDisplay = SkillDisplay:new(m_uiTopLayer)

    SpawnPlayerAndSetPosition()
    m_camera = Camera:new(m_player:GetPlayerUnit())
    m_player:SetPlayerCamera(m_camera)
    LoadInventoryFromSave() -- Load Inventory later as Player is required to apply effects
    CheckAndSpawnEntryDoor() -- This should be done later as the Player is required to be moved on the doorway
    CheckAndSpawnExitDoor()
    SpawnEnemiesAndCloseDoors()

    m_miniMap = MiniMap:new(m_uiMiddleLayer, m_roomGenerator)
    if m_isBeginningRoom then
        m_miniMap:DisableMiniMap()
    else
        m_miniMap:UpdateMiniMap()
    end
    
    -- Add Triggers At The End...
    DCEI.TriggerAddJoystickEvent(
        function()
            if m_sceneTransitionActive then
                return
            end

            local axes = DCEI.TriggeringJoystickAxes
            if m_player ~= nil then
                m_player:HandleJoystickMoved(axes)
            end
        end
    )
    DCEI.TriggerAddJoystickReleaseEvent(
        function()
            if m_sceneTransitionActive then
                return
            end

            if m_player ~= nil then
                m_player:HandleJoystickReleased()
            end
        end
    )
    DCEI.TriggerAddJoystickButtonEvent(0, 
        function()
            if m_sceneTransitionActive then
                return
            end

            local buttonId = DCEI.TriggeringJoystickButtonId
            local buttonEvent = DCEI.TriggeringJoystickButtonEventType
            
            if m_player ~= nil then
                m_player:HandleJoystickButtonClicked(buttonId, buttonEvent, m_roomEnemies)
            end
        end, 
        { icon = "icon_enhance_crusader_zeal" }
    )
    DCEI.TriggerAddJoystickButtonEvent(1, 
        function()
            if m_sceneTransitionActive then
                return
            end

            local buttonId = DCEI.TriggeringJoystickButtonId
            local buttonEvent = DCEI.TriggeringJoystickButtonEventType
            
            if m_player ~= nil then
                m_player:HandleJoystickButtonClicked(buttonId, buttonEvent, m_roomEnemies)
            end
        end, 
        { icon = "icon_enhance_stoneguard_bash" }
    )
    DCEI.TriggerAddJoystickButtonEvent(2, 
        function()
            if m_sceneTransitionActive then
                return
            end

            local buttonId = DCEI.TriggeringJoystickButtonId
            local buttonEvent = DCEI.TriggeringJoystickButtonEventType

            if m_player ~= nil then
                m_player:HandleJoystickButtonClicked(buttonId, buttonEvent, m_roomEnemies)
            end
        end, 
        { icon = "icon_spell_angelic_host" }
    )

    DCEI.TriggerAddUnitDiedEvent(DCEI.UnitAny, HandleUnitDied)
    DCEI.TriggerAddBehaviorAddEvent(DCEI.UnitAny, HandleBehaviourAdded)
    DCEI.TriggerAddUnitSelectedEvent(DCEI.UnitAny, HandleUnitSelected)

    DCEI.TriggerAddTimerEventPeriodicIndefinite(Update, GAME_LOOP_RATE)
end

function Update()

    if m_sceneTransitionActive then
        m_fader:Update(GAME_LOOP_RATE)

        -- Update the camera to set the final state earlier
        if m_player ~= nil and m_player:GetPlayerUnit() ~= nil then
            m_camera:Update(GAME_LOOP_RATE)
        end

        return
    end

    UpdatePlayerHealth(GAME_LOOP_RATE) -- Update Health first otherwise the Player will have current health as LastFramePlayerHealth
    
    if m_player ~= nil then
        m_player:Update(GAME_LOOP_RATE)
        local playerGoldAmount = m_player:GetPlayerGold()
        DCEI.SetText(m_playerGoldDisplay,  tostring(playerGoldAmount))

        local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
        m_collectiblesUi:Update(GAME_LOOP_RATE, playerPosition)
    end

    if m_roomEnemies ~= nil and m_player ~= nil then
        m_roomEnemies:UpdateEnemies(GAME_LOOP_RATE, m_player:GetPlayerUnit())
        
        local enemy = m_roomEnemies:GetActiveNearestEnemy(m_player:GetPlayerUnit())
        m_player:LookTowardsEnemy(enemy)
    end

    UpdatePlayerDamageUI(GAME_LOOP_RATE)
    m_inventory:UpdateSlots(GAME_LOOP_RATE)

    if m_player ~= nil and m_player:GetPlayerUnit() ~= nil then
        m_camera:Update(GAME_LOOP_RATE)
    end

    if m_helmOfValorInInventory then
        if not m_helmOfValorActive then
            m_helmOfValorTimeRemaining = m_helmOfValorTimeRemaining - GAME_LOOP_RATE

            if m_helmOfValorTimeRemaining <= 0 then
                m_helmOfValorActive = true
                DCEI.ApplyBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[COLLECTIBLE_HELM_OF_VALOR].itemBehaviourName)
            end
        end
    end

    if not m_doorOpenAnimPlayed then
        if m_roomEnemies ~= nil then
            if m_roomEnemies:IsRoomClear() then
                m_doorOpenAnimPlayed = true
                m_roomEnemiesCleared = true

                if not m_isBeginningRoom then
                    m_roomGenerator:MarkRoomAtPlayerPositionClear()
                end
                ActivateDoorOpenAnimations()
            end
        else
            -- This will generally trigger on Merchant Rooms
            -- Does not matter if it triggers on already cleared rooms
            if not m_isBeginningRoom then
                m_roomGenerator:MarkRoomAtPlayerPositionVisited()
            end

            m_doorOpenAnimPlayed = true
            m_roomEnemiesCleared = true
            ActivateDoorOpenAnimations()
        end
    end
end

-- #endregion LifeCycle Functions

-- #region Event Functions

-- #region Unit Events
function HandleUnitDied()
    if m_sceneTransitionActive then
        return
    end

    local unit = DCEI.TriggeringUnit

    -- Just go through all rooms and trigger it
    -- The correct one will automatically trigger

    local unitName = DCEI.UnitName(unit)
    if unitName == PLAYER_NAME_RANGED or unitName == PLAYER_NAME_MELEE and not m_nextRoomTransitionActive then
        m_player:ClearData()
        m_player:Destroy()
        m_player = nil

        m_nextRoomTransitionActive = true
        m_sceneTransitionActive = true
        m_fader:StartFadeIn(
            0, 
            function()
                DisplayGameOverSequence(false)
            end
        )

    elseif m_roomEnemies ~= nil then
        local goldAmount = m_roomEnemies:RemoveDeadEnemy(unit)
        if goldAmount ~= -1 then
            m_player:AddGold(goldAmount)
        end
    end
end

function HandleBehaviourAdded()
    if m_sceneTransitionActive then
        return
    end

    local behaviourName = DCEI.TriggeringBehaviorName
    local unit = DCEI.TriggeringUnit
    local unitName = DCEI.UnitName(unit)

    if behaviourName == PLAYER_COLLISION_BEHAVIOUR then
        if unitName == ROOM_EXIT_DOOR then
            if m_nextRoomTransitionActive or not m_roomEnemiesCleared then
                return
            end

            m_nextRoomTransitionActive = true
            m_sceneTransitionActive = true
            m_player:HidePlayerUI()

            SaveNextRoomData()
            m_fader:StartFadeIn(
                0,
                function()
                    DisplayGameOverSequence(true)
                end
            )

        elseif unitName == EXIT_DOORWAY and m_isBeginningRoom then
            if m_nextRoomTransitionActive or not m_roomEnemiesCleared then
                return
            end

            m_nextRoomTransitionActive = true
            m_sceneTransitionActive = true
            m_player:HidePlayerUI()

            SaveNextRoomData()
            m_fader:StartFadeIn(
                0,
                function()
                    DisplayGameOverSequence(true)
                end
            )

        elseif unitName == EXIT_DOORWAY then
            if m_roomGenerator.currentPlayerRow == m_roomGenerator.exitRoomRow and m_roomGenerator.currentPlayerColumn == m_roomGenerator.exitRoomColumn then
                if m_nextRoomTransitionActive or not m_roomEnemiesCleared then
                    return
                end

                m_nextRoomTransitionActive = true
                m_sceneTransitionActive = true
                m_player:HidePlayerUI()

                m_fader:StartFadeIn(0, UpdateCollisionWithExitDoor)
            end
        end

    elseif behaviourName == PLAYERCHARACTER_MISSILE_REACHED then
        DCEI.LogMessage("Missile Reached Position")
        local missilePosition = DCEI.GetUnitPosition2D(unit)

        m_player:SetPlayerPosition(missilePosition.x, missilePosition.y)
        m_player:SetDashInActive()

    elseif behaviourName == GOBLIN_MINER_MISSILE_BEHAVIOUR then
        DCEI.LogMessage("Miner Missile Reached")
        local missilePosition = DCEI.GetUnitPosition2D(unit)

        if m_roomEnemies ~= nil then
            m_roomEnemies:ForceSetUnitPosition(missilePosition)
        end

    elseif behaviourName == ENEMY_STUNNED_BEHAVIOUR then
        DCEI.LogMessage("Enemy Stun Behaviour Added")
        if m_roomEnemies ~= nil then
            m_roomEnemies:UpdateEnemyStunState(unit)
        end

    elseif behaviourName == PLAYERCHARACTER_DAMAGED then
        if unitName == PLAYER_NAME_MELEE or unitName == PLAYER_NAME_RANGED then
            if m_helmOfValorActive and m_helmOfValorInInventory then
                DCEI.RemoveBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[COLLECTIBLE_HELM_OF_VALOR].itemBehaviourName)
                m_helmOfValorActive = false
                m_helmOfValorTimeRemaining = COLLECTIBLE_HELM_OF_VALOR_TIMER
            
                m_inventory:ActivateInventorySlotRecharge(InventoryCollectibles[COLLECTIBLE_HELM_OF_VALOR].itemName, COLLECTIBLE_HELM_OF_VALOR_TIMER)
            end
        end
    end
end

function HandleUnitSelected()
    if m_sceneTransitionActive then
        return
    end
    
    local unit = DCEI.TriggeringUnit
    local unitName = DCEI.UnitName(unit)

    DCEI.LogMessage("Selected Unit: " .. unitName)

    -- Add Collectibles to Inventory if successful
    -- Then destroy the unit
    if string.match(unitName, COLLECTIBLE_STRING) then
        HandleInventoryUnitClicked(unit, unitName)
    end

    DCEI.DeselectUnit(unit)
end
-- #endregion Unit Events

-- #endregion Event Functions

-- #region Utility Fuctions

-- #region Common Game Spawn

function SpawnPlayerAndSetPosition()
    -- Load/Generate Room Data
    local roomType = SaveMod.GetRoomName()
    local roomLevel = SaveMod.GetRoomLevel()

    if roomLevel ~= nil then
        m_roomLevel = roomLevel
    else -- Save the new level if it does not exists...
        SaveMod.SaveMainMapRoomLevel(m_roomLevel)
    end

    if roomType == nil then -- This should be the beginning room
        DCEI.LogMessage("Beginning Room. Generating Rooms")

        m_roomGenerator = RoomGenerator:new(m_randomSeed, m_roomLevel)
        m_isBeginningRoom = true
    else
        DCEI.LogMessage("Loading Old Room Data")

        m_roomGenerator = RoomGenerator:LoadRoomStructure()
        m_randomSeed = m_roomGenerator:GetRandomSeed()

        math.randomseed(m_randomSeed)
        m_isBeginningRoom = false
    end
    -- Load/Generate Room Data

    -- Spawn Player
    local playerType
    if UseMeleePlayer then
        playerType = 0
    else
        playerType = 1
    end

    local spawnPosition
    local spawnDirection = SaveMod.GetRoomLastDirection()

    if spawnDirection == LEFT then
        spawnPosition = m_leftSpawn
    elseif spawnDirection == RIGHT then
        spawnPosition = m_rightSpawn
    elseif spawnDirection == TOP then
        spawnPosition = m_topSpawn
    elseif spawnDirection == BOTTOM then
        spawnPosition = m_bottomSpawn
    else
        if m_leftSpawn ~= nil then
            spawnPosition = m_leftSpawn
        elseif m_rightSpawn ~= nil then
            spawnPosition = m_rightSpawn
        elseif m_topSpawn ~= nil then
            spawnPosition = m_topSpawn
        else
            spawnPosition = m_bottomSpawn
        end
    end

    m_player = Player:new(spawnPosition.x, spawnPosition.y, playerType, m_uiRoot, m_skillDisplay)
    -- Spawn Player

    SpawnItemDrops()
    ApplyInventoryBehaviours()
end

function SpawnItemDrops()
    m_roomItemDrops = RoomItemDrops:new()
    local roomName
    local playerRow = BEGINNING_ROOM_MARKER
    local playerColumn = BEGINNING_ROOM_MARKER

    if m_isBeginningRoom then
        roomName = BEGINNING_ROOM_NAME
    else
        playerRow = m_roomGenerator.currentPlayerRow
        playerColumn = m_roomGenerator.currentPlayerColumn
        roomName = m_roomGenerator.roomMatrix[playerRow][playerColumn]
    end

    local roomItems = m_roomItemDrops:GetItemsInRoom(roomName, playerRow, playerColumn)
    for _, item in ipairs(roomItems) do
        local xPosition = item.xPosition
        local yPosition = item.yPosition
        local itemName = item.itemName

        local item = DCEI.CreateUnit(1, 1, itemName, xPosition, yPosition)
        DCEI.ApplyBehavior(item, COLLECTIBLE_DROPPED_BEHAVIOUR)
        m_collectiblesUi:AddNewUI(m_uiRoot, item, itemName)
    end
end

function SpawnEnemiesAndCloseDoors()
    local playerRow = m_roomGenerator.currentPlayerRow
    local playerColumn = m_roomGenerator.currentPlayerColumn

    local exitRow = m_roomGenerator.exitRoomRow
    local exitColumn = m_roomGenerator.exitRoomColumn

    local spawnEnemies = true

    if m_isBeginningRoom then
        spawnEnemies = false
    end

    if not m_isBeginningRoom and not m_roomGenerator:IsPlayerRoomCleared() then
        if playerRow == exitRow and playerColumn == exitColumn and m_roomLevel == ROOM_LEVEL_MAX then
            m_roomEnemies = RoomEnemies:new(m_player:GetPlayerUnit(), m_roomGenerator, m_roomLevel, true)
        else
            m_roomEnemies = RoomEnemies:new(m_player:GetPlayerUnit(), m_roomGenerator, m_roomLevel, false)
        end
        ActivateDoorCloseAnimations()
    end
end

function ActivateDoorCloseAnimations()
    DCEI.LogMessage("Playing Close Door Animations")

    local roomDoors = DCEI.FindUnits(ROOM_EXIT_DOOR)
    DCEI.LogMessage("Total Doors: " .. #roomDoors)

    for _, door in ipairs(roomDoors) do
        DCEI.LogMessage("Casting Close Ability")
        DCEI.CastAbility(DOOR_CLOSE_ANIM, door, door)
    end
end

function ActivateDoorOpenAnimations()
    DCEI.LogMessage("Playing Open Door Animations")

    local roomDoors = DCEI.FindUnits(ROOM_EXIT_DOOR)
    DCEI.LogMessage("Total Doors: " .. #roomDoors)

    for _, door in ipairs(roomDoors) do
        DCEI.LogMessage("Casting Open Ability")
        DCEI.CastAbility(DOOR_OPEN_ANIM, door, door)
    end

    local playerRow = m_roomGenerator.currentPlayerRow
    local playerColumn = m_roomGenerator.currentPlayerColumn

    local spawnRoomRow = m_roomGenerator.spawnRoomRow
    local spawnRoomColumn = m_roomGenerator.spawnRoomColumn

    if playerRow ~= spawnRoomRow and playerColumn ~= spawnRoomColumn then
        local exitDoors = DCEI.FindUnits(EXIT_DOORWAY)
        for _, door in ipairs(exitDoors) do
            DCEI.ApplyBehavior(door, EXIT_DOORWAY_OPEN)
        end

    elseif m_isBeginningRoom then
        local exitDoors = DCEI.FindUnits(EXIT_DOORWAY)
        for _, door in ipairs(exitDoors) do
            DCEI.ApplyBehavior(door, EXIT_DOORWAY_OPEN)
        end
    end
end

-- #endregion Common Game Spawn

-- #region Doorways

function GetDoorsInDirection(doors, direction)
    local validDoors = {}

    for _, door in ipairs(doors) do
        local position = DCEI.GetUnitPosition2D(door)
        if position.x < RoomMod.GetMinDirectionPosition(true) and direction == LEFT then
            table.insert(validDoors, door)

        elseif position.x > RoomMod.GetMaxDirectionPosition(true) and direction == RIGHT then
            table.insert(validDoors, door)

        elseif position.y < RoomMod.GetMinDirectionPosition(false) and direction == BOTTOM then
            table.insert(validDoors, door)

        elseif position.y > RoomMod.GetMaxDirectionPosition(false) and direction == TOP then
            table.insert(validDoors, door)
        end
    end

    return validDoors
end

function GetNearestDoorFromCenter(validDoors)
    local nearestPosition = 999
    local nearestUnit = nil
    local worldCenter = DCEI.GetMapCenterPoint()

    for _, door in ipairs(validDoors) do
        local position = DCEI.GetUnitPosition2D(door)
        local distance = ExtensionFunction.VectorDistance(worldCenter, position)

        if distance < nearestPosition then
            nearestPosition = distance
            nearestUnit = door
        end
    end

    return nearestUnit
end

function CheckAndSpawnEntryDoor()
    local playerSpawnRow = m_roomGenerator.currentPlayerRow
    local playerSpawnColumn = m_roomGenerator.currentPlayerColumn

    local spawnRow = m_roomGenerator.spawnRoomRow
    local spawnColumn = m_roomGenerator.spawnRoomColumn

    if playerSpawnRow ~= spawnRow or playerSpawnColumn ~= spawnColumn or m_isBeginningRoom then
        return
    end

    local direction = m_roomGenerator.spawnRoomDoorDirection
    local roomExits = DCEI.FindUnits(ROOM_EXIT_DOOR)
    local validExits = GetDoorsInDirection(roomExits, direction)

    local validExit = GetNearestDoorFromCenter(validExits)
    local position = DCEI.GetUnitPosition2D(validExit)
    local newDoor = DCEI.CreateUnit(1, 1, EXIT_DOORWAY, position.x, position.y)

    if direction == LEFT then
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_LEFT_ROTATION, 0)
    elseif direction == RIGHT then
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_RIGHT_ROTATION, 0)
    elseif direction == TOP then
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_TOP_ROTATION, 0)
    else
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_BOTTOM_ROTATION, 0)
    end

    for _, exit in ipairs(validExits) do
        DCEI.RemoveUnit(exit)
    end

    local spawnDirection = SaveMod.GetRoomLastDirection()
    
    if spawnDirection == nil then
        spawnDirection = direction
        local spawnPosition

        if spawnDirection == LEFT then
            spawnPosition = m_leftSpawn
        elseif spawnDirection == RIGHT then
            spawnPosition = m_rightSpawn
        elseif spawnDirection == TOP then
            spawnPosition = m_topSpawn
        elseif spawnDirection == BOTTOM then
            spawnPosition = m_bottomSpawn
        end

        DCEI.SetUnitPosition2D(m_player:GetPlayerUnit(), spawnPosition.x, spawnPosition.y)
        DCEI.Move(m_player:GetPlayerUnit(), spawnPosition.x, spawnPosition.y)
    end
end

function CheckAndSpawnExitDoor()
    if m_isBeginningRoom then
        return
    end

    local playerSpawnRow = m_roomGenerator.currentPlayerRow
    local playerSpawnColumn = m_roomGenerator.currentPlayerColumn
    
    local exitRoomRow = m_roomGenerator.exitRoomRow
    local exitRoomColumn = m_roomGenerator.exitRoomColumn

    if playerSpawnRow ~= exitRoomRow or playerSpawnColumn ~= exitRoomColumn then
        return
    end

    local direction = m_roomGenerator.exitRoomDoorDirection
    local roomExits = DCEI.FindUnits(ROOM_EXIT_DOOR)
    local validExits = GetDoorsInDirection(roomExits, direction)

    local validExit = GetNearestDoorFromCenter(validExits)
    local position = DCEI.GetUnitPosition2D(validExit)
    local newDoor = DCEI.CreateUnit(1, 1, EXIT_DOORWAY, position.x, position.y)

    if direction == LEFT then
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_LEFT_ROTATION, 0)
    elseif direction == RIGHT then
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_RIGHT_ROTATION, 0)
    elseif direction == TOP then
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_TOP_ROTATION, 0)
    else
        DCEI.SetUnitRotationEuler(newDoor, 0, EXIT_BOTTOM_ROTATION, 0)
    end

    for _, exit in ipairs(validExits) do
        DCEI.RemoveUnit(exit)
    end
end

function UpdateCollisionWithExitDoor()
    m_inventory:SaveInventory()
    m_player:SaveData()
    m_roomItemDrops:ClearData() -- Clear the data for the older dungeon

    m_roomLevel = m_roomLevel + 1
    if m_roomLevel > ROOM_LEVEL_MAX then
        m_roomGenerator:ClearSaveData()

        SaveMod.ClearAllMainMapData()
        DCEI.Wait(1)
        DCEI.PlayLevel(BEGINNING_ROOM_PATH, BEGINNING_ROOM_NAME)

    else
        m_roomGenerator:ClearSaveData()
        SaveMod.ClearItemDrops()
        
        local randomSeed = os.time()
        math.randomseed(randomSeed)
        m_randomSeed = randomSeed
        
        m_roomGenerator = RoomGenerator:new(randomSeed, m_roomLevel)
        
        local roomName = m_roomGenerator:GetRoomFromPlayerPosition()
        local roomPath = RoomMod.GetRoomPath(roomName)

        SaveMod.SaveAllMainMapData(roomName, m_roomLevel, nil)
        DCEI.Wait(1)
        DCEI.PlayLevel(roomPath, roomName)
    end
end

function GetRandomCenterPointOnMap(validPositions)
    local capturedPositions = {}

    local worldCenter = DCEI.GetMapCenterPoint()
    
    local currentX = math.floor(worldCenter.x)
    local currentY = math.floor(worldCenter.y)
    local initialDiff = 1

    while true do
        for i = currentX, currentX + initialDiff - 1 do
            local position = { x = i, y = currentY }
            if ExtensionFunction.ArrayHasPosition(validPositions, position) then
                table.insert(capturedPositions, position)
            end
        end
        currentX = currentX + initialDiff

        for i = currentY, currentY - initialDiff + 1, -1 do
            local position = { x = currentX, y = i }
            if ExtensionFunction.ArrayHasPosition(validPositions, position) then
                table.insert(capturedPositions, position)
            end
        end
        currentY = currentY - initialDiff

        initialDiff = initialDiff + 1

        for i = currentX, currentX - initialDiff + 1, -1 do
            local position = { x = i, y = currentY }
            if ExtensionFunction.ArrayHasPosition(validPositions, position) then
                table.insert(capturedPositions, position)
            end
        end
        currentX = currentX - initialDiff

        for i = currentY, currentY + initialDiff - 1 do
            local position = { x = currentX, y = i }
            if ExtensionFunction.ArrayHasPosition(validPositions, position) then
                table.insert(capturedPositions, position)
            end
        end
        currentY = currentY + initialDiff

        initialDiff = initialDiff + 1

        if currentX >= WORLD_WIDTH or currentY >= WORLD_HEIGHT or currentX <= 0 or currentY <= 0 then
            break
        end

        if #capturedPositions >= CENTER_POSITIONS_MAX_COUNT then
            break
        end
    end

    local randomIndex = math.random(1, #capturedPositions)
    local targetPosition = capturedPositions[randomIndex]

    return targetPosition
end

-- #endregion Doorways

-- #region GameOver State

function SaveNextRoomData()
    if not m_isBeginningRoom then
        DCEI.LogMessage("Saving Next Room Data")

        local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
        local direction = ""
        
        if playerPosition.x < RoomMod.GetMinDirectionPosition(true) then
            m_roomGenerator.currentPlayerColumn = m_roomGenerator.currentPlayerColumn - 1
            direction = RIGHT
        elseif playerPosition.x > RoomMod.GetMaxDirectionPosition(true) then
            m_roomGenerator.currentPlayerColumn = m_roomGenerator.currentPlayerColumn + 1
            direction = LEFT
        elseif playerPosition.y < RoomMod.GetMinDirectionPosition(false) then
            m_roomGenerator.currentPlayerRow = m_roomGenerator.currentPlayerRow + 1
            direction = TOP
        elseif playerPosition.y > RoomMod.GetMaxDirectionPosition(false) then
            m_roomGenerator.currentPlayerRow = m_roomGenerator.currentPlayerRow - 1
            direction = BOTTOM
        else
            DCEI.LogError("Invalid Bounds?!!")
        end

        SaveMod.SaveMainMapLastDirection(direction)
        m_roomGenerator:SaveRoomStructure()
    else
        SaveMod.SaveMainMapLastDirection(nil)
    end

    -- Only Save when going into the new room
    m_roomItemDrops:SaveData()
    m_inventory:SaveInventory() 
    m_player:SaveData()
    m_skillDisplay:SaveSkillTree()
end

function DisplayGameOverSequence(playerWon)
    if m_player ~= nil then
        m_player:Destroy()
        m_player = nil
    end
    m_camera:UpdateTarget(nil)

    if playerWon then
        DCEI.LogMessage("X: " .. m_roomGenerator.currentPlayerColumn .. ", Y: " .. m_roomGenerator.currentPlayerRow)
        local roomName = m_roomGenerator:GetRoomFromPlayerPosition()
        local roomPath = RoomMod.GetRoomPath(roomName)

        SaveMod.SaveMainMapRoomName(roomName)
        DCEI.Wait(1)
        DCEI.PlayLevel(roomPath, roomName)
    else
        m_roomGenerator:ClearSaveData()
        m_inventory:ClearInventorySave()
        m_roomItemDrops:ClearData()

        SaveMod.ClearAllMainMapData()
        DCEI.Wait(1)
        DCEI.PlayLevel(BEGINNING_ROOM_PATH, BEGINNING_ROOM_NAME)
    end
end

-- #endregion GameOver State

-- #region Player Functions

function UpdatePlayerHealth(deltaTime)
    if m_player == nil then
        return
    end

    if m_player:GetPlayerUnit() == nil then
        return
    end

    local playerHealth = DCEI.GetHealthValue(m_player:GetPlayerUnit())
    local lastFramePlayerHealth = m_player:GetPlayerLastFrameHealth()

    if lastFramePlayerHealth > playerHealth then
        m_camera:StartShakeWithUnit(1, 0)
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), PLAYER_INVINCIBLE_BEHAVIOUR)

        m_playerInvincibilityTimer = PlayerInvincibleTimer
        m_playerDamageUiFlashCount = PlayerDamageFlashCount
        m_playerDamageUiIsFlashOn = false
    end

    if m_playerInvincibilityTimer > 0 then
        m_playerInvincibilityTimer = m_playerInvincibilityTimer - deltaTime

        if m_playerInvincibilityTimer <= 0 then
            DCEI.RemoveBehavior(m_player:GetPlayerUnit(), PLAYER_INVINCIBLE_BEHAVIOUR)
        end
    end
end

-- #endregion Player Functions

-- #region UI Functions

function CreateBaseUIElements()
    m_uiRoot = DCEI.GetUiRoot()

    local bottomFrame = DCEI.NewFrame(m_uiRoot)
    local middleFrame = DCEI.NewFrame(m_uiRoot)
    local topFrame = DCEI.NewFrame(m_uiRoot)

    DCEI.SetMatchParent(bottomFrame, true, true)
    DCEI.SetMatchParent(middleFrame, true, true)
    DCEI.SetMatchParent(topFrame, true, true)

    m_uiBottomLayer = bottomFrame
    m_uiMiddleLayer = middleFrame
    m_uiTopLayer = topFrame
end

function CreateCollectiblesUI()
    m_collectiblesUi = CollectiblesUIManager:new(m_uiRoot)
end

function CreatePlayerDamageDisplay()
    local damageDisplay = DCEI.NewFrame(m_uiTopLayer)
    DCEI.SetMatchParent(damageDisplay, true, true)
    DCEI.SetBackgroundImage(damageDisplay, "ui_mask_blurry")
    DCEI.SetBackgroundImageColor(damageDisplay, 1, 1, 1, 0)

    m_damageDisplay = damageDisplay
end

function CreatePlayerGoldDisplay()
    local playerGoldStack = DCEI.NewHStack(m_uiMiddleLayer)
    DCEI.SetTopAlignmentInParent(playerGoldStack)
    DCEI.SetLeftAlignmentInParent(playerGoldStack)
    DCEI.SetPaddingTop(playerGoldStack, 21)
    DCEI.SetPaddingLeft(playerGoldStack, 140)
    DCEI.SetSpacing(playerGoldStack, 14)
    
    local playerGoldImage = DCEI.NewFrame(playerGoldStack)
    DCEI.SetMinSize(playerGoldImage, 50, 50)
    DCEI.SetBackgroundImage(playerGoldImage, "ui_ingame_coin")

    local playerGoldText = DCEI.NewText(playerGoldStack)
    DCEI.SetTextFontSize(playerGoldText, 30)
    m_playerGoldDisplay = playerGoldText
end

function CreateDebugUI()
    local horizontalStack = DCEI.NewHStack(m_uiMiddleLayer)
    DCEI.SetTopAlignmentInParent(horizontalStack)
    DCEI.SetLeftAlignmentInParent(horizontalStack)
    DCEI.SetPaddingTop(horizontalStack, 21)
    DCEI.SetPaddingLeft(horizontalStack, 21)
    DCEI.SetSpacing(horizontalStack, 14)

    local characterButton = DCEI.NewButton(horizontalStack)
    DCEI.SetMinSize(characterButton, 50, 50)
    DCEI.SetBackgroundImage(characterButton, "icon_enhance_crusader_punish")
    DCEI.SetOnClickCallback(characterButton, HandleCharacterSwitch)

    local goldButton = DCEI.NewButton(horizontalStack)
    DCEI.SetMinSize(goldButton, 50, 54)
    DCEI.SetBackgroundImage(goldButton, "icon_affinity_gold")
    DCEI.SetOnClickCallback(goldButton, HandleGoldButtonClicked)

    local roomType = SaveMod.GetRoomName()
    if roomType == nil then
        local skillTreeButton = DCEI.NewButton(m_uiMiddleLayer)
        DCEI.SetMinSize(skillTreeButton, 50, 50)
        DCEI.SetBackgroundImage(skillTreeButton, "icon_enhance_repeater_bolashot")
        DCEI.SetOnClickCallback(skillTreeButton, HandleSkillTreeClick)
        DCEI.SetLeftAlignmentInParent(skillTreeButton)
        DCEI.SetTopAlignmentInParent(skillTreeButton)
        DCEI.SetHorizontalOffsetInParent(skillTreeButton, 21)
        DCEI.SetVerticalOffsetInParent(skillTreeButton, -100)
    end
end

function UpdatePlayerDamageUI(deltaTime)
    if m_playerDamageUiFlashCount > 0 then
        m_playerDamageUiFlashTimer = m_playerDamageUiFlashTimer - deltaTime

        if m_playerDamageUiFlashTimer <= 0 then
            if m_playerDamageUiIsFlashOn then
                DCEI.SetBackgroundImageColor(m_damageDisplay, 1, 1, 1, 0) -- Hide the Image
                m_playerDamageUiFlashCount = m_playerDamageUiFlashCount - 1
            else
                DCEI.SetBackgroundImageColor(m_damageDisplay, 1, 0, 0, 1) -- Display a Red Image
            end

            m_playerDamageUiIsFlashOn = not m_playerDamageUiIsFlashOn

            if m_playerDamageUiFlashCount ~= 0 then
                m_playerDamageUiFlashTimer = PlayerDamageFlashTimer
            end
        end
    end
end

function HandleCharacterSwitch()
    local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
    RemoveInventoryBehaviours()

    m_player:Destroy()
    m_player = nil

    local playerType
    if UseMeleePlayer then
        playerType = 0
    else
        playerType = 1
    end
    
    m_player = Player:new(playerPosition.x, playerPosition.y, playerType, m_uiRoot, m_skillDisplay)
    m_player:ShowPlayerUI()

    UseMeleePlayer = not UseMeleePlayer

    ApplyInventoryBehaviours()

    m_camera:UpdateTarget(m_player:GetPlayerUnit())
    m_player:SetPlayerCamera(m_camera)
end

function HandleGoldButtonClicked()
    -- TODO: Remove this later on...
    if m_player ~= nil then
        m_player:AddGold(10)
        DCEI.SetHealthValue(m_player:GetPlayerUnit(), 150)
    end
end

function HandleSkillTreeClick()
    if m_skillDisplay ~= nil then
        m_skillDisplay:ShowSkillTree(m_player)
    end
end

-- #endregion

-- #region Inventory Functions

function HandleInventoryUnitClicked(unit, unitName)
    if m_player == nil then
        DCEI.LogError("Player does not exist")
        return
    end

    local behaviourStack = DCEI.UnitBehaviorStackCount(unit, COLLECTIBLE_DROPPED_BEHAVIOUR)
    local usedGold = false

    if behaviourStack == 0 then
        local playerGold = m_player:GetPlayerGold()
        local itemCost = InventoryCollectibles[unitName].itemCost

        if playerGold < itemCost then
            DCEI.LogMessage("Item Name: " .. unitName .. ", Item Gold: " .. itemCost)
            DCEI.LogMessage("Not enough gold to buy!!!")
            return
        end

        local row = m_roomGenerator.currentPlayerRow
        local column = m_roomGenerator.currentPlayerColumn

        m_roomGenerator:MarkMerchantItemAsBought(row, column, unitName)
        usedGold = true
        m_player:UseGold(itemCost)
    end

    local success = m_inventory:CheckAndAddItemToSlot(unitName)
    if success then
        if not usedGold then
            local unitPosition = DCEI.GetUnitPosition2D(unit)
            local roomName
            local playerRow = BEGINNING_ROOM_MARKER
            local playerColumn = BEGINNING_ROOM_MARKER

            if m_isBeginningRoom then
                roomName = BEGINNING_ROOM_NAME
            else
                playerRow = m_roomGenerator.currentPlayerRow
                playerColumn = m_roomGenerator.currentPlayerColumn
                roomName = m_roomGenerator.roomMatrix[playerRow][playerColumn]
            end

            m_roomItemDrops:RemoveItemFromList(unitName, unitPosition.x, unitPosition.y, roomName, playerRow, playerColumn)
        end

        DCEI.RemoveUnit(unit)
    else
        DCEI.LogError("Inventory is full!!!")
    end

    ApplyInventoryItemBehaviour(unitName)
end

function CreateInventoryUI()
    local horizontalStack = DCEI.NewHStack(m_uiMiddleLayer)
    DCEI.SetTopAlignmentInParent(horizontalStack)
    DCEI.SetPaddingTop(horizontalStack, 21)

    local inventoryItems = {}
    
    for i = 0, 3 do
        local inventoryItem = InventorySlot:new(
            "btn_yellow_invert", 
            "btn_grey_invert", 
            horizontalStack, 
            HandleInventorySlotClicked,
            HandleInventoryItemDropped
        )
        table.insert(inventoryItems, inventoryItem)
    end

    local inventory = Inventory:new(inventoryItems)
    m_inventory = inventory
end

function LoadInventoryFromSave()
    -- This must be done after the player is created as the behaviours will be added to the player
    m_inventory:LoadInventory()
    ApplyInventoryBehaviours()
end

function ApplyInventoryBehaviours()
    local slots = m_inventory:GetInventorySlots()
    for i, slot in ipairs(slots) do
        local itemName = slot:GetInventoryItemName()
        ApplyInventoryItemBehaviour(itemName)
        
        if itemName == COLLECTIBLE_HELM_OF_VALOR then
            m_helmOfValorTimeRemaining = slot.currentRechargeTime    
        end
    end
end

function RemoveInventoryBehaviours()
    local slots = m_inventory:GetInventorySlots()
    for i, slot in ipairs(slots) do
        local itemName = slot:GetInventoryItemName()
        RemoveInventoryItemBehaviour(itemName)
    end
end

function ApplyInventoryItemBehaviour(itemName)
    if itemName == COLLECTIBLE_BOOTS_OF_SPEED then
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[itemName].itemBehaviourName)
    elseif itemName == COLLECTIBLE_HAMMER_OF_ATTACK then
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[itemName].itemBehaviourName)
    elseif itemName == COLLECTIBLE_HELM_OF_VALOR then
        m_helmOfValorInInventory = true
        m_helmOfValorActive = false
        m_helmOfValorTimeRemaining = 0
    end
end

function RemoveInventoryItemBehaviour(itemName)
    if itemName == COLLECTIBLE_BOOTS_OF_SPEED then
        DCEI.RemoveBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[itemName].itemBehaviourName)
    elseif itemName == COLLECTIBLE_HAMMER_OF_ATTACK then
        DCEI.RemoveBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[itemName].itemBehaviourName)
    elseif itemName == COLLECTIBLE_HELM_OF_VALOR then
        m_helmOfValorInInventory = false
        m_helmOfValorActive = false
        m_helmOfValorTimeRemaining = 0

        DCEI.RemoveBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[itemName].itemBehaviourName)
    end
end

function HandleInventoryItemDropped(itemName, inventorySlot)
    if itemName == "" then
        DCEI.LogMessage("Slot Already Empty")
        return
    end

    DropInventoryItemToWorld(itemName)

    RemoveInventoryItemBehaviour(itemName)
    inventorySlot:DropInventoryItem()
end

function HandleInventorySlotClicked(itemName, inventorySlot)
    if m_player == nil then
        return
    end

    DCEI.LogMessage("Selected Item: " .. itemName)

    if itemName == COLLECTIBLE_POTION then
        local healthAmount = InventoryCollectibles[itemName].itemPotionHealth
        local potionBehaviour = InventoryCollectibles[itemName].itemBehaviourName

        DCEI.LogMessage("Adding Player Health: " .. healthAmount)
        DCEI.AddHealth(m_player:GetPlayerUnit(), healthAmount)
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), potionBehaviour)
        
        inventorySlot:UseItem()
        
    elseif itemName == COLLECTIBLE_BOMB then
        local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
        local bombUnitName = InventoryCollectibles[itemName].itemBombName

        DCEI.LogMessage("Deploying Bomb...")
        DCEI.CreateUnit(0, 0, bombUnitName, playerPosition.x, playerPosition.y)

        inventorySlot:UseItem()

    else
        DropInventoryItemToWorld(itemName)

        RemoveInventoryItemBehaviour(itemName)
        inventorySlot:DropInventoryItem()
    end
end

function DropInventoryItemToWorld(itemName)
    local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
    local item = DCEI.CreateUnit(1, 1, itemName, playerPosition.x, playerPosition.y)
    DCEI.ApplyBehavior(item, COLLECTIBLE_DROPPED_BEHAVIOUR)

    local roomName
    local playerRow = BEGINNING_ROOM_MARKER
    local playerColumn = BEGINNING_ROOM_MARKER

    if m_isBeginningRoom then
        roomName = BEGINNING_ROOM_NAME
    else
        playerRow = m_roomGenerator.currentPlayerRow
        playerColumn = m_roomGenerator.currentPlayerColumn
        roomName = m_roomGenerator.roomMatrix[playerRow][playerColumn]
    end

    m_roomItemDrops:AddItemToList(itemName, playerPosition.x, playerPosition.y, roomName, playerRow, playerColumn)
    m_collectiblesUi:AddNewUI(m_uiRoot, item, itemName)
end

-- #endregion Inventory Functions

-- #endregion Utility Fuctions

-- This function shuold be run before Start...
function mod.ActivateMerchantRooms()
    local spawnUnits = DCEI.FindUnits(SPAWN_MARKER_UNIT)
    local row = m_roomGenerator.currentPlayerRow
    local column = m_roomGenerator.currentPlayerColumn

    local items = m_roomGenerator:GetMerchantRoomData(row, column)
    if items == nil then
        DCEI.LogError("Invalid Merchant Room!!!")
        return
    end
    
    for i, unit in ipairs(spawnUnits) do
        local unitPosition = DCEI.GetUnitPosition2D(unit)
        DCEI.RemoveUnit(unit)
        
        local item = items[i]
        if not item.bought then
            local itemInstance = DCEI.CreateUnit(1, 1, item.itemName, unitPosition.x, unitPosition.y)
            m_collectiblesUi:AddNewUI(m_uiRoot, itemInstance, item.itemName)
        end
    end
end

mod.SpawnMarkerUnit = SPAWN_MARKER_UNIT
mod.RoomName = ROOM_NAME

return mod