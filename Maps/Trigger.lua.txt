local ArcadeCore = GameModules["Arcade/Core"] -- Maybe be required
local ExtensionFunction = GameModules["Mods/ExtensionFunctionMod"]
local InventoryMod = GameModules["Mods/InventoryMod"]
local EnemyMod = GameModules["Mods/EnemyMod"]
local RoomMod = GameModules["Mods/RoomMod"]

local Inventory = InventoryMod.Inventory
local InventorySlot = InventoryMod.InventorySlot
local InventoryItem = InventoryMod.InventoryItem

EnemyMod.VectorDistance = ExtensionFunction.VectorDistance
local SingleAttackEnemy = EnemyMod.SingleAttackEnemy
local MultiAttackEnemy = EnemyMod.MultiAttackEnemy

RoomMod.VectorDistance = ExtensionFunction.VectorDistance
RoomMod.SingleAttackEnemy = SingleAttackEnemy
RoomMod.MultiAttackEnemy = MultiAttackEnemy
local RoomData = RoomMod.RoomData


-- #region Rectangle Class
Rect = { x = 0, y = 0, width = 0, height = 0 }
Rect.__index = Rect
function Rect:new(x, y, width, height)
    local rect = {}
    setmetatable(rect, Rect)
    
    rect.x = x
    rect.y = y
    rect.width = width
    rect.height = height

    return rect
end
function Rect:center()
    local xPosition = self.x + self.width / 2.0
    local yPosition = self.y + self.height / 2.0

    return xPosition, yPosition
end
function Rect:topLeft()
    return self.x, self.y
end
function Rect:bottomRight()
    return self.x + self.width, self.y + self.height
end
function Rect:overlaps(rect)
    return self.x < rect.x + rect.width and self.x + self.width > rect.x and
            self.y < rect.y + rect.height and self.y + self.height > rect.y
end
function Rect:contains(xPosition, yPosition)
    return self.x <= xPosition and self.x + self.width >= xPosition and 
            self.y <= yPosition and self.y + self.height >= yPosition
end
-- #endregion

-- Variables
-- Debug
local DEBUG_UNIT = "DebugMarkerUnit"

-- Prefabs
local SOLID_WALL_PREFAB = "Wall"
local BREAKABLE_WALL_PREFAB = "Breakable Wall"
local DOORWAY = "Doorway"
local ENEMY_PREFABS = {
    {
        name = "Ranged Enemy Type 1",
        ability = "Ranged Enemy Type 1 Ability",
        isMulti = false
    },
    {
        name = "Ranged Enemy Type 2",
        blankUnitName = "Ranged Enemy Type 2 Blank",
        ability = "Ranged Enemy Type 2 Ability",
        isMulti = true
    }
}
local COLLECTIBLE_PREFAB = "Collectible" -- TODO: Remove this later on...
local WORLD_WIDTH = 30
local WORLD_HEIGHT = 30
local GAME_LOOP_RATE = 0.0625
local BASE_ROOM_SIZE = 10 -- TODO: Use room size from template later on...

-- Player
local PLAYER_NAME = "Player Character"
local PLAYER_WEAPON_1 = "Player Character Weapon 1 Ability"
local PLAYER_WEAPON_2 = "Player Character Weapon 2 Ability"
local PLAYER_DASH_ABILITY = "Player Character Dash Ability"
local PLAYER_COLLISION_BEHAVIOUR = "Player Character Collision Detected Behaviour"

-- Collectibles
local COLLECTIBLES = {
    { itemType = 0, itemPrefab = "Collectible Test 1", itemImage = "icon_affinity_brown" },
    { itemType = 1, itemPrefab = "Collectible Test 2", itemImage = "icon_affinity_gold" }
}

-- Public Variables
-- Room
local RoomSize = 10
local RoomTemplates = {
    {
        {0, 0, 0, 0, 0, 2, 0, 0, 0, 0},
        {0, 5, 3, 5, 5, 3, 3, 5, 5, 0},
        {2, 5, 5, 0, 0, 0, 5, 5, 5, 0},
        {2, 0, 1, 5, 5, 5, 3, 5, 3, 2},
        {0, 5, 1, 1, 5, 1, 3, 5, 5, 0},
        {0, 5, 1, 1, 5, 5, 5, 5, 5, 0},
        {0, 5, 5, 3, 5, 5, 5, 5, 5, 0},
        {0, 5, 5, 1, 1, 1, 3, 5, 5, 0},
        {0, 5, 5, 5, 5, 5, 5, 5, 5, 0},
        {0, 0, 0, 0, 0, 2, 0, 0, 0, 0},
    }
}
-- Waves
local MinWaveCount = 1
local MaxWaveCount = 3
-- Player
local PlayerSpawnPosition = { x = 27, y = 27 }
local PlayerDashTimer = 0.3
local PlayerDashSpeed = 5
local PlayerDashMana = 30
-- Mouse
local SingleClickTriggerTime = 0.3

-- Private Variables
-- Rooms
local m_rooms = {}
-- Player
local m_player
local m_playerCollided = false
local m_dashTimer = 0
local m_dashVelocity = { x = 0, y = 0 }
local m_playerMoving = false
-- UI
local m_uiRoot
local m_inventory
local m_collectibleItems = {} -- TODO: Check if there is a better way...

-- #region LifeCycle Functions
function Start()
    math.randomseed(os.time())

    m_player = DCEI.CreateUnit(1, 1, PLAYER_NAME, PlayerSpawnPosition.x, PlayerSpawnPosition.y)
    m_uiRoot = DCEI.GetUiRoot()

    DCEI.TriggerAddUnitDiedEvent(DCEI.UnitAny, HandleUnitDied)
    DCEI.TriggerAddBehaviorAddEvent(DCEI.UnitAny, HandleBehaviourAdded)
    DCEI.TriggerAddUnitSelectedEvent(DCEI.UnitAny, HandleUnitSelected)
    DCEI.TriggerAddTimerEventPeriodicIndefinite(Update, GAME_LOOP_RATE)

    DCEI.SetCameraDistanceSmooth(20)

    -- DCEI.TriggerAddMouseDownEvent(0, HandleMouseDown)
    DCEI.TriggerAddJoystickEvent(HandleJoystickMoved)
    DCEI.TriggerAddJoystickReleaseEvent(HandleJoystickReleased)
    DCEI.TriggerAddJoystickButtonEvent(0, HandleJoystickButtonClicked, { icon = "icon_enhance_crusader_zeal" })
    DCEI.TriggerAddJoystickButtonEvent(1, HandleJoystickButtonClicked, { icon = "icon_enhance_stoneguard_bash" })
    DCEI.TriggerAddJoystickButtonEvent(2, HandleJoystickButtonClicked, { icon = "icon_spell_angelic_host" })

    ArcadeCore.HideDefaultUi()
    CreatePlayerUIElements()
    CreateInvertoryUI()

    local xCounter = 0
    local yCounter = 0
    local i = 0
    local j = 0

    while j < WORLD_HEIGHT do
        while i < WORLD_WIDTH do
            -- Don't Spawn the Last Room
            if i == WORLD_WIDTH - BASE_ROOM_SIZE and j == WORLD_HEIGHT - BASE_ROOM_SIZE then
                break
            end

            local rect = Rect:new(i, j, BASE_ROOM_SIZE, BASE_ROOM_SIZE)
            local randomPatternIndex = math.random(1, #RoomTemplates)
            local randomWaveCount = math.random(MinWaveCount, MaxWaveCount)
            
            local roomData = RoomData:new(
                rect, RoomTemplates[randomPatternIndex],
                randomWaveCount,
                SOLID_WALL_PREFAB, BREAKABLE_WALL_PREFAB, DOORWAY,
                ENEMY_PREFABS, COLLECTIBLE_PREFAB,
                ExtensionFunction.VectorDistance,
                MultiAttackEnemy, SingleAttackEnemy
            )
            table.insert(m_rooms, roomData)

            i = i + BASE_ROOM_SIZE
        end
        j = j + BASE_ROOM_SIZE
        i = 0
    end

    local collectible_1 = InventoryItem:new(COLLECTIBLES[1].itemPrefab, 25, 25, COLLECTIBLES[1].itemType, COLLECTIBLES[1].itemImage)
    local collectible_2 = InventoryItem:new(COLLECTIBLES[2].itemPrefab, 23, 23, COLLECTIBLES[2].itemType, COLLECTIBLES[2].itemImage)

    table.insert(m_collectibleItems, collectible_1)
    table.insert(m_collectibleItems, collectible_2)
end

function Update()
    for i, room in ipairs(m_rooms) do
        room:IsPlayerInRoom(m_player)
        room:UpdateEnemies(GAME_LOOP_RATE, m_player)
    end

    if m_player ~= nil then
        local position = DCEI.GetUnitPosition2D(m_player)
        DCEI.SetCameraFocusSmooth(position.x, position.y, true)

        if m_dashTimer > 0 then
            UpdatePlayerDashMovement(GAME_LOOP_RATE)
        end
    end

    MakePlayerLookTowardsNearestEnemy()
    m_playerCollided = false
end

-- #endregion LifeCycle Functions

-- #region Event Functions

-- Unit Events
function HandleUnitDied()
    local unit = DCEI.TriggeringUnit

    -- Just go through all rooms and trigger it
    -- The correct one will automatically trigger
    for i, room in ipairs(m_rooms) do
        room:RemovedDeadEnemy(unit)
    end

    local unitName = DCEI.UnitName(unit)
    if unitName == PLAYER_NAME then
        DisplayGameOverSequence()
    end
end

function HandleBehaviourAdded()
    local behaviourName = DCEI.TriggeringBehaviorName

    if behaviourName == PLAYER_COLLISION_BEHAVIOUR then
        m_playerCollided = true
    end
end

function HandleUnitSelected()
    -- TODO: Maybe use names to specify what type of Unit was select
    -- Like __Collectible or something...
    local unit = DCEI.TriggeringUnit
    local index = -1

    for i, collectibleItem in ipairs(m_collectibleItems) do
        if collectibleItem:CompareUnits(unit) then
            if not m_inventory:IsFull() then
                m_inventory:AddItemToSlot(collectibleItem)
                index = i
            end
        end
    end

    if index ~= -1 then
        local collectibleItem = m_collectibleItems[index]
        collectibleItem:Destroy()
        table.remove(m_collectibleItems, index)
    end
end
-- Unit Events

-- Joystick Events
function HandleJoystickMoved()
    -- When Dashing the Player cannot move normally
    if m_player == nil or m_dashTimer > 0 then
        return
    end

    local axes = DCEI.TriggeringJoystickAxes
    local playerPosition = DCEI.GetUnitPosition2D(m_player)
    m_playerMoving = true

    DCEI.Move(m_player, playerPosition.x + axes.x, playerPosition.y + axes.y)
end

function HandleJoystickReleased()
    local playerPosition = DCEI.GetUnitPosition2D(m_player)
    m_playerMoving = false

    DCEI.Move(m_player, playerPosition.x, playerPosition.y)
end

function HandleJoystickButtonClicked()
    local buttonId = DCEI.TriggeringJoystickButtonId
    local buttonEvent = DCEI.TriggeringJoystickButtonEventType

    if buttonEvent ~= 1 then
        return
    end

    local mousePosition = DCEI.GetMousePosition2D()

    if buttonId == 0 then
        LaunchPlayerLightAttack(mousePosition)
    elseif buttonId == 1 then
        LaunchPlayerHeavyAttack(mousePosition)
    elseif buttonId == 2 then
        MakePlayerDodgeAndRoll()
    end
end
-- Joystick Events

-- Mouse Events
function HandleMouseDown(mousePosition)
    if m_player == nil or m_dashTimer > 0 then
        return
    end

    DCEI.Move(m_player, mousePosition.x, mousePosition.y)
end
-- Mouse Events

-- #endregion Event Functions

-- #region Utility Fuctions

-- #region GameOver State

function DisplayGameOverSequence()
    local maskOptions = {
        color = { r = 0, g = 0, b = 0 },
        duration = 0.5
    }

    DCEI.ShowScreenMaskWithAlpha(1, maskOptions)
    DCEI.Wait(maskOptions.duration)

    ResetGameState()

    DCEI.ShowScreenMaskWithAlpha(0, maskOptions)
    DCEI.Wait(maskOptions.duration)
    DCEI.HideScreenMask()
end

function ResetGameState()
    for i, room in ipairs(m_rooms) do
        room:Reset()
    end

    m_player = DCEI.CreateUnit(1, 1, PLAYER_NAME, PlayerSpawnPosition.x, PlayerSpawnPosition.y)
    CreatePlayerUIElements()
end

-- #endregion GameOver State

-- #region Player Functions
function MakePlayerLookTowardsNearestEnemy()
    if m_player == nil or m_playerMoving then
        return
    end

    for i, room in ipairs(m_rooms) do
        local enemy = room:GetNearestEnemy(m_player)
        if enemy ~= nil then
            local enemyPosition = DCEI.GetUnitPosition2D(enemy)
            local playerPosition = DCEI.GetUnitPosition2D(m_player)

            local direction = ExtensionFunction.VectorSubtract(enemyPosition, playerPosition)
            local angle = math.deg(math.atan(direction.x, direction.y))

            DCEI.SetUnitRotationEuler(m_player, 0, angle, 0)
            break
        end
    end
end

function LaunchPlayerLightAttack()
    if m_player == nil then
        DCEI.LogMessage("Player Died")
        return
    end

    local abilityCasted = false

    for i, room in ipairs(m_rooms) do
        local enemy = room:GetNearestEnemy(m_player)
        if enemy ~= nil then
            local position = DCEI.GetUnitPosition2D(enemy)
            DCEI.CastAbilityAtPosition(PLAYER_WEAPON_1, m_player, position.x, position.y)
            abilityCasted = true
            break                
        end
    end

    if not abilityCasted then
        local playerRotation = DCEI.GetUnitRotationEuler(m_player)
        local playerPosition = DCEI.GetUnitPosition2D(m_player)
        local yRotation = ExtensionFunction.NormalizeUnitRotation(playerRotation)
        
        local xPoint = math.sin(math.rad(yRotation)) + playerPosition.x
        local yPoint = math.cos(math.rad(yRotation)) + playerPosition.y
        DCEI.CastAbilityAtPosition(PLAYER_WEAPON_1, m_player, xPoint, yPoint)
    end
end

function LaunchPlayerHeavyAttack()
    if m_player == nil then
        DCEI.LogMessage("Player Died")
        return
    end

    local abilityCasted = false

    for i, room in ipairs(m_rooms) do
        local enemy = room:GetNearestEnemy(m_player)
        if enemy ~= nil then
            local position = DCEI.GetUnitPosition2D(enemy)
            DCEI.CastAbilityAtPosition(PLAYER_WEAPON_2, m_player, position.x, position.y)
            abilityCasted = true
            break
        end
    end

    if not abilityCasted then
        local playerRotation = DCEI.GetUnitRotationEuler(m_player)
        local playerPosition = DCEI.GetUnitPosition2D(m_player)
        local yRotation = ExtensionFunction.NormalizeUnitRotation(playerRotation)
        
        local xPoint = math.sin(math.rad(yRotation)) + playerPosition.x
        local yPoint = math.cos(math.rad(yRotation)) + playerPosition.y
        DCEI.CastAbilityAtPosition(PLAYER_WEAPON_2, m_player, xPoint, yPoint)
    end
end

function MakePlayerDodgeAndRoll()
    if m_player == nil then
        DCEI.LogMessage("Player Died")
        return
    end

    -- To show UI
    DCEI.CastAbility(PLAYER_DASH_ABILITY, m_player, m_player)

    local playerMana = DCEI.GetManaValue(m_player)
    if playerMana < PlayerDashMana then
        DCEI.LogMessage("Not enough mana for dash")
        return
    end

    local playerRotation = DCEI.GetUnitRotationEuler(m_player)
    local yRotation = ExtensionFunction.NormalizeUnitRotation(playerRotation)

    local xVelocity = math.sin(math.rad(yRotation)) * PlayerDashSpeed
    local yVelocity = math.cos(math.rad(yRotation)) * PlayerDashSpeed
    m_dashVelocity.x = xVelocity
    m_dashVelocity.y = yVelocity
    m_dashTimer = PlayerDashTimer
end

function UpdatePlayerDashMovement(deltaTime)
    if m_playerCollided then
        m_dashTimer = 0
        m_dashVelocity.x = 0
        m_dashVelocity.y = 0
        return
    end

    m_dashTimer = m_dashTimer - deltaTime
    
    if m_dashTimer <= 0 then
        m_dashVelocity.x = 0
        m_dashVelocity.y = 0
    else
        local playerPosition = DCEI.GetUnitPosition2D(m_player)
        playerPosition.x = playerPosition.x + m_dashVelocity.x * deltaTime
        playerPosition.y = playerPosition.y + m_dashVelocity.y * deltaTime

        DCEI.SetUnitPosition2D(m_player, playerPosition.x, playerPosition.y)
    end
end
-- #endregion Player Functions

-- #region UI Functions

function CreatePlayerUIElements()
    -- Health Bar
    local healthBarBackground = DCEI.NewFrame(m_uiRoot)
    local healthBar = DCEI.NewFrame(healthBarBackground)

    DCEI.SetBackgroundImage(healthBarBackground, "bar_progression00_empty")
    DCEI.SetBackgroundImage(healthBar, "bar_exp00_fill")
    DCEI.SetBackgroundImageColor(healthBar, 0, 1, 0, 1)

    DCEI.SetMinSize(healthBarBackground, 67, 10)
    DCEI.SetMinSize(healthBar, 65, 7)

    DCEI.SetBackgroundImageFillAmountExpression(healthBar, "MainCharacter.Health.Fraction")
    DCEI.BindUnit("MainCharacter", m_player)
    DCEI.AttachToUnit(healthBarBackground, m_player, { offset = { up = 0.8 } })

    -- Mana Bar
    local manaBarBackground = DCEI.NewFrame(m_uiRoot)
    local manaBar = DCEI.NewFrame(manaBarBackground)

    DCEI.SetBackgroundImage(manaBarBackground, "bar_progression00_empty")
    DCEI.SetBackgroundImage(manaBar, "bar_exp00_fill")

    DCEI.SetMinSize(manaBarBackground, 67, 10)
    DCEI.SetMinSize(manaBar, 65, 7)

    DCEI.SetBackgroundImageFillAmountExpression(manaBar, "MainCharacter.Mana.Fraction")
    DCEI.BindUnit("MainCharacter", m_player)
    DCEI.AttachToUnit(manaBarBackground, m_player, { offset = { up = 0.6 } })
    
    -- Destroy UI when player dies
    DCEI.TriggerAddUnitDiedEvent(
        m_player, 
        function()
            DCEI.Destroy(healthBarBackground)
            DCEI.Destroy(manaBarBackground)
        end
    )
    DCEI.TriggerAddUnitRemovedEvent(
        m_player,
        function()
            DCEI.Destroy(healthBarBackground)
            DCEI.Destroy(manaBarBackground)
        end
    )
end

function CreateInvertoryUI()
    local horizontalStack = DCEI.NewHStack(m_uiRoot)
    DCEI.SetTopAlignmentInParent(horizontalStack)
    DCEI.SetPaddingTop(horizontalStack, 21)

    local inventoryItems = {}
    
    for i = 0, 3 do
        local inventoryItem = InventorySlot:new("btn_yellow_invert", "btn_grey_invert", horizontalStack, HandleInventorySlotClicked)
        table.insert(inventoryItems, inventoryItem)
    end

    local inventory = Inventory:new(inventoryItems, 4)
    m_inventory = inventory
end

function HandleInventorySlotClicked(itemType)
    DCEI.LogMessage("Inventory Item: " .. itemType)
end

function HandleLeftButtonClick()
    DCEI.LogMessage("Left Button Clicked")
    MakePlayerDodgeAndRoll()
end

function HandleRightButtonClick()
    DCEI.LogMessage("Right Button Clicked")
    local mousePosition = DCEI.GetMousePosition2D()
    LaunchPlayerLightAttack(mousePosition)
end

-- #endregion

-- #endregion Utility Fuctions

-- Initialization
Start()