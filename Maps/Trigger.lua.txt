-- #region Mods and Includes
local ArcadeCore = GameModules["Arcade/Core"] -- Maybe be required
local ExtensionFunction = GameModules["Mods/ExtensionFunctionMod"]
local InventoryMod = GameModules["Mods/InventoryMod"]
local EnemyMod = GameModules["Mods/EnemyMod"]
local RoomMod = GameModules["Mods/NewRoomMod"]
local CameraMod = GameModules["Mods/CameraMod"]
local UtilClassMod = GameModules["Mods/UtilClassMod"]
local PlayerMod = GameModules["Mods/PlayerMod"]

local Inventory = InventoryMod.Inventory
local InventorySlot = InventoryMod.InventorySlot
local InventoryCollectibles = InventoryMod.InventoryCollectibles

EnemyMod.VectorDistance = ExtensionFunction.VectorDistance
EnemyMod.VectorSubtract = ExtensionFunction.VectorSubtract
EnemyMod.LerpAngleDeg = ExtensionFunction.LerpAngleDeg
EnemyMod.NormalizeUnitRotation = ExtensionFunction.NormalizeUnitRotation
EnemyMod.WalkableTextureId = RoomMod.WalkableTextureId
local EnemyHobGoblin = EnemyMod.EnemyHobGoblin
local EnemyGoblinChef = EnemyMod.EnemyGoblinChef
local EnemyGoblin = EnemyMod.EnemyGoblin
local EnemyGoblinSapper = EnemyMod.EnemyGoblinSapper
local EnemyOoze = EnemyMod.EnemyOoze

RoomMod.EnemyHobGoblin = EnemyHobGoblin
RoomMod.EnemyGoblinChef = EnemyGoblinChef
RoomMod.EnemyGoblin = EnemyGoblin
RoomMod.EnemyGoblinSapper = EnemyGoblinSapper
RoomMod.EnemyOoze = EnemyOoze
RoomMod.split = ExtensionFunction.split
RoomMod.ToBoolean = ExtensionFunction.ToBoolean
RoomMod.ArrayHasValue = ExtensionFunction.ArrayHasValue
RoomMod.VectorDistance = ExtensionFunction.VectorDistance
RoomMod.ShuffleTable = ExtensionFunction.ShuffleTable
local RoomGenerator = RoomMod.RoomGenerator
local RoomEnemies = RoomMod.RoomEnemies
local MiniMap = RoomMod.MiniMap

local Camera = CameraMod.Camera

PlayerMod.VectorSubtract = ExtensionFunction.VectorSubtract
PlayerMod.NormalizeUnitRotation = ExtensionFunction.NormalizeUnitRotation
local Player = PlayerMod.Player

local Rect = UtilClassMod.Rect
-- #endregion Mods and Includes

local mod = {}


-- #region Constants
local WORLD_WIDTH = 30
local WORLD_HEIGHT = 30
local MAX_ROOM_COLUMNS = 3
local GAME_LOOP_RATE = 0.0625

local LEFT = "L"
local RIGHT = "R"
local TOP = "T"
local BOTTOM = "B"
local LAST_DIRECTION = "LastDirection"

local DEBUG_UNIT = "__DebugMarkerUnit"
local EXIT_DOORWAY = "_TrapDoorway"
local EXIT_DOORWAY_OPEN = "_DoorwayOpen"
local EXIT_DOORWAY_CLOSE = "_DoorwayClose"

local PLAYER_COLLISION_BEHAVIOUR = "_CollisionDetection_PlayerCharacter"
local PLAYER_INVINCIBLE_BEHAVIOUR = "_PlayerCharacter_Damage_Invincible"
local PLAYERCHARACTER_MISSILE_REACHED = "_PlayerCharacter_Missile_Reached"
local PLAYERCHARACTER_DAMAGED = "_PlayerCharacter_Damaged"
local PLAYER_NAME_RANGED = "_PlayerCharacter_Ranged"
local PLAYER_NAME_MELEE = "_PlayerCharacter_Melee"

-- Enemy
local ENEMY_STUNNED_BEHAVIOUR = "_Enemy_Stunned"

-- Collectibles
local COLLECTIBLE_STRING = "_Collectible"
local COLLECTIBLE_BOOTS_OF_SPEED = "_Collectible_Boots_Of_Speed"
local COLLECTIBLE_HAMMER_OF_ATTACK = "_Collectible_Hammer_Of_Attack"
local COLLECTIBLE_POTION = "_Collectible_Potion"
local COLLECTIBLE_BOMB = "_Collectible_Bomb"

local COLLECTIBLE_HELM_OF_VALOR = "_Collectible_Helm_Of_Valor"
local COLLECTIBLE_HELM_OF_VALOR_TIMER = 10

-- Rooms
local BEGINNING_ROOM_NAME = "StartingBase"
local BEGINNING_ROOM_PATH = "Mods/StartingBase"
local DOOR_OPEN_ANIM = "_Room_Exit_Open"
local DOOR_CLOSE_ANIM = "_Room_Exit_Close"
local ROOM_EXIT_DOOR = "_Room_Exit"
local ROOM_NAME = "RoomName"

-- #endregion Constants

-- Public Variables
-- Player
local PlayerInvincibleTimer = 3
local PlayerDamageFlashCount = 1
local PlayerDamageFlashTimer = 0.15
local UseMeleePlayer = true
-- Private Variables
-- Rooms
local m_roomGenerator
local m_roomEnemies
local m_isBeginningRoom = false
local m_nextRoomTransitionActive = false
local m_doorOpenAnimPlayed = false
local m_roomEnemiesCleared = false
local m_exitDoor
local m_entryDoor
-- Player
local m_player
local m_leftSpawn
local m_rightSpawn
local m_topSpawn
local m_bottomSpawn
-- Player Health and Damage
local m_playerInvincibilityTimer = 0
local m_playerDamageUiFlashCount = 0
local m_playerDamageUiFlashTimer = 0
local m_playerDamageUiIsFlashOn = false
-- Helm Of Valor
local m_helmOfValorTimeRemaining = 0
local m_helmOfValorActive = false
local m_helmOfValorInInventory = false
-- Camera
local m_camera
-- UI
local m_uiRoot
local m_uiBottomLayer
local m_uiMiddleLayer
local m_uiTopLayer
local m_inventory
local m_damageDisplay
local m_playerGoldDisplay
local m_miniMap
-- Random
local m_randomSeed

-- #region LifeCycle Functions
function mod.Start(spawnPositionLeft, spawnPositionRight, spawnPositionTop, spawnPositionBottom)
    local randomSeed = os.time()
    DCEI.LogMessage("Random Seed: " .. randomSeed)
    math.randomseed(randomSeed)
    m_randomSeed = randomSeed

    m_leftSpawn = spawnPositionLeft
    m_rightSpawn = spawnPositionRight
    m_topSpawn = spawnPositionTop
    m_bottomSpawn = spawnPositionBottom
    
    CreateBaseUIElements()
    CreatePlayerDamageDisplay()
    CreatePlayerGoldDisplay()
    ArcadeCore.HideDefaultUi()
    CreateInventoryUI()
    CreateDebugUI()

    SpawnPlayerAndSetPosition()
    m_camera = Camera:new(m_player:GetPlayerUnit())
    m_player:SetPlayerCamera(m_camera)
    LoadInventoryFromSave() -- Load Inventory later as Player is required to apply effects
    CheckAndSpawnEntryDoor() -- This should be done later as the Player is required to be moved on the doorway
    CheckAndSpawnExitDoor()
    SpawnEnemiesAndCloseDoors()

    m_miniMap = MiniMap:new(m_uiMiddleLayer, m_roomGenerator)
    if m_isBeginningRoom then
        m_miniMap:DisableMiniMap()
    else
        m_miniMap:UpdateMiniMap()
    end
    
    -- Add Triggers At The End...
    DCEI.TriggerAddJoystickEvent(
        function()
            local axes = DCEI.TriggeringJoystickAxes
            if m_player ~= nil then
                m_player:HandleJoystickMoved(axes)
            end
        end
    )
    DCEI.TriggerAddJoystickReleaseEvent(
        function()
            if m_player ~= nil then
                m_player:HandleJoystickReleased()
            end
        end
    )
    DCEI.TriggerAddJoystickButtonEvent(0, 
        function()
            local buttonId = DCEI.TriggeringJoystickButtonId
            local buttonEvent = DCEI.TriggeringJoystickButtonEventType
            
            if m_player ~= nil then
                m_player:HandleJoystickButtonClicked(buttonId, buttonEvent, m_roomEnemies)
            end
        end, 
        { icon = "icon_enhance_crusader_zeal" }
    )
    DCEI.TriggerAddJoystickButtonEvent(1, 
        function()
            local buttonId = DCEI.TriggeringJoystickButtonId
            local buttonEvent = DCEI.TriggeringJoystickButtonEventType
            
            if m_player ~= nil then
                m_player:HandleJoystickButtonClicked(buttonId, buttonEvent, m_roomEnemies)
            end
        end, 
        { icon = "icon_enhance_stoneguard_bash" }
    )
    DCEI.TriggerAddJoystickButtonEvent(2, 
        function()
            local buttonId = DCEI.TriggeringJoystickButtonId
            local buttonEvent = DCEI.TriggeringJoystickButtonEventType

            if m_player ~= nil then
                m_player:HandleJoystickButtonClicked(buttonId, buttonEvent, m_roomEnemies)
            end
        end, 
        { icon = "icon_spell_angelic_host" }
    )

    DCEI.TriggerAddUnitDiedEvent(DCEI.UnitAny, HandleUnitDied)
    DCEI.TriggerAddBehaviorAddEvent(DCEI.UnitAny, HandleBehaviourAdded)
    DCEI.TriggerAddUnitSelectedEvent(DCEI.UnitAny, HandleUnitSelected)

    DCEI.TriggerAddTimerEventPeriodicIndefinite(Update, GAME_LOOP_RATE)
end

function Update()
    UpdatePlayerHealth(GAME_LOOP_RATE) -- Update Health first otherwise the Player will have current health as LastFramePlayerHealth
    
    if m_player ~= nil then
        m_player:Update(GAME_LOOP_RATE)
        local playerGoldAmount = m_player:GetPlayerGold()
        DCEI.SetText(m_playerGoldDisplay,  tostring(playerGoldAmount))
    end

    if m_roomEnemies ~= nil and m_player ~= nil then
        m_roomEnemies:UpdateEnemies(GAME_LOOP_RATE, m_player:GetPlayerUnit())
        
        local enemy = m_roomEnemies:GetActiveNearestEnemy(m_player:GetPlayerUnit())
        m_player:LookTowardsEnemy(enemy)
    end

    UpdatePlayerDamageUI(GAME_LOOP_RATE)
    m_inventory:UpdateSlots(GAME_LOOP_RATE)

    if m_player ~= nil and m_player:GetPlayerUnit() ~= nil then
        m_camera:Update(GAME_LOOP_RATE)
    end

    if m_helmOfValorInInventory then
        if not m_helmOfValorActive then
            m_helmOfValorTimeRemaining = m_helmOfValorTimeRemaining - GAME_LOOP_RATE

            if m_helmOfValorTimeRemaining <= 0 then
                m_helmOfValorActive = true
                DCEI.ApplyBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[COLLECTIBLE_HELM_OF_VALOR].itemBehaviourName)
            end
        end
    end

    if not m_doorOpenAnimPlayed then
        if m_roomEnemies ~= nil then
            if m_roomEnemies:IsRoomClear() then
                m_doorOpenAnimPlayed = true
                m_roomEnemiesCleared = true

                if not m_isBeginningRoom then
                    m_roomGenerator:MarkRoomAtPlayerPositionClear()
                end
                ActivateDoorOpenAnimations()
            end
        else
            m_doorOpenAnimPlayed = true
            m_roomEnemiesCleared = true
            ActivateDoorOpenAnimations()
        end
    end
end

-- #endregion LifeCycle Functions

-- #region Event Functions

-- #region Unit Events
function HandleUnitDied()
    local unit = DCEI.TriggeringUnit

    -- Just go through all rooms and trigger it
    -- The correct one will automatically trigger

    local unitName = DCEI.UnitName(unit)
    if unitName == PLAYER_NAME_RANGED or unitName == PLAYER_NAME_MELEE and not m_nextRoomTransitionActive then
        m_player:ClearData()
        m_player:Destroy()
        m_player = nil

        m_nextRoomTransitionActive = true
        DisplayGameOverSequence(false)

    elseif m_roomEnemies ~= nil then
        local goldAmount = m_roomEnemies:RemoveDeadEnemy(unit)
        if goldAmount ~= -1 then
            m_player:AddGold(goldAmount)
        end
    end
end

function HandleBehaviourAdded()
    local behaviourName = DCEI.TriggeringBehaviorName
    local unit = DCEI.TriggeringUnit
    local unitName = DCEI.UnitName(unit)

    if behaviourName == PLAYER_COLLISION_BEHAVIOUR then
        if unitName == ROOM_EXIT_DOOR then
            if m_nextRoomTransitionActive or not m_roomEnemiesCleared then
                return
            end

            m_nextRoomTransitionActive = true
            SaveNextRoomData()
            DisplayGameOverSequence(true)

        elseif unitName == EXIT_DOORWAY and unit == m_exitDoor then
            if m_nextRoomTransitionActive or not m_roomEnemiesCleared then
                return
            end

            m_nextRoomTransitionActive = true
            UpdateCollisionWithExitDoor()

        elseif unitName == EXIT_DOORWAY and m_isBeginningRoom then
            if m_nextRoomTransitionActive or not m_roomEnemiesCleared then
                return
            end

            m_nextRoomTransitionActive = true
            SaveNextRoomData()
            DisplayGameOverSequence(true)
        end

    elseif behaviourName == PLAYERCHARACTER_MISSILE_REACHED then
        DCEI.LogMessage("Missile Reached Position")
        local missilePosition = DCEI.GetUnitPosition2D(unit)

        m_player:SetPlayerPosition(missilePosition.x, missilePosition.y)
        m_player:SetDashInActive()

    elseif behaviourName == ENEMY_STUNNED_BEHAVIOUR then
        DCEI.LogMessage("Enemy Stun Behaviour Added")
        if m_roomEnemies ~= nil then
            m_roomEnemies:UpdateEnemyStunState(unit)
        end

    elseif behaviourName == PLAYERCHARACTER_DAMAGED then
        if unitName == PLAYER_NAME_MELEE or unitName == PLAYER_NAME_RANGED then
            if m_helmOfValorActive and m_helmOfValorInInventory then
                DCEI.RemoveBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[COLLECTIBLE_HELM_OF_VALOR].itemBehaviourName)
                m_helmOfValorActive = false
                m_helmOfValorTimeRemaining = COLLECTIBLE_HELM_OF_VALOR_TIMER
            
                m_inventory:ActivateInventorySlotRecharge(InventoryCollectibles[COLLECTIBLE_HELM_OF_VALOR].itemName, COLLECTIBLE_HELM_OF_VALOR_TIMER)
            end
        end
    end
end

function HandleUnitSelected()
    local unit = DCEI.TriggeringUnit
    local unitName = DCEI.UnitName(unit)

    DCEI.LogMessage("Selected Unit: " .. unitName)

    -- Add Collectibles to Inventory if successful
    -- Then destroy the unit
    if string.match(unitName, COLLECTIBLE_STRING) then
        local success = m_inventory:CheckAndAddItemToSlot(unitName)
        if success then
            DCEI.RemoveUnit(unit)
        else
            DCEI.LogError("Inventory is full!!!")
        end

        ApplyInventoryItemBehaviour(unitName)
    end
end
-- #endregion Unit Events

-- #endregion Event Functions

-- #region Utility Fuctions

-- #region Common Game Spawn

function SpawnPlayerAndSetPosition()
    -- Load/Generate Room Data
    local roomType = DCEI.Save.Get(ROOM_NAME)
    if roomType == nil then -- This should be the beginning room
        DCEI.LogMessage("Beginning Room. Generating Rooms")

        m_roomGenerator = RoomGenerator:new(m_randomSeed)
        m_isBeginningRoom = true
    else
        DCEI.LogMessage("Loading Old Room Data")

        m_roomGenerator = RoomGenerator:LoadRoomStructure()
        m_randomSeed = m_roomGenerator:GetRandomSeed()

        math.randomseed(m_randomSeed)
        m_isBeginningRoom = false
    end
    -- Load/Generate Room Data

    -- Spawn Player
    local playerType
    if UseMeleePlayer then
        playerType = 0
    else
        playerType = 1
    end

    local spawnPosition
    local spawnDirection = DCEI.Save.Get(LAST_DIRECTION)

    if spawnDirection == LEFT then
        spawnPosition = m_leftSpawn
    elseif spawnDirection == RIGHT then
        spawnPosition = m_rightSpawn
    elseif spawnDirection == TOP then
        spawnPosition = m_topSpawn
    elseif spawnDirection == BOTTOM then
        spawnPosition = m_bottomSpawn
    else
        if m_leftSpawn ~= nil then
            spawnPosition = m_leftSpawn
        elseif m_rightSpawn ~= nil then
            spawnPosition = m_rightSpawn
        elseif m_topSpawn ~= nil then
            spawnPosition = m_topSpawn
        else
            spawnPosition = m_bottomSpawn
        end
    end

    m_player = Player:new(spawnPosition.x, spawnPosition.y, playerType, m_uiRoot)
    -- Spawn Player

    if m_isBeginningRoom then
        DCEI.TriggerAddTimerEventElapsed(
            function()
                local trapDoor = DCEI.FindUnit(EXIT_DOORWAY)
                local doorPosition = DCEI.GetUnitPosition2D(trapDoor)
                DCEI.CastAbilityAtPosition(EXIT_DOORWAY_OPEN, trapDoor, doorPosition.x, doorPosition.y)
            end,
            1
        )
    end

    ApplyInventoryBehaviours()
end

function SpawnEnemiesAndCloseDoors()
    local spawnEnemies = true

    if m_isBeginningRoom then
        spawnEnemies = false
    end

    if not m_isBeginningRoom and not m_roomGenerator:IsPlayerRoomCleared() then
        m_roomEnemies = RoomEnemies:new(m_player:GetPlayerUnit(), m_roomGenerator)
        ActivateDoorCloseAnimations()
    end
end

function ActivateDoorCloseAnimations()
    DCEI.LogMessage("Playing Close Door Animations")

    local roomDoors = DCEI.FindUnits(ROOM_EXIT_DOOR)
    DCEI.LogMessage("Total Doors: " .. #roomDoors)

    for _, door in ipairs(roomDoors) do
        DCEI.LogMessage("Casting Close Ability")
        DCEI.CastAbility(DOOR_CLOSE_ANIM, door, door)
    end

    if m_exitDoor ~= nil then
        DCEI.CastAbility(EXIT_DOORWAY_CLOSE, m_exitDoor, m_exitDoor)
    end
end

function ActivateDoorOpenAnimations()
    DCEI.LogMessage("Playing Open Door Animations")

    local roomDoors = DCEI.FindUnits(ROOM_EXIT_DOOR)
    DCEI.LogMessage("Total Doors: " .. #roomDoors)

    for _, door in ipairs(roomDoors) do
        DCEI.LogMessage("Casting Open Ability")
        DCEI.CastAbility(DOOR_OPEN_ANIM, door, door)
    end

    if m_exitDoor ~= nil then
        DCEI.LogMessage("Playing Exit Door Animation")
        DCEI.CastAbility(EXIT_DOORWAY_OPEN, m_exitDoor, m_exitDoor)
    end
end

-- #endregion Common Game Spawn

-- #region Doorways

function CheckAndSpawnEntryDoor()
    local playerSpawnRow = m_roomGenerator.currentPlayerRow
    local playerSpawnColumn = m_roomGenerator.currentPlayerColumn

    local spawnRow = m_roomGenerator.spawnRoomRow
    local spawnColumn = m_roomGenerator.spawnRoomColumn

    if playerSpawnRow ~= spawnRow or playerSpawnColumn ~= spawnColumn or m_isBeginningRoom then
        return
    end

    local validPositions = {}
    for i = 1, RoomMod.RoomSize do
        for j = 1, RoomMod.RoomSize do
            if DCEI.GetTerrainTypeAtPoint(i, j) == RoomMod.WalkableTextureId then
                table.insert(validPositions, { x = i, y = j })
            end
        end
    end

    local randomPosition = math.random(1, #validPositions)
    local doorSpawnPoint = validPositions[randomPosition]

    m_entryDoor = DCEI.CreateUnit(0, 0, EXIT_DOORWAY, doorSpawnPoint.x, doorSpawnPoint.y)

    local spawnDirection = DCEI.Save.Get(LAST_DIRECTION)
    if spawnDirection == nil then
        DCEI.SetUnitPosition2D(m_player:GetPlayerUnit(), doorSpawnPoint.x, doorSpawnPoint.y)
        DCEI.Move(m_player:GetPlayerUnit(), doorSpawnPoint.x, doorSpawnPoint.y)
    end

    DCEI.TriggerAddTimerEventElapsed(
        function()
            DCEI.CastAbilityAtPosition(EXIT_DOORWAY_CLOSE, m_entryDoor, doorSpawnPoint.x, doorSpawnPoint.y)
        end,
        1
    )
end

function CheckAndSpawnExitDoor()
    if m_isBeginningRoom then
        return
    end

    local playerSpawnRow = m_roomGenerator.currentPlayerRow
    local playerSpawnColumn = m_roomGenerator.currentPlayerColumn
    
    local exitRoomRow = m_roomGenerator.exitRoomRow
    local exitRoomColumn = m_roomGenerator.exitRoomColumn

    if playerSpawnRow ~= exitRoomRow or playerSpawnColumn ~= exitRoomColumn then
        return
    end

    local validPositions = {}
    for i = 1, RoomMod.RoomSize do
        for j = 1, RoomMod.RoomSize do
            if DCEI.GetTerrainTypeAtPoint(i, j) == RoomMod.WalkableTextureId then
                table.insert(validPositions, { x = i, y = j })
            end
        end
    end

    local randomPosition = math.random(1, #validPositions)
    local doorSpawnPoint = validPositions[randomPosition]

    m_exitDoor = DCEI.CreateUnit(0, 0, EXIT_DOORWAY, doorSpawnPoint.x, doorSpawnPoint.y)
end

function UpdateCollisionWithExitDoor()
    local maskOptions = {
        color = { r = 0, g = 0, b = 0 },
        duration = 1
    }

    DCEI.ShowScreenMaskWithAlpha(1, maskOptions)
    DCEI.Wait(maskOptions.duration)

    m_roomGenerator:ClearSaveData()
    m_inventory:SaveInventory()
    m_player:SaveData()

    DCEI.Save.Set(ROOM_NAME, nil) -- Reset to beginning room
    DCEI.Save.Set(LAST_DIRECTION, nil)
    DCEI.Save.Commit()
    DCEI.Wait(1)
    DCEI.PlayLevel(BEGINNING_ROOM_PATH, BEGINNING_ROOM_NAME)
end

-- #endregion Doorways

-- #region GameOver State

function SaveNextRoomData()
    if not m_isBeginningRoom then
        DCEI.LogMessage("Saving Next Room Data")

        local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
        local direction = ""
        
        if playerPosition.x < RoomMod.MinDirectionPosition then
            m_roomGenerator.currentPlayerColumn = m_roomGenerator.currentPlayerColumn - 1
            direction = RIGHT
        elseif playerPosition.x > RoomMod.MaxDirectionPosition then
            m_roomGenerator.currentPlayerColumn = m_roomGenerator.currentPlayerColumn + 1
            direction = LEFT
        elseif playerPosition.y < RoomMod.MinDirectionPosition then
            m_roomGenerator.currentPlayerRow = m_roomGenerator.currentPlayerRow + 1
            direction = TOP
        elseif playerPosition.y > RoomMod.MaxDirectionPosition then
            m_roomGenerator.currentPlayerRow = m_roomGenerator.currentPlayerRow - 1
            direction = BOTTOM
        else
            DCEI.LogError("Invalid Bounds?!!")
        end

        DCEI.Save.Set(LAST_DIRECTION, direction)
        DCEI.Save.Commit()

        m_roomGenerator:SaveRoomStructure()
    else
        DCEI.Save.Set(LAST_DIRECTION, nil)
        DCEI.Save.Commit()
    end

    -- Only Save when going into the new room
    m_inventory:SaveInventory() 
    m_player:SaveData() -- Ideally in this case, the player will not be destroyed
end

function DisplayGameOverSequence(playerWon)
    local maskOptions = {
        color = { r = 0, g = 0, b = 0 },
        duration = 1
    }

    DCEI.ShowScreenMaskWithAlpha(1, maskOptions)
    DCEI.Wait(maskOptions.duration)

    if m_player ~= nil then
        m_player:Destroy()
        m_player = nil
    end
    m_camera:UpdateTarget(nil)

    if playerWon then
        DCEI.LogMessage("X: " .. m_roomGenerator.currentPlayerColumn .. ", Y: " .. m_roomGenerator.currentPlayerRow)
        local roomName = m_roomGenerator:GetRoomFromPlayerPosition()
        local roomPath = RoomMod.GetRoomPath(roomName)

        DCEI.Save.Set(ROOM_NAME, roomName)
        DCEI.Save.Commit()
        DCEI.Wait(1)
        DCEI.PlayLevel(roomPath, roomName)
    else
        m_roomGenerator:ClearSaveData()
        m_inventory:ClearInventorySave()

        DCEI.Save.Set(ROOM_NAME, nil) -- Reset to beginning room
        DCEI.Save.Set(LAST_DIRECTION, nil)
        DCEI.Save.Commit()
        DCEI.Wait(1)
        DCEI.PlayLevel(BEGINNING_ROOM_PATH, BEGINNING_ROOM_NAME)
    end
end

-- #endregion GameOver State

-- #region Player Functions

function UpdatePlayerHealth(deltaTime)
    if m_player == nil then
        return
    end

    if m_player:GetPlayerUnit() == nil then
        return
    end

    local playerHealth = DCEI.GetHealthValue(m_player:GetPlayerUnit())
    local lastFramePlayerHealth = m_player:GetPlayerLastFrameHealth()

    if lastFramePlayerHealth > playerHealth then
        m_camera:StartShakeWithUnit(1, 0)
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), PLAYER_INVINCIBLE_BEHAVIOUR)

        m_playerInvincibilityTimer = PlayerInvincibleTimer
        m_playerDamageUiFlashCount = PlayerDamageFlashCount
        m_playerDamageUiIsFlashOn = false
    end

    if m_playerInvincibilityTimer > 0 then
        m_playerInvincibilityTimer = m_playerInvincibilityTimer - deltaTime

        if m_playerInvincibilityTimer <= 0 then
            DCEI.RemoveBehavior(m_player:GetPlayerUnit(), PLAYER_INVINCIBLE_BEHAVIOUR)
        end
    end
end

-- #endregion Player Functions

-- #region UI Functions

function CreateBaseUIElements()
    m_uiRoot = DCEI.GetUiRoot()

    local bottomFrame = DCEI.NewFrame(m_uiRoot)
    local middleFrame = DCEI.NewFrame(m_uiRoot)
    local topFrame = DCEI.NewFrame(m_uiRoot)

    DCEI.SetMatchParent(bottomFrame, true, true)
    DCEI.SetMatchParent(middleFrame, true, true)
    DCEI.SetMatchParent(topFrame, true, true)

    m_uiBottomLayer = bottomFrame
    m_uiMiddleLayer = middleFrame
    m_uiTopLayer = topFrame
end

function CreatePlayerDamageDisplay()
    local damageDisplay = DCEI.NewFrame(m_uiTopLayer)
    DCEI.SetMatchParent(damageDisplay, true, true)
    DCEI.SetBackgroundImage(damageDisplay, "ui_mask_blurry")
    DCEI.SetBackgroundImageColor(damageDisplay, 1, 1, 1, 0)

    m_damageDisplay = damageDisplay
end

function CreatePlayerGoldDisplay()
    local playerGoldStack = DCEI.NewHStack(m_uiMiddleLayer)
    DCEI.SetTopAlignmentInParent(playerGoldStack)
    DCEI.SetLeftAlignmentInParent(playerGoldStack)
    DCEI.SetPaddingTop(playerGoldStack, 21)
    DCEI.SetPaddingLeft(playerGoldStack, 140)
    DCEI.SetSpacing(playerGoldStack, 14)
    
    local playerGoldImage = DCEI.NewFrame(playerGoldStack)
    DCEI.SetMinSize(playerGoldImage, 50, 54)
    DCEI.SetBackgroundImage(playerGoldImage, "icon_affinity_gold")

    local playerGoldText = DCEI.NewText(playerGoldStack)
    DCEI.SetTextFontSize(playerGoldText, 30)
    m_playerGoldDisplay = playerGoldText
end

function CreateDebugUI()
    local horizontalStack = DCEI.NewHStack(m_uiMiddleLayer)
    DCEI.SetTopAlignmentInParent(horizontalStack)
    DCEI.SetLeftAlignmentInParent(horizontalStack)
    DCEI.SetPaddingTop(horizontalStack, 21)
    DCEI.SetPaddingLeft(horizontalStack, 21)
    DCEI.SetSpacing(horizontalStack, 14)

    local characterButton = DCEI.NewButton(horizontalStack)
    DCEI.SetMinSize(characterButton, 50, 50)
    DCEI.SetBackgroundImage(characterButton, "icon_enhance_crusader_punish")
    DCEI.SetOnClickCallback(characterButton, HandleCharacterSwitch)
end

function UpdatePlayerDamageUI(deltaTime)
    if m_playerDamageUiFlashCount > 0 then
        m_playerDamageUiFlashTimer = m_playerDamageUiFlashTimer - deltaTime

        if m_playerDamageUiFlashTimer <= 0 then
            if m_playerDamageUiIsFlashOn then
                DCEI.SetBackgroundImageColor(m_damageDisplay, 1, 1, 1, 0) -- Hide the Image
                m_playerDamageUiFlashCount = m_playerDamageUiFlashCount - 1
            else
                DCEI.SetBackgroundImageColor(m_damageDisplay, 1, 0, 0, 1) -- Display a Red Image
            end

            m_playerDamageUiIsFlashOn = not m_playerDamageUiIsFlashOn

            if m_playerDamageUiFlashCount ~= 0 then
                m_playerDamageUiFlashTimer = PlayerDamageFlashTimer
            end
        end
    end
end

function HandleCharacterSwitch()
    local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
    RemoveInventoryBehaviours()

    m_player:Destroy()
    m_player = nil

    local playerType
    if UseMeleePlayer then
        playerType = 0
    else
        playerType = 1
    end
    
    m_player = Player:new(playerPosition.x, playerPosition.y, playerType, m_uiRoot)

    UseMeleePlayer = not UseMeleePlayer

    ApplyInventoryBehaviours()

    m_camera:UpdateTarget(m_player:GetPlayerUnit())
    m_player:SetPlayerCamera(m_camera)
end

-- #endregion

-- #region Inventory Functions

function CreateInventoryUI()
    local horizontalStack = DCEI.NewHStack(m_uiMiddleLayer)
    DCEI.SetTopAlignmentInParent(horizontalStack)
    DCEI.SetPaddingTop(horizontalStack, 21)

    local inventoryItems = {}
    
    for i = 0, 3 do
        local inventoryItem = InventorySlot:new(
            "btn_yellow_invert", 
            "btn_grey_invert", 
            horizontalStack, 
            HandleInventorySlotClicked,
            HandleInventoryItemDropped
        )
        table.insert(inventoryItems, inventoryItem)
    end

    local inventory = Inventory:new(inventoryItems)
    m_inventory = inventory
end

function LoadInventoryFromSave()
    -- This must be done after the player is created as the behaviours will be added to the player
    m_inventory:LoadInventory()
    ApplyInventoryBehaviours()
end

function ApplyInventoryBehaviours()
    local slots = m_inventory:GetInventorySlots()
    for i, slot in ipairs(slots) do
        local itemName = slot:GetInventoryItemName()
        ApplyInventoryItemBehaviour(itemName)
        
        if itemName == COLLECTIBLE_HELM_OF_VALOR then
            m_helmOfValorTimeRemaining = slot.currentRechargeTime    
        end
    end
end

function RemoveInventoryBehaviours()
    local slots = m_inventory:GetInventorySlots()
    for i, slot in ipairs(slots) do
        local itemName = slot:GetInventoryItemName()
        RemoveInventoryItemBehaviour(itemName)
    end
end

function ApplyInventoryItemBehaviour(itemName)
    if itemName == COLLECTIBLE_BOOTS_OF_SPEED then
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[itemName].itemBehaviourName)
    elseif itemName == COLLECTIBLE_HAMMER_OF_ATTACK then
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[itemName].itemBehaviourName)
    elseif itemName == COLLECTIBLE_HELM_OF_VALOR then
        m_helmOfValorInInventory = true
        m_helmOfValorActive = false
        m_helmOfValorTimeRemaining = 0
    end
end

function RemoveInventoryItemBehaviour(itemName)
    if itemName == COLLECTIBLE_BOOTS_OF_SPEED then
        DCEI.RemoveBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[itemName].itemBehaviourName)
    elseif itemName == COLLECTIBLE_HAMMER_OF_ATTACK then
        DCEI.RemoveBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[itemName].itemBehaviourName)
    elseif itemName == COLLECTIBLE_HELM_OF_VALOR then
        m_helmOfValorInInventory = false
        m_helmOfValorActive = false
        m_helmOfValorTimeRemaining = 0

        DCEI.RemoveBehavior(m_player:GetPlayerUnit(), InventoryCollectibles[itemName].itemBehaviourName)
    end
end

function HandleInventoryItemDropped(itemName, inventorySlot)
    if itemName == "" then
        DCEI.LogMessage("Slot Already Empty")
        return
    end

    local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
    DCEI.CreateUnit(1, 1, itemName, playerPosition.x, playerPosition.y)

    RemoveInventoryItemBehaviour(itemName)
    inventorySlot:DropInventoryItem()
end

function HandleInventorySlotClicked(itemName, inventorySlot)
    if m_player == nil then
        return
    end

    DCEI.LogMessage("Selected Item: " .. itemName)

    if itemName == COLLECTIBLE_POTION then
        local healthAmount = InventoryCollectibles[itemName].itemPotionHealth
        local potionBehaviour = InventoryCollectibles[itemName].itemBehaviourName

        DCEI.LogMessage("Adding Player Health: " .. healthAmount)
        DCEI.AddHealth(m_player:GetPlayerUnit(), healthAmount)
        DCEI.ApplyBehavior(m_player:GetPlayerUnit(), potionBehaviour)
        
        inventorySlot:UseItem()
        
    elseif itemName == COLLECTIBLE_BOMB then
        local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
        local bombUnitName = InventoryCollectibles[itemName].itemBombName

        DCEI.LogMessage("Deploying Bomb...")
        DCEI.CreateUnit(0, 0, bombUnitName, playerPosition.x, playerPosition.y)

        inventorySlot:UseItem()

    else
        local playerPosition = DCEI.GetUnitPosition2D(m_player:GetPlayerUnit())
        DCEI.CreateUnit(1, 1, itemName, playerPosition.x, playerPosition.y)

        RemoveInventoryItemBehaviour(itemName)
        inventorySlot:DropInventoryItem()
    end
end

-- #endregion Inventory Functions

-- #endregion Utility Fuctions

return mod