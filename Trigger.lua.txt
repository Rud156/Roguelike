local ArcadeCore = GameModules["Arcade/Core"] -- Maybe be required

-- Extension Functions
function VectorDistance(vectorA, vectorB)
    local x = vectorA.x - vectorB.x
    local y = vectorA.y - vectorB.y

    return math.sqrt(x * x + y * y)
end
function To360Angle(rotationDeg)
    while rotationDeg < 0 do
        rotationDeg = rotationDeg + 360
    end
    while rotationDeg > 360 do
        rotationDeg = rotationDeg - 360
    end

    return rotationDeg
end

-- Rectangle Class
Rect = { x = 0, y = 0, width = 0, height = 0 }
Rect.__index = Rect
function Rect:new(x, y, width, height)
    local rect = {}
    setmetatable(rect, Rect)
    
    rect.x = x
    rect.y = y
    rect.width = width
    rect.height = height

    return rect
end
function Rect:center()
    local xPosition = self.x + self.width / 2.0
    local yPosition = self.y + self.height / 2.0

    return xPosition, yPosition
end
function Rect:topLeft()
    return self.x, self.y
end
function Rect:bottomRight()
    return self.x + self.width, self.y + self.height
end
function Rect:overlaps(rect)
    return self.x < rect.x + rect.width and self.x + self.width > rect.x and
            self.y < rect.y + rect.height and self.y + self.height > rect.y
end
function Rect:contains(xPosition, yPosition)
    return self.x <= xPosition and self.x + self.width >= xPosition and 
            self.y <= yPosition and self.y + self.height >= yPosition
end

-- Room Data Class
RoomData = { 
    rect = nil, 
    
    -- Walls
    solidWalls = {}, 
    breakableWalls = {}, 
    
    -- Other Positions
    enemySpawnPositions = {}, 
    collectiblePositions = {},
    emptyPositions = {},

    -- Exits
    roomExits = {},
    roomExitPositions = {},
    roomExitPrefab = "",

    -- Spawn Info
    playerInRoom = false,
    roomCleared = false,

    -- Room Enemies
    enemies = {},
    enemyPositions = {},
    enemyPrefabs = {},
    totalWaveCount = 0,
    currentWaveCount = 0
}
RoomData.__index = RoomData
-- Patterns contains Map Generation data
-- 0: Solid Wall
-- 1: Breakable Wall
-- 2: Doorway
-- 3: Enemy Spawn Positions
-- 4: Collectible Positions
-- This is just a basic map template for testing
function RoomData:new(
    rect, pattern, 
    totalWaveCount,
    solidWallPrefab, breakableWallPrefab, doorwayPrefab,
    enemyPrefabs, collectiblePrefabs
)
    local roomData = {}
    setmetatable(roomData, RoomData)

    roomData.rect = rect

    roomData.solidWalls = {}
    roomData.breakableWalls = {}
    
    roomData.enemySpawnPositions = {}
    roomData.collectiblePositions = {}
    roomData.emptyPositions = {}

    roomData.roomExits = {}
    roomData.roomExitPositions = {}
    roomData.roomExitPrefab = doorwayPrefab
    
    roomData.playerInRoom = false
    roomData.roomCleared = false

    roomData.enemies = {}
    roomData.enemyPositions = {}
    roomData.enemyPrefabs = enemyPrefabs
    roomData.totalWaveCount = totalWaveCount
    roomData.currentWaveCount = 0

    local startX = rect.x
    local startY = rect.y

    for i = 1, #pattern do
        for j = 1, #pattern[i] do
            local patternValue = pattern[i][j]
            local xPosition = startX + i
            local yPosition = startY + j

            if patternValue == 0 then
                local solidWallInstance = DCEI.CreateUnit(0, 0, solidWallPrefab, xPosition, yPosition)
                table.insert(roomData.solidWalls, solidWallInstance)

            elseif patternValue == 1 then
                local breakableWallInstance = DCEI.CreateUnit(0, 0, breakableWallPrefab, xPosition, yPosition)
                table.insert(roomData.breakableWalls, breakableWallInstance)

            elseif patternValue == 2 then
                local doorwayPosition = { x = xPosition, y = yPosition }
                table.insert(roomData.roomExitPositions, doorwayPosition)
                
            elseif patternValue == 3 then
                local enemyPosition = { x = xPosition, y = yPosition }
                table.insert(roomData.enemyPositions, enemyPosition)

            elseif patternValue == 4 then
                -- TODO: Complete this part...

            elseif patternValue == 5 then
                local emptyPosition = { x = xPosition, y = yPosition }
                table.insert(roomData.emptyPositions, emptyPosition)
            else
                DCEI.LogMessage("Invalid Tile ID")
            end
        end
    end

    return roomData
end
function RoomData:UpdateEnemies(deltaTime, player)
    local playerPosition = DCEI.GetUnitPosition2D(player)
    for i, enemy in ipairs(self.enemies) do
        enemy:Update(deltaTime, playerPosition)
    end
end
function RoomData:IsPlayerInRoom(player)
    if self.playerInRoom then
        return
    end

    local playerPosition = DCEI.GetUnitPosition2D(player)
    if self.rect:contains(playerPosition.x, playerPosition.y) then
        self:InitializePlayerEntered()
    end
end
function RoomData:InitializePlayerEntered()
    if self.roomCleared then
        return -- Don't do anything as the player has already cleared the room
    end

    self.playerInRoom = true
    self:CreateDoors()
    self:SpawnNextWave()
end
function RoomData:RemovedDeadEnemy(enemyUnit)
    if not self.playerInRoom then
        return
    end

    local index = -1
    for i, enemy in ipairs(self.enemies) do
        if enemy:GetMainUnit() == enemyUnit then
            index = i
            break
        end
    end

    if index ~= -1 then
        local enemyClassInstance = self.enemies[index]
        enemyClassInstance:CleanupEnemyDied()
        table.remove(self.enemies, index)
    end

    local totalEnemyCount = #self.enemies
    if totalEnemyCount == 0 then
        self:SpawnNextWave()
    end
end
function RoomData:SpawnNextWave()
    if self.currentWaveCount >= self.totalWaveCount then
        self:MarkRoomCleared()
        return
    end

    for i, enemyPosition in ipairs(self.enemyPositions) do
        local randomValue = math.random()
        if randomValue <= 0.25 then
            local randomEnemyIndex = math.random(1, #self.enemyPrefabs)
            local randomEnemy = self.enemyPrefabs[randomEnemyIndex]
            local enemy

            if randomEnemy.isMulti then
                enemy = MultiAttackEnemy:new(
                    self,
                    randomEnemy.name, randomEnemy.blankUnitName,
                    5,
                    randomEnemy.ability, 2.5,
                    enemyPosition.x, enemyPosition.y
                )
            else
                enemy = SingleAttackEnemy:new(
                    self,
                    randomEnemy.name, randomEnemy.ability,
                    1,
                    enemyPosition.x, enemyPosition.y
                )
            end
            
            table.insert(self.enemies, enemy)
        end
    end

    self.currentWaveCount = self.currentWaveCount + 1
end
function RoomData:MarkRoomCleared()
    self.roomCleared = true
    self:RemoveDoors()
end
function RoomData:CreateDoors()
    for i, doorwayPosition in ipairs(self.roomExitPositions) do
        local doorway = DCEI.CreateUnit(0, 0, self.roomExitPrefab, doorwayPosition.x, doorwayPosition.y)
        table.insert(self.roomExits, doorway)
    end
end
function RoomData:RemoveDoors()
    for i, doorway in ipairs(self.roomExits) do
        DCEI.RemoveUnit(doorway)
    end

    self.roomExits = {}
end
function RoomData:GetNearestEnemy(player)
    if not self.playerInRoom then
        return nil
    end

    local playerPosition = DCEI.GetUnitPosition2D(player)
    local lastNearestEnemy = nil
    local lastEnemyDistance = 100

    for i, enemyUnit in ipairs(self.enemies) do
        local enemyPosition = DCEI.GetUnitPosition2D(enemyUnit:GetMainUnit())
        local distance = VectorDistance(playerPosition, enemyPosition)
        
        if distance < lastEnemyDistance then
            lastNearestEnemy = enemyUnit:GetMainUnit()
            lastEnemyDistance = distance
        end
    end

    return lastNearestEnemy
end
function RoomData:GetEmptyPositions()
    return self.emptyPositions
end

-- Single Attack Enemy
local ENEMY_REACHED_DISTANCE = 3
SingleAttackEnemy = {
    -- Units
    room = nil,
    unit = nil,

    -- Static Data
    attackName = "",

    -- Movement/Attack
    targetPosition = nil,
    attackTimer = 0,
    currentTimer = 0,
}
SingleAttackEnemy.__index = SingleAttackEnemy
function SingleAttackEnemy:new(room, enemyName, attackName, attackTimer, xPosition, yPosition)
    local singleAttackEnemy = {}
    setmetatable(singleAttackEnemy, SingleAttackEnemy)

    local enemyUnit = DCEI.CreateUnit(-1, -1, enemyName, xPosition, yPosition)
    singleAttackEnemy.room = room
    singleAttackEnemy.unit = enemyUnit

    singleAttackEnemy.attackName = attackName

    singleAttackEnemy.targetPosition = nil
    singleAttackEnemy.attackTimer = attackTimer
    singleAttackEnemy.currentTimer = attackTimer

    return singleAttackEnemy
end
function SingleAttackEnemy:Update(deltaTime, playerPosition)
    if self.targetPosition == nil then
        self:SetRandomEnemyMovePosition()
    else
        local currentPosition = DCEI.GetUnitPosition2D(self.unit)
        local distance = VectorDistance(self.targetPosition, currentPosition)
        if distance < ENEMY_REACHED_DISTANCE then
            self:SetRandomEnemyMovePosition()
        end
    end

    DCEI.Move(self.unit, self.targetPosition.x, self.targetPosition.y)

    self.currentTimer = self.currentTimer - deltaTime
    if self.currentTimer <= 0 then
        DCEI.CastAbilityAtPosition(self.attackName, self.unit, playerPosition.x, playerPosition.y)
        self.currentTimer = self.attackTimer
    end
end
function SingleAttackEnemy:SetRandomEnemyMovePosition()
    local positions = self.room:GetEmptyPositions()
    local randomIndex = math.random(1, #positions)

    self.targetPosition = positions[randomIndex]
end
function SingleAttackEnemy:GetMainUnit()
    return self.unit
end
function SingleAttackEnemy:CleanupEnemyDied()
    -- Do nothing here...
end

-- Multi Attack Enemy
MultiAttackEnemy = {
    -- Units
    room = nil,
    mainUnit = nil,
    blankUnits = {},
    totalUnits = 0,

    -- Static Data
    attackName = "",

    -- Movement/Attack
    targetPosition = nil,
    attackTimer = 0,
    currentTimer = 0,
}
MultiAttackEnemy.__index = MultiAttackEnemy
function MultiAttackEnemy:new(room, enemyName, blankEnemyName, totalUnits, attackName, attackTimer, xPosition, yPosition)
    local multiAttackEnemy = {}
    setmetatable(multiAttackEnemy, MultiAttackEnemy)

    local enemyUnit = DCEI.CreateUnit(-1, -1, enemyName, xPosition, yPosition)
    multiAttackEnemy.room = room
    multiAttackEnemy.mainUnit = enemyUnit
    multiAttackEnemy.blankUnits = {}
    multiAttackEnemy.totalUnits = totalUnits

    multiAttackEnemy.attackName = attackName

    multiAttackEnemy.targetPosition = nil
    multiAttackEnemy.attackTimer = attackTimer
    multiAttackEnemy.currentTimer = attackTimer

    for i = 1, totalUnits do
        local unit = DCEI.CreateUnit(-1, -1, blankEnemyName, xPosition, yPosition)
        table.insert(multiAttackEnemy.blankUnits, unit)
    end

    return multiAttackEnemy
end
function MultiAttackEnemy:Update(deltaTime, playerPosition)
    if self.targetPosition == nil then
        self:SetRandomEnemyMovePosition()
    else
        local currentPosition = DCEI.GetUnitPosition2D(self.mainUnit)
        local distance = VectorDistance(self.targetPosition, currentPosition)
        if distance < ENEMY_REACHED_DISTANCE then
            self:SetRandomEnemyMovePosition()
        end
    end

    DCEI.Move(self.mainUnit, self.targetPosition.x, self.targetPosition.y)
    local mainUnitPosition = DCEI.GetUnitPosition2D(self.mainUnit)
    for i, unit in ipairs(self.blankUnits) do
        DCEI.SetUnitPosition2D(unit, mainUnitPosition.x, mainUnitPosition.y)
    end

    self.currentTimer = self.currentTimer - deltaTime
    if self.currentTimer <= 0 then
        self:AttackCirclePattern(playerPosition)
        self.currentTimer = self.attackTimer
    end
end
function MultiAttackEnemy:AttackCirclePattern(playerPosition)
    local currentPosition = DCEI.GetUnitPosition2D(self.mainUnit)
    local distance = VectorDistance(currentPosition, playerPosition)

    local angleDiff = 360.0 / self.totalUnits
    local currentAngle = 0

    for i, unit in ipairs(self.blankUnits) do
        local xPosition = math.cos(math.rad(currentAngle)) * distance + currentPosition.x
        local yPosition = math.sin(math.rad(currentAngle)) * distance + currentPosition.y

        DCEI.CastAbilityAtPosition(self.attackName, unit, xPosition, yPosition)

        currentAngle = currentAngle + angleDiff
    end
end
function MultiAttackEnemy:SetRandomEnemyMovePosition()
    local positions = self.room:GetEmptyPositions()
    local randomIndex = math.random(1, #positions)

    self.targetPosition = positions[randomIndex]
end
function MultiAttackEnemy:GetMainUnit()
    return self.mainUnit
end
function MultiAttackEnemy:CleanupEnemyDied()
    for i, unit in ipairs(self.blankUnits) do
        DCEI.RemoveUnit(unit)
    end

    self.blankUnits = {}
end

-- Variables
-- Prefabs
local SOLID_WALL_PREFAB = "Wall"
local BREAKABLE_WALL_PREFAB = "Breakable Wall"
local DOORWAY = "Doorway"
local ENEMY_PREFABS = {
    {
        name = "Ranged Enemy Type 1",
        ability = "Ranged Enemy Type 1 Ability",
        isMulti = false
    },
    {
        name = "Ranged Enemy Type 2",
        blankUnitName = "Ranged Enemy Type 2 Blank",
        ability = "Ranged Enemy Type 2 Ability",
        isMulti = true
    }
}
local COLLECTIBLE_PREFAB = "Collectible"
local WORLD_WIDTH = 30
local WORLD_HEIGHT = 30
local GAME_LOOP_RATE = 0.0625
local BASE_ROOM_SIZE = 10 -- TODO: Use room size from template later on...

-- Player
local PLAYER_NAME = "Player Character"
local PLAYER_WEAPON_1 = "Player Character Weapon 1 Ability"
local PLAYER_WEAPON_2 = "Player Character Weapon 2 Ability"
local PLAYER_COLLISION_BEHAVIOUR = "Player Character Collision Detected Behaviour"

-- Public Variables
-- Room
local RoomSize = 10
local RoomTemplates = {
    {
        {0, 0, 0, 0, 0, 2, 0, 0, 0, 0},
        {0, 5, 3, 5, 5, 3, 3, 5, 5, 0},
        {2, 5, 5, 0, 0, 0, 5, 5, 5, 0},
        {2, 0, 1, 5, 5, 5, 3, 5, 3, 2},
        {0, 5, 1, 1, 5, 1, 3, 5, 5, 0},
        {0, 5, 1, 1, 5, 5, 5, 5, 5, 0},
        {0, 5, 5, 3, 5, 5, 5, 5, 5, 0},
        {0, 5, 5, 1, 1, 1, 3, 5, 5, 0},
        {0, 5, 5, 5, 5, 5, 5, 5, 5, 0},
        {0, 0, 0, 0, 0, 2, 0, 0, 0, 0},
    }
}
-- Waves
local MinWaveCount = 1
local MaxWaveCount = 3
-- Player
local PlayerSpawnPosition = { x = 27, y = 27 }
local PlayerDashTimer = 0.3
local PlayerDashSpeed = 5
-- Mouse
local SingleClickTriggerTime = 0.3

-- Private Variables
local m_rooms = {}
local m_player
local m_dashTimer = 0
local m_dashVelocity = { x = 0, y = 0 }
local m_mouseDownTimer = -1
local m_mouseDownTriggered = false
local m_mousePosition = 0

-- LifeCycle Functions
function Start()
    math.randomseed(os.time())

    local xCounter = 0
    local yCounter = 0
    local i = 0
    local j = 0

    while j < WORLD_HEIGHT do
        while i < WORLD_WIDTH do
            -- Don't Spawn the Last Room
            if i == WORLD_WIDTH - BASE_ROOM_SIZE and j == WORLD_HEIGHT - BASE_ROOM_SIZE then
                break
            end

            local rect = Rect:new(i, j, BASE_ROOM_SIZE, BASE_ROOM_SIZE)
            local randomPatternIndex = math.random(1, #RoomTemplates)
            local randomWaveCount = math.random(MinWaveCount, MaxWaveCount)
            
            local roomData = RoomData:new(
                rect, RoomTemplates[randomPatternIndex],
                randomWaveCount,
                SOLID_WALL_PREFAB, BREAKABLE_WALL_PREFAB, DOORWAY,
                ENEMY_PREFABS, COLLECTIBLE_PREFAB
            )
            table.insert(m_rooms, roomData)

            i = i + BASE_ROOM_SIZE
        end
        j = j + BASE_ROOM_SIZE
        i = 0
    end

    m_player = DCEI.CreateUnit(1, 1, PLAYER_NAME, PlayerSpawnPosition.x, PlayerSpawnPosition.y)

    DCEI.TriggerAddUnitDiedEvent(DCEI.UnitAny, HandleUnitDied)
    DCEI.TriggerAddBehaviorAddEvent(DCEI.UnitAny, HandleBehaviourAdded)
    DCEI.TriggerAddTimerEventPeriodicIndefinite(Update, GAME_LOOP_RATE)

    DCEI.SetCameraDistanceSmooth(20)

    DCEI.TriggerAddMouseDownEvent(0, HandleLeftMouseDownEvent)
    DCEI.TriggerAddMouseUpEvent(0, HandleLeftMouseUpEvent)
    DCEI.TriggerAddJoystickEvent(HandleJoystickMoved)
end

function Update()
    for i, room in ipairs(m_rooms) do
        room:IsPlayerInRoom(m_player)
        room:UpdateEnemies(GAME_LOOP_RATE, m_player)
    end

    if m_player ~= nil then
        local position = DCEI.GetUnitPosition2D(m_player)
        DCEI.SetCameraFocusSmooth(position.x, position.y, true)

        if m_dashTimer > 0 then
            UpdatePlayerDashMovement(GAME_LOOP_RATE)
        end
    end

    if m_mouseDownTriggered then
        m_mouseDownTimer = m_mouseDownTimer + GAME_LOOP_RATE
        
    end
end

-- Event Functions

-- Unit Events
function HandleUnitDied()
    local unit = DCEI.TriggeringUnit

    -- Just go through all rooms and trigger it
    -- The correct one will automatically trigger
    for i, room in ipairs(m_rooms) do
        room:RemovedDeadEnemy(unit)
    end

    local unitName = DCEI.UnitName(unit)
    if unitName == PLAYER_NAME then
        -- TODO: Do something when the player dies...
    end
end

function HandleBehaviourAdded()
    local behaviourName = DCEI.TriggeringBehaviorName

    if behaviourName == PLAYER_COLLISION_BEHAVIOUR then
        DCEI.LogMessage("Player Collided")
    end
end

-- Unit Events

-- Mouse Events
function HandleLeftMouseDownEvent(mousePosition)
    UpdateMousePosition(mousePosition)
    m_mouseDownTriggered = true
    m_mouseDownTimer = 0
end

function HandleLeftMouseUpEvent(mousePosition)
    UpdateMousePosition(mousePosition)

    if m_mouseDownTriggered then
        if m_mousePosition == 1 then
            if m_mouseDownTimer <= SingleClickTriggerTime then
                LaunchPlayerLightAttack(mousePosition)
            else
                LaunchPlayerHeavyAttack(mousePosition)
            end
        elseif m_mousePosition == -1 then
            MakePlayerDodgeAndRoll()
        end
    end

    m_mouseDownTriggered = false
    m_mouseDownTimer = 0
end

function UpdateMousePosition(mousePosition)
    if m_player ~= nil then
        local playerPosition = DCEI.GetUnitPosition2D(m_player)
        if mousePosition.x < playerPosition.x then
            m_mousePosition = -1
        elseif mousePosition.x > playerPosition.x then
            m_mousePosition = 1
        else
            m_mousePosition = 0
        end
    end
end
-- Mouse Events

-- Joystick Events
function HandleJoystickMoved()
    -- When Dashing the Player cannot move normally
    if m_player == nil or m_dashTimer > 0 then
        return
    end

    local axes = DCEI.TriggeringJoystickAxes
    local playerPosition = DCEI.GetUnitPosition2D(m_player)

    DCEI.Move(m_player, playerPosition.x + axes.x, playerPosition.y + axes.y)
end
-- Joystick Events


-- Utility Fuctions
function LaunchPlayerLightAttack(mousePosition)
    if m_player == nil then
        DCEI.LogMessage("Player Died")
        return
    end

    local abilityCasted = false

    for i, room in ipairs(m_rooms) do
        local enemy = room:GetNearestEnemy(m_player)
        if enemy ~= nil then
            local position = DCEI.GetUnitPosition2D(enemy)
            DCEI.CastAbilityAtPosition(PLAYER_WEAPON_1, m_player, position.x, position.y)
            abilityCasted = true
            break                
        end
    end

    if not abilityCasted then
        DCEI.CastAbilityAtPosition(PLAYER_WEAPON_1, m_player, mousePosition.x, mousePosition.y)
    end
end

function LaunchPlayerHeavyAttack(mousePosition)
    if m_player == nil then
        DCEI.LogMessage("Player Died")
        return
    end

    local abilityCasted = false

    for i, room in ipairs(m_rooms) do
        local enemy = room:GetNearestEnemy(m_player)
        if enemy ~= nil then
            local position = DCEI.GetUnitPosition2D(enemy)
            DCEI.CastAbilityAtPosition(PLAYER_WEAPON_2, m_player, position.x, position.y)
            abilityCasted = true
            break
        end
    end

    if not abilityCasted then
        DCEI.CastAbilityAtPosition(PLAYER_WEAPON_2, m_player, mousePosition.x, mousePosition.y)
    end
end

function MakePlayerDodgeAndRoll()
    if m_player == nil then
        DCEI.LogMessage("Player Died")
        return
    end

    local playerRotation = DCEI.GetUnitRotationEuler(m_player)
    local yRotation = playerRotation.y
    -- Everything is different in the mirror world
    if playerRotation.x == -180.0 or playerRotation.z == -180.0 then -- Bad hack but the engine does not return consistent Y Rotations
        if playerRotation.y < 0 then
            yRotation = yRotation + 270.0
        else
            yRotation = yRotation + 90
        end
    end

    local xVelocity = math.sin(math.rad(yRotation)) * PlayerDashSpeed
    local yVelocity = math.cos(math.rad(yRotation)) * PlayerDashSpeed
    m_dashVelocity.x = xVelocity
    m_dashVelocity.y = yVelocity
    m_dashTimer = PlayerDashTimer
end

function UpdatePlayerDashMovement(deltaTime)
    m_dashTimer = m_dashTimer - deltaTime
    
    local playerPosition = DCEI.GetUnitPosition2D(m_player)
    playerPosition.x = playerPosition.x + m_dashVelocity.x * deltaTime
    playerPosition.y = playerPosition.y + m_dashVelocity.y * deltaTime

    DCEI.SetUnitPosition2D(m_player, playerPosition.x, playerPosition.y)

    if m_dashTimer <= 0 then
        m_dashVelocity.x = 0
        m_dashVelocity.y = 0
    end
end
-- Utility Fuctions

-- Initialization
Start()