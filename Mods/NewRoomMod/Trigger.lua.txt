local ArcadeCore = GameModules["Arcade/Core"]

local mod = {}

local COMMON_ROOMS = {
    "CR_BL_0",
    "CR_BLR_0",
    "CR_BR_0",
    "CR_LR_0",
    "CR_TB_0",
    "CR_TBL_0",
    "CR_TBLR_0",
    "CR_TBR_0",
    "CR_TL_0",
    "CR_TLR_0",
    "CR_TR_0"
}

local MERCHANT_ROOMS = {
    "MR_B_0",
    "MR_L_0",
    "MR_R_0", 
    "MR_T_0"
}

local SECRET_ROOMS = {
    "SR_B_0",
    "SR_L_0",
    "SR_R_0",
    "SR_T_0"
}

local LEFT = "L"
local RIGHT = "R"
local TOP = "T"
local BOTTOM = "B"

local EXIT_ROOM_PATH_LENGTH = 4

local RoomGenerator  = {
    roomMatrix = {},
    roomMatrixCounter = {},
    roomAdjacencyList = {},

    spawnRoomRow = 100,
    spawnRoomColumn = 100,

    exitRoomRow = 100,
    exitRoomColumn = 100,

    minRow = 999,
    maxRow = -1,
    minColumn = 999,
    maxColumn = -1
}
RoomGenerator.__index = RoomGenerator
function RoomGenerator:new()
    local roomGenerator = {}
    setmetatable(roomGenerator, RoomGenerator)

    roomGenerator.roomMatrix = {}
    roomGenerator.roomMatrixCounter = {}
    roomGenerator.roomAdjacencyList = {}

    roomGenerator.spawnRoomRow = -1
    roomGenerator.spawnRoomColumn = -1

    roomGenerator.exitRoomRow = -1
    roomGenerator.exitRoomColumn = -1

    roomGenerator.minRow = 999
    roomGenerator.maxRow = -1
    roomGenerator.minColumn = 999
    roomGenerator.maxColumn = -1
    
    roomGenerator:GenerateRoomBase()
    roomGenerator:PrintRooms()
    roomGenerator:PrintRoomCounters()
    roomGenerator:PrintRoomAdjacenyList()

    return roomGenerator
end
function RoomGenerator:GenerateRoomBase()
    local spawnRoomRow = 100
    local spawnRoomColumn = 100

    self.spawnRoomRow = spawnRoomRow
    self.spawnRoomColumn = spawnRoomColumn

    local i = spawnRoomRow -- Row
    local j = spawnRoomColumn -- Column

    local randomCommonRoom = math.random(1, #COMMON_ROOMS)
    self.roomMatrix[i] = {}
    self.roomMatrix[i][j] = COMMON_ROOMS[randomCommonRoom]

    local maxIterationCount = 30

    if self.minRow > i then
        self.minRow = i
    end
    if self.maxRow < i then
        self.maxRow = i
    end
    if self.minColumn > j then
        self.minColumn = j
    end
    if self.maxColumn < j then
        self.maxColumn = j
    end

    while true do
        local randomSide = self:SelectRandomExit(self.roomMatrix[i][j])
        DCEI.LogMessage("Random Side: " .. randomSide)
        local exitOnSide

        if randomSide == LEFT then
            j = j - 1
            exitOnSide = RIGHT
        elseif randomSide == RIGHT then
            j = j + 1
            exitOnSide = LEFT
        elseif randomSide == TOP then
            i = i - 1
            exitOnSide = BOTTOM
        else
            i = i + 1
            exitOnSide = TOP
        end

        if self.minRow > i then
            self.minRow = i
        end
        if self.maxRow < i then
            self.maxRow = i
        end
        if self.minColumn > j then
            self.minColumn = j
        end
        if self.maxColumn < j then
            self.maxColumn = j
        end

        if self.roomMatrix[i] == nil then
            self.roomMatrix[i] = {}
        end

        if self.roomMatrix[i][j] == nil then
            local leftSide = j - 1
            local rightSide = j + 1
            local topSide = i - 1
            local bottomSide = i + 1
            local room

            if leftSide == spawnRoomColumn and i == spawnRoomRow then
                room = self:GetRoomWithLeftExit(COMMON_ROOMS)
            elseif rightSide == spawnRoomColumn and i == spawnRoomRow then
                room = self:GetRoomWithRightExit(COMMON_ROOMS)
            elseif j == spawnRoomColumn and topSide == spawnRoomRow then
                room = self:GetRoomWithTopExit(COMMON_ROOMS)
            elseif j == spawnRoomColumn and bottomSide == spawnRoomRow then
                room = self:GetRoomWithBottomExit(COMMON_ROOMS)
            else
                if exitOnSide == LEFT then
                    room = self:GetRoomWithLeftExit(COMMON_ROOMS)
                elseif exitOnSide == RIGHT then
                    room = self:GetRoomWithRightExit(COMMON_ROOMS)
                elseif exitOnSide == TOP then
                    room = self:GetRoomWithTopExit(COMMON_ROOMS)
                else
                    room = self:GetRoomWithBottomExit(COMMON_ROOMS)
                end
            end

            self.roomMatrix[i][j] = room
            DCEI.LogMessage("I: " .. i .. ", J: " .. j .. " " .. self.roomMatrix[i][j] .. "\n")

        else
            local leftSide = j - 1
            local rightSide = j + 1
            local topSide = i - 1
            local bottomSide = i + 1
            local room = self.roomMatrix[i][j]

            if leftSide == spawnRoomColumn and i == spawnRoomRow then
                if not mod.RoomHasLeftExit(self.roomMatrix[i][j]) then
                    room = self:GetRoomWithLeftExit(COMMON_ROOMS)
                end
            elseif rightSide == spawnRoomColumn and i == spawnRoomRow then
                if not mod.RoomHasRightExit(self.roomMatrix[i][j]) then
                    room = self:GetRoomWithRightExit(COMMON_ROOMS)
                end
            elseif j == spawnRoomColumn and topSide == spawnRoomRow then
                if not mod.RoomHasTopExit(self.roomMatrix[i][j]) then
                    room = self:GetRoomWithTopExit(COMMON_ROOMS)
                end
            elseif j == spawnRoomColumn and bottomSide == spawnRoomRow then
                if not mod.RoomHasBottomExit(self.roomMatrix[i][j]) then
                    room = self:GetRoomWithBottomExit(COMMON_ROOMS)
                end
            else
                -- Do nothing here just continue
            end

            self.roomMatrix[i][j] = room
            DCEI.LogMessage("I: " .. i .. ", J: " .. j .. " " ..  self.roomMatrix[i][j] .. "\n")
        end

        self:UpdateRoomMatrixCounter()
        self:UpdateRoomAdajcencyList()
        
        local breakLoop = self:CheckBFSForExitRoom()
        if breakLoop then
            break
        end
        
        maxIterationCount = maxIterationCount - 1
        if maxIterationCount <= 0 then
            break
        end
    end

    DCEI.LogMessage("\n")
    DCEI.LogMessage("Min Row: " .. self.minRow)
    DCEI.LogMessage("Max Row: " .. self.maxRow)
    DCEI.LogMessage("Min Column: " .. self.minColumn)
    DCEI.LogMessage("Max Column: " .. self.maxColumn)
    DCEI.LogMessage("\n")

    self:PlaceSecretRooms()
end
function RoomGenerator:PlaceSecretRooms()
    local minRow = self.minRow
    local maxRow = self.maxRow
    local minColumn = self.minColumn
    local maxColumn = self.maxColumn

    for i = self.minRow, self.maxRow do
        for j = self.minColumn, self.maxColumn do
        DCEI.LogMessage("I: " .. i .. ", J: " .. j)

            if self.roomMatrix[i][j] then
                DCEI.LogMessage("Room: " .. self.roomMatrix[i][j])
                
                local leftSide = j - 1
                local rightSide = j + 1
                local topSide = i - 1
                local bottomSide = i + 1

                if self.roomMatrix[i][leftSide] == nil and mod.RoomHasLeftExit(self.roomMatrix[i][j]) then
                    DCEI.LogMessage("Left Added")
                    local room = self:GetRoomWithRightExit(SECRET_ROOMS)
                    self.roomMatrix[i][leftSide] = room

                    if minColumn > leftSide then
                        minColumn = leftSide
                    end
                end

                if self.roomMatrix[i][rightSide] == nil and mod.RoomHasRightExit(self.roomMatrix[i][j]) then
                    DCEI.LogMessage("Right Added")
                    local room = self:GetRoomWithLeftExit(SECRET_ROOMS)
                    self.roomMatrix[i][rightSide] = room

                    if maxColumn < rightSide then
                        maxColumn = rightSide
                    end
                end

                if mod.RoomHasTopExit(self.roomMatrix[i][j]) then
                    if self.roomMatrix[topSide] == nil then
                        DCEI.LogMessage("Top Added 0")
                        local room = self:GetRoomWithBottomExit(SECRET_ROOMS)

                        self.roomMatrix[topSide] = {}
                        self.roomMatrix[topSide][j] = room

                    elseif self.roomMatrix[topSide][j] == nil then
                        DCEI.LogMessage("Top Added 1")
                        local room = self:GetRoomWithBottomExit(SECRET_ROOMS)
                        self.roomMatrix[topSide][j] = room
                    end

                    if minRow > topSide then
                        minRow = topSide
                    end
                end

                if mod.RoomHasBottomExit(self.roomMatrix[i][j]) then
                    if self.roomMatrix[bottomSide] == nil then
                        DCEI.LogMessage("Bottom Added 0")
                        local room = self:GetRoomWithTopExit(SECRET_ROOMS)

                        self.roomMatrix[bottomSide] = {}
                        self.roomMatrix[bottomSide][j] = room

                    elseif self.roomMatrix[bottomSide][j] == nil then
                        DCEI.LogMessage("Bottom Added 1")
                        local room = self:GetRoomWithTopExit(SECRET_ROOMS)
                        self.roomMatrix[bottomSide][j] = room
                    end

                    if maxRow < bottomSide then
                        maxRow = bottomSide
                    end
                end

            else
                -- Do nothing. Just ignore the index...
            end

            DCEI.LogMessage("\n")
        end
    end

    self.minRow = minRow
    self.maxRow = maxRow
    self.minColumn = minColumn
    self.maxColumn = maxColumn

    DCEI.LogMessage("Min Row: " .. minRow)
    DCEI.LogMessage("Max Row: " .. maxRow)
    DCEI.LogMessage("Min Column: " .. minColumn)
    DCEI.LogMessage("Max Column: " .. maxColumn)
end
function RoomGenerator:UpdateRoomMatrixCounter()
    local staicCounter = 0

    for i = self.minRow, self.maxRow do
        for j = self.minColumn, self.maxColumn do
            if self.roomMatrix[i][j] then
                if self.roomMatrixCounter[i] == nil then
                    self.roomMatrixCounter[i] = {}
                end

                self.roomMatrixCounter[i][j] = staicCounter
                staicCounter = staicCounter + 1
            end
        end
    end
end
function RoomGenerator:UpdateRoomAdajcencyList()
    self.roomAdjacencyList = {}

    for i = self.minRow, self.maxRow do
        for j = self.minColumn, self.maxColumn do
            if self.roomMatrix[i][j] ~= nil then
                local adjacentRooms = {}
                local roomNumber = self.roomMatrixCounter[i][j]

                local hasLeftExit = false
                local hasRightExit = false
                local hasTopExit = false
                local hasBottomExit = false

                if mod.RoomHasLeftExit(self.roomMatrix[i][j]) then
                    hasLeftExit = true
                end
                if mod.RoomHasRightExit(self.roomMatrix[i][j]) then
                    hasRightExit = true
                end
                if mod.RoomHasTopExit(self.roomMatrix[i][j]) then
                    hasTopExit = true
                end
                if mod.RoomHasBottomExit(self.roomMatrix[i][j]) then
                    hasBottomExit = true
                end

                local leftSide = j - 1
                local rightSide = j + 1
                local topSide = i - 1
                local bottomSide = i + 1

                if hasLeftExit then
                    if self.roomMatrix[i][leftSide] ~= nil and mod.RoomHasRightExit(self.roomMatrix[i][leftSide]) then
                        table.insert(adjacentRooms, self.roomMatrixCounter[i][leftSide])
                    end
                end

                if hasRightExit then
                    if self.roomMatrix[i][rightSide] ~= nil and mod.RoomHasLeftExit(self.roomMatrix[i][rightSide]) then
                        table.insert(adjacentRooms, self.roomMatrixCounter[i][rightSide])
                    end
                end

                if hasTopExit and self.roomMatrix[topSide] ~= nil then
                    if self.roomMatrix[topSide][j] ~= nil and mod.RoomHasBottomExit(self.roomMatrix[topSide][j]) then
                        table.insert(adjacentRooms, self.roomMatrixCounter[topSide][j])
                    end
                end

                if hasBottomExit and self.roomMatrix[bottomSide] ~= nil then
                    if self.roomMatrix[bottomSide][j] ~= nil and mod.RoomHasTopExit(self.roomMatrix[bottomSide][j]) then
                        table.insert(adjacentRooms, self.roomMatrixCounter[bottomSide][j])
                    end
                end

                self.roomAdjacencyList[roomNumber] = adjacentRooms
            end
        end
    end
end
function RoomGenerator:CheckBFSForExitRoom()
    for i = self.minRow, self.maxRow do
        for j = self.minColumn, self.maxColumn do
            if i == self.spawnRoomRow and j == self.spawnRoomColumn then
                -- Do nothing here...
            elseif self.roomMatrix[i][j] ~= nil then
                local roomNumber = self.roomMatrixCounter[i][j]
                local spawnRoomNumber = self.roomMatrixCounter[self.spawnRoomRow][self.spawnRoomColumn]
                local pathLength = self:FindPathToSpawnRoom(spawnRoomNumber, roomNumber)

                if pathLength == EXIT_ROOM_PATH_LENGTH then
                    self.exitRoomRow = i
                    self.exitRoomColumn = j

                    return true
                end
            end
        end
    end

    return false
end
function RoomGenerator:FindPathToSpawnRoom(spawnRoomNumber, startRoomNumber)
    local explored = {}
    local queue = { startRoomNumber }
    local pathLength = 0

    if spawnRoomNumber == startRoomNumber then
        return 0
    end

    while #queue ~= 0 do
        local node = table.remove(queue, 1)
        
        if not mod.ArrayHasValue(explored, node) then
            local adjacentRooms = self.roomAdjacencyList[node]
            for i, room in ipairs(adjacentRooms) do
                table.insert(queue, room)

                if room == spawnRoomNumber then
                    return pathLength
                end
            end

            pathLength = pathLength + 1
            table.insert(explored, node)
        end
    end

    DCEI.LogError("Can't reach Spawn Room!!!")
    return -1
end
function RoomGenerator:GetRoomWithLeftExit(rooms)
    local validRooms = {}

    for i, room in ipairs(rooms) do
        if mod.RoomHasLeftExit(room) then
            table.insert(validRooms, room)
        end
    end

    local randomIndex = math.random(1, #validRooms)
    return validRooms[randomIndex]
end
function RoomGenerator:GetRoomWithRightExit(rooms)
    local validRooms = {}

    for i, room in ipairs(rooms) do
        if mod.RoomHasRightExit(room) then
            table.insert(validRooms, room)
        end
    end

    local randomIndex = math.random(1, #validRooms)
    return validRooms[randomIndex]
end
function RoomGenerator:GetRoomWithTopExit(rooms)
    local validRooms = {}

    for i, room in ipairs(rooms) do
        if mod.RoomHasTopExit(room) then
            table.insert(validRooms, room)
        end
    end

    local randomIndex = math.random(1, #validRooms)
    return validRooms[randomIndex]
end
function RoomGenerator:GetRoomWithBottomExit(rooms)
    local validRooms = {}

    for i, room in ipairs(rooms) do
        if mod.RoomHasBottomExit(room) then
            table.insert(validRooms, room)
        end
    end

    local randomIndex = math.random(1, #validRooms)
    return validRooms[randomIndex]
end
function RoomGenerator:PrintRooms()
    DCEI.LogMessage("Printing Rooms")

    for i = self.minRow, self.maxRow do
        local stringValue = ""
        
        for j = self.minColumn, self.maxColumn do
            if self.roomMatrix[i][j] ~= nil then
                stringValue = stringValue .. self.roomMatrix[i][j] .. " "
            else
                stringValue = stringValue .. "*** "
            end
        end

        DCEI.LogMessage(stringValue)
    end
end
function RoomGenerator:PrintRoomCounters()
    DCEI.LogMessage("Printing Room Counters")

    for i = self.minRow, self.maxRow do
        local stringValue = ""

        for j = self.minColumn, self.maxColumn do
            if self.roomMatrixCounter[i] ~= nil then
                if self.roomMatrixCounter[i][j] ~= nil then
                    stringValue = stringValue .. self.roomMatrixCounter[i][j] .. " "
                else
                    stringValue = stringValue .. "*** "
                end
            end
        end

        DCEI.LogMessage(stringValue)
    end
end
function RoomGenerator:PrintRoomAdjacenyList()
    DCEI.LogMessage("Prining Room Adjaceny List")

    for key, value in pairs(self.roomAdjacencyList) do
        local stringValue = key .. ": "
        for i, room in ipairs(value) do
            stringValue = stringValue .. room .. " "
        end

        DCEI.LogMessage(stringValue)
    end
end
function RoomGenerator:SelectRandomExit(roomName)
    local randomArray = { 0, 0, 0, 0 }
    
    if mod.RoomHasLeftExit(roomName) then
        randomArray[1] = 1
    end
    if mod.RoomHasRightExit(roomName) then
        randomArray[2] = 1
    end
    if mod.RoomHasTopExit(roomName) then
        randomArray[3] = 1
    end
    if mod.RoomHasBottomExit(roomName) then
        randomArray[4] = 1
    end

    local validIndexes = {}
    for i = 1, #randomArray do
        if randomArray[i] == 1 then
            table.insert(validIndexes, i)
        end
    end

    if #validIndexes == 0 then
        DCEI.LogError("Room has no exit?... Exiting")
        return
    end

    local randomIndex = math.random(1, #validIndexes)
    local randomSide = validIndexes[randomIndex]

    if randomSide == 1 then
        return LEFT
    elseif randomSide == 2 then
        return RIGHT
    elseif randomSide == 3 then
        return TOP
    else
        return BOTTOM
    end
end

function mod.RoomHasLeftExit(value)
    return string.find(value, "_.*L.*_")
end
  
function mod.RoomHasRightExit(value)
    return string.find(value, "_.*R.*_")
end
  
function mod.RoomHasTopExit(value)
    return string.find(value, "_.*T.*_")
end

function mod.RoomHasBottomExit(value)
    return string.find(value, "_.*B.*_")
end

function mod.ArrayHasValue(array, value)
    for i, data in ipairs(array) do
        if data == value then
            return true
        end
    end

    return false
end

return mod