local ArcadeCore = GameModules["Arcade/Core"]

local mod = {}

local BASE_ROOM_PATH = "Mods/RoomTemplates"
local COMMON_ROOM_PATH = BASE_ROOM_PATH .. "/CommonRoom"
local MERCHANT_ROOM_PATH = BASE_ROOM_PATH .. "/MerchantRoom"
local SECRET_ROOM_PATH = BASE_ROOM_PATH .. "/SecretRoom"

local COMMON_ROOMS = {
    "CR_BL_0",
    "CR_BLR_0",
    "CR_BR_0",
    "CR_LR_0",
    "CR_TB_0",
    "CR_TBL_0",
    "CR_TBLR_0",
    "CR_TBR_0",
    "CR_TL_0",
    "CR_TLR_0",
    "CR_TR_0"
}

local MERCHANT_ROOMS = {
    "MR_B_0",
    "MR_L_0",
    "MR_R_0", 
    "MR_T_0"
}

local SECRET_ROOMS = {
    "SR_B_0",
    "SR_L_0",
    "SR_R_0",
    "SR_T_0"
}

local LEFT = "L"
local RIGHT = "R"
local TOP = "T"
local BOTTOM = "B"

local EXIT_ROOM_PATH_LENGTH = 3
local ARRAY_NIL = -9999 -- Because LUA has weird ideas of arrays

local RoomGenerator  = {
    roomMatrix = {},
    roomMatrixCounter = {},
    roomAdjacencyList = {},

    spawnRoomRow = 100,
    spawnRoomColumn = 100,

    exitRoomRow = 100,
    exitRoomColumn = 100,

    minRow = 999,
    maxRow = -1,
    minColumn = 999,
    maxColumn = -1,

    currentPlayerRow = -1,
    currentPlayerColumn = -1
}
RoomGenerator.__index = RoomGenerator
function RoomGenerator:new()
    local roomGenerator = {}
    setmetatable(roomGenerator, RoomGenerator)

    roomGenerator.roomMatrix = {}
    roomGenerator.roomMatrixCounter = {}
    roomGenerator.roomAdjacencyList = {}

    roomGenerator.spawnRoomRow = -1
    roomGenerator.spawnRoomColumn = -1

    roomGenerator.exitRoomRow = -1
    roomGenerator.exitRoomColumn = -1

    roomGenerator.minRow = 999
    roomGenerator.maxRow = -1
    roomGenerator.minColumn = 999
    roomGenerator.maxColumn = -1

    roomGenerator.currentPlayerRow = -1
    roomGenerator.currentPlayerColumn = -1
    
    roomGenerator:GenerateRoomBase()
    -- roomGenerator:PrintRooms()
    -- roomGenerator:PrintRoomCounters()
    -- roomGenerator:PrintRoomAdjacenyList()
    -- roomGenerator:PrintSpawnAndExit()
    roomGenerator:SaveRoomStructure()

    return roomGenerator
end
function RoomGenerator:SaveRoomStructure()
    DCEI.LogMessage("Saving Room Structure")

    DCEI.Save.Set("RoomMatrix", mod.Convert2DMatrixToString(self.roomMatrix, self.minRow, self.maxRow, self.minColumn, self.maxColumn))
    DCEI.Save.Set("RoomMatrixCounter", mod.Convert2DMatrixToString(self.roomMatrixCounter, self.minRow, self.maxRow, self.minColumn, self.maxColumn))
    DCEI.Save.Set("RoomAdjacencyList", mod.ConvertAdjacencyListToString(self.roomAdjacencyList))

    DCEI.Save.Set("SpawnRoomRow", self.spawnRoomRow)
    DCEI.Save.Set("SpawnRoomColumn", self.spawnRoomColumn)
    
    DCEI.Save.Set("ExitRoowRow", self.exitRoomRow)
    DCEI.Save.Set("ExitRoomColumn", self.exitRoomColumn)
    
    DCEI.Save.Set("MinRow", self.minRow)
    DCEI.Save.Set("MaxRow", self.maxRow)
    DCEI.Save.Set("MinColumn", self.minColumn)
    DCEI.Save.Set("MaxColumn", self.maxColumn)

    DCEI.Save.Set("PlayerRow", self.currentPlayerRow)
    DCEI.Save.Set("PlayerColumn", self.currentPlayerColumn)
    DCEI.Save.Commit()
end
function RoomGenerator:LoadRoomStructure()
    DCEI.LogMessage("Loading Room Structure")

    local roomGenerator = {}
    setmetatable(roomGenerator, RoomGenerator)
        
    roomGenerator.roomMatrix = mod.ConvertStringTo2DMatrix(DCEI.Save.Get("RoomMatrix"))
    roomGenerator.roomMatrixCounter = mod.ConvertStringTo2DMatrix(DCEI.Save.Get("RoomMatrixCounter"))
    roomGenerator.roomAdjacencyList = mod.ConvertStringToAdjacencyList(DCEI.Save.Get("RoomAdjacencyList"))

    roomGenerator.spawnRoomRow = DCEI.Save.Get("SpawnRoomRow")
    roomGenerator.spawnRoomColumn = DCEI.Save.Get("SpawnRoomColumn")

    roomGenerator.exitRoomRow = DCEI.Save.Get("ExitRoomRow")
    roomGenerator.exitRoomColumn = DCEI.Save.Get("ExitRoomColumn")

    roomGenerator.minRow = DCEI.Save.Get("MinRow")
    roomGenerator.maxRow = DCEI.Save.Get("MaxRow")
    roomGenerator.minColumn = DCEI.Save.Get("MinColumn")
    roomGenerator.maxColumn = DCEI.Save.Get("MaxColumn")

    roomGenerator.currentPlayerRow = DCEI.Save.Get("PlayerRow")
    roomGenerator.currentPlayerColumn = DCEI.Save.Get("PlayerColumn")

    return roomGenerator
end
function RoomGenerator:ClearSaveData()
   DCEI.LogMessage("Deleting Save Room Data") 

   DCEI.Save.Set("RoomMatrix", nil)
    DCEI.Save.Set("RoomMatrixCounter", nil)
    DCEI.Save.Set("RoomAdjacencyList", nil)

    DCEI.Save.Set("SpawnRoomRow", nil)
    DCEI.Save.Set("SpawnRoomColumn", nil)
    
    DCEI.Save.Set("ExitRoowRow", nil)
    DCEI.Save.Set("ExitRoomColumn", nil)
    
    DCEI.Save.Set("MinRow", nil)
    DCEI.Save.Set("MaxRow", nil)
    DCEI.Save.Set("MinColumn", nil)
    DCEI.Save.Set("MaxColumn", nil)

    DCEI.Save.Set("PlayerRow", nil)
    DCEI.Save.Set("PlayerColumn", nil)
    DCEI.Save.Commit()
end
function RoomGenerator:GetRoomFromPlayerPosition()
    return self.roomMatrix[self.currentPlayerRow][self.currentPlayerColumn]
end
function RoomGenerator:GenerateRoomBase()
    local spawnRoomRow = 100
    local spawnRoomColumn = 100

    self.spawnRoomRow = spawnRoomRow
    self.spawnRoomColumn = spawnRoomColumn

    self.currentPlayerRow = spawnRoomRow
    self.currentPlayerColumn = spawnRoomColumn

    local i = spawnRoomRow -- Row
    local j = spawnRoomColumn -- Column

    local randomCommonRoom = math.random(1, #COMMON_ROOMS)
    self.roomMatrix[i] = {}
    self.roomMatrix[i][j] = COMMON_ROOMS[randomCommonRoom]

    self:UpdateMinMaxRowColumn(i, j)
    
    while true do
        local randomSide = self:SelectRandomExit(self.roomMatrix[i][j])
        DCEI.LogMessage("Random Side: " .. randomSide)

        if randomSide == LEFT then
            j = j - 1
        elseif randomSide == RIGHT then
            j = j + 1
        elseif randomSide == TOP then
            i = i - 1
        else
            i = i + 1
        end

        self:UpdateMinMaxRowColumn(i, j)

        if self.roomMatrix[i] == nil then
            self.roomMatrix[i] = {}
        end

        local exitLeft, exitRight, exitTop, exitBottom = self:GetAdjacentRoomExits(i, j)

        local leftSide = j - 1
        local rightSide = j + 1
        local topSide = i - 1
        local bottomSide = i + 1
        local room

        if leftSide == spawnRoomColumn and i == spawnRoomRow then
            room = self:GetRoomWithExits(COMMON_ROOMS, true, exitRight, exitTop, exitBottom)
        elseif rightSide == spawnRoomColumn and i == spawnRoomRow then
            room = self:GetRoomWithExits(COMMON_ROOMS, exitLeft, true, exitTop, exitBottom)
        elseif j == spawnRoomColumn and topSide == spawnRoomRow then
            room = self:GetRoomWithExits(COMMON_ROOMS, exitLeft, exitRight, true, exitBottom)
        elseif j == spawnRoomColumn and bottomSide == spawnRoomRow then
            room = self:GetRoomWithExits(COMMON_ROOMS, exitLeft, exitRight, exitTop, true)
        else
            room = self:GetRoomWithExits(COMMON_ROOMS, exitLeft, exitRight, exitTop, exitBottom)
        end

        self.roomMatrix[i][j] = room

        self:UpdateRoomMatrixCounter()
        self:UpdateRoomAdajcencyList()
        
        local breakLoop = self:CheckBFSForExitRoom()
        if breakLoop then
            break
        end
    end

    self:PlaceSecretRooms()
    self:MergeCommonSecretRooms()
end
function RoomGenerator:PlaceSecretRooms()
    local minRow = self.minRow
    local maxRow = self.maxRow
    local minColumn = self.minColumn
    local maxColumn = self.maxColumn

    for i = self.minRow, self.maxRow do
        for j = self.minColumn, self.maxColumn do
        DCEI.LogMessage("I: " .. i .. ", J: " .. j)

            if self.roomMatrix[i][j] then
                DCEI.LogMessage("Room: " .. self.roomMatrix[i][j])
                
                local leftSide = j - 1
                local rightSide = j + 1
                local topSide = i - 1
                local bottomSide = i + 1

                if self.roomMatrix[i][leftSide] == nil and mod.RoomHasLeftExit(self.roomMatrix[i][j]) then
                    DCEI.LogMessage("Left Added")
                    local room = self:GetRoomWithExits(SECRET_ROOMS, false, true, false, false)
                    self.roomMatrix[i][leftSide] = room

                    if minColumn > leftSide then
                        minColumn = leftSide
                    end
                end

                if self.roomMatrix[i][rightSide] == nil and mod.RoomHasRightExit(self.roomMatrix[i][j]) then
                    DCEI.LogMessage("Right Added")
                    local room = self:GetRoomWithExits(SECRET_ROOMS, true, false, false, false)
                    self.roomMatrix[i][rightSide] = room

                    if maxColumn < rightSide then
                        maxColumn = rightSide
                    end
                end

                if mod.RoomHasTopExit(self.roomMatrix[i][j]) then
                    if self.roomMatrix[topSide] == nil then
                        DCEI.LogMessage("Top Added 0")
                        local room = self:GetRoomWithExits(SECRET_ROOMS, false, false, false, true)

                        self.roomMatrix[topSide] = {}
                        self.roomMatrix[topSide][j] = room

                    elseif self.roomMatrix[topSide][j] == nil then
                        DCEI.LogMessage("Top Added 1")
                        local room = self:GetRoomWithExits(SECRET_ROOMS, false, false, false, true)
                        self.roomMatrix[topSide][j] = room
                    end

                    if minRow > topSide then
                        minRow = topSide
                    end
                end

                if mod.RoomHasBottomExit(self.roomMatrix[i][j]) then
                    if self.roomMatrix[bottomSide] == nil then
                        DCEI.LogMessage("Bottom Added 0")
                        local room = self:GetRoomWithExits(SECRET_ROOMS, false, false, true, false)

                        self.roomMatrix[bottomSide] = {}
                        self.roomMatrix[bottomSide][j] = room

                    elseif self.roomMatrix[bottomSide][j] == nil then
                        DCEI.LogMessage("Bottom Added 1")
                        local room = self:GetRoomWithExits(SECRET_ROOMS, false, false, true, false)
                        self.roomMatrix[bottomSide][j] = room
                    end

                    if maxRow < bottomSide then
                        maxRow = bottomSide
                    end
                end

            else
                -- Do nothing. Just ignore the index...
            end

            DCEI.LogMessage("")
        end
    end

    self.minRow = minRow
    self.maxRow = maxRow
    self.minColumn = minColumn
    self.maxColumn = maxColumn

    DCEI.LogMessage("Min Row: " .. minRow)
    DCEI.LogMessage("Max Row: " .. maxRow)
    DCEI.LogMessage("Min Column: " .. minColumn)
    DCEI.LogMessage("Max Column: " .. maxColumn)
end
function RoomGenerator:MergeCommonSecretRooms()
    for i = self.minRow, self.maxRow do
        for j = self.minColumn, self.maxColumn do
            if self.roomMatrix[i][j] ~= nil and mod.IsSecretRoom(self.roomMatrix[i][j]) then
                local exitLeft, exitRight, exitTop, exitBottom = self:GetAdjacentRoomExits(i, j)
                local totalExits = 0
                
                if exitLeft then
                    totalExits = totalExits + 1
                end
                if exitRight then
                    totalExits = totalExits + 1
                end
                if exitTop then
                    totalExits = totalExits + 1
                end
                if exitBottom then
                    totalExits = totalExits + 1
                end

                if totalExits > 1 then
                    local room = self:GetRoomWithSpecificExits(COMMON_ROOMS, exitLeft, exitRight, exitTop, exitBottom)
                    self.roomMatrix[i][j] = room
                end
            end
        end
    end
end
function RoomGenerator:UpdateMinMaxRowColumn(i, j)
    if self.minRow > i then
        self.minRow = i
    end
    if self.maxRow < i then
        self.maxRow = i
    end
    if self.minColumn > j then
        self.minColumn = j
    end
    if self.maxColumn < j then
        self.maxColumn = j
    end
end
function RoomGenerator:UpdateRoomMatrixCounter()
    local staicCounter = 0

    for i = self.minRow, self.maxRow do
        for j = self.minColumn, self.maxColumn do
            if self.roomMatrix[i][j] then
                if self.roomMatrixCounter[i] == nil then
                    self.roomMatrixCounter[i] = {}
                end

                self.roomMatrixCounter[i][j] = staicCounter
                staicCounter = staicCounter + 1
            end
        end
    end
end
function RoomGenerator:UpdateRoomAdajcencyList()
    self.roomAdjacencyList = {}

    for i = self.minRow, self.maxRow do
        for j = self.minColumn, self.maxColumn do
            if self.roomMatrix[i][j] ~= nil then
                local adjacentRooms = {}
                local roomNumber = self.roomMatrixCounter[i][j]

                local hasLeftExit = false
                local hasRightExit = false
                local hasTopExit = false
                local hasBottomExit = false

                if mod.RoomHasLeftExit(self.roomMatrix[i][j]) then
                    hasLeftExit = true
                end
                if mod.RoomHasRightExit(self.roomMatrix[i][j]) then
                    hasRightExit = true
                end
                if mod.RoomHasTopExit(self.roomMatrix[i][j]) then
                    hasTopExit = true
                end
                if mod.RoomHasBottomExit(self.roomMatrix[i][j]) then
                    hasBottomExit = true
                end

                local leftSide = j - 1
                local rightSide = j + 1
                local topSide = i - 1
                local bottomSide = i + 1

                if hasLeftExit then
                    if self.roomMatrix[i][leftSide] ~= nil and mod.RoomHasRightExit(self.roomMatrix[i][leftSide]) then
                        table.insert(adjacentRooms, self.roomMatrixCounter[i][leftSide])
                    end
                end

                if hasRightExit then
                    if self.roomMatrix[i][rightSide] ~= nil and mod.RoomHasLeftExit(self.roomMatrix[i][rightSide]) then
                        table.insert(adjacentRooms, self.roomMatrixCounter[i][rightSide])
                    end
                end

                if hasTopExit and self.roomMatrix[topSide] ~= nil then
                    if self.roomMatrix[topSide][j] ~= nil and mod.RoomHasBottomExit(self.roomMatrix[topSide][j]) then
                        table.insert(adjacentRooms, self.roomMatrixCounter[topSide][j])
                    end
                end

                if hasBottomExit and self.roomMatrix[bottomSide] ~= nil then
                    if self.roomMatrix[bottomSide][j] ~= nil and mod.RoomHasTopExit(self.roomMatrix[bottomSide][j]) then
                        table.insert(adjacentRooms, self.roomMatrixCounter[bottomSide][j])
                    end
                end

                self.roomAdjacencyList[roomNumber] = adjacentRooms
            end
        end
    end
end
function RoomGenerator:CheckBFSForExitRoom()
    for i = self.minRow, self.maxRow do
        for j = self.minColumn, self.maxColumn do
            if i == self.spawnRoomRow and j == self.spawnRoomColumn then
                -- Do nothing here...
            elseif self.roomMatrix[i][j] ~= nil then
                local roomNumber = self.roomMatrixCounter[i][j]
                local spawnRoomNumber = self.roomMatrixCounter[self.spawnRoomRow][self.spawnRoomColumn]
                local pathLength = self:FindPathToSpawnRoom(spawnRoomNumber, roomNumber)

                if pathLength == EXIT_ROOM_PATH_LENGTH then
                    self.exitRoomRow = i
                    self.exitRoomColumn = j

                    return true
                end
            end
        end
    end

    return false
end
function RoomGenerator:FindPathToSpawnRoom(spawnRoomNumber, startRoomNumber)
    local explored = {}
    local queue = { startRoomNumber, ARRAY_NIL }
    local pathLength = 0

    if spawnRoomNumber == startRoomNumber then
        return 0
    end

    while #queue > 1 do
        local node = table.remove(queue, 1)
        
        if node == ARRAY_NIL then
            pathLength = pathLength + 1
            table.insert(queue, ARRAY_NIL)
        elseif not mod.ArrayHasValue(explored, node) then
            local adjacentRooms = self.roomAdjacencyList[node]
            for i, room in ipairs(adjacentRooms) do
                table.insert(queue, room)

                if room == spawnRoomNumber then
                    return pathLength
                end
            end

            table.insert(explored, node)
        end
    end

    DCEI.LogError("Can't reach Spawn Room!!!")
    return -1
end
function RoomGenerator:GetAdjacentRoomExits(row, column)
    local leftSide = column - 1
    local rightSide = column + 1
    local topSide = row - 1
    local bottomSide = row + 1

    local exitLeft = false
    local exitRight = false
    local exitTop = false
    local exitBottom = false

    if self.roomMatrix[row][leftSide] ~= nil then
        if mod.RoomHasRightExit(self.roomMatrix[row][leftSide]) then
            exitLeft = true
        end
    end

    if self.roomMatrix[row][rightSide] ~= nil then
        if mod.RoomHasLeftExit(self.roomMatrix[row][rightSide]) then
            exitRight = true
        end
    end

    if self.roomMatrix[topSide] ~= nil then
        if self.roomMatrix[topSide][column] ~= nil then
            if mod.RoomHasBottomExit(self.roomMatrix[topSide][column]) then
                exitTop = true
            end
        end 
    end

    if self.roomMatrix[bottomSide] ~= nil then
        if self.roomMatrix[bottomSide][column] ~= nil then
            if mod.RoomHasTopExit(self.roomMatrix[bottomSide][column]) then
                exitBottom = true
            end
        end 
    end

    return exitLeft, exitRight, exitTop, exitBottom
end
function RoomGenerator:GetAllRoomsWithExits(rooms, hasLeft, hasRight, hasTop, hasBottom)
    local validRooms = rooms

    if hasLeft then
        validRooms = self:GetRoomsWithLeftExit(validRooms)
    end

    if hasRight then
        validRooms = self:GetRoomsWithRightExit(validRooms)
    end

    if hasTop then
        validRooms = self:GetRoomsWithTopExit(validRooms)
    end

    if hasBottom then
        validRooms = self:GetRoomsWithBottomExit(validRooms)
    end

    return validRooms
end
function RoomGenerator:GetRoomWithExits(rooms, hasLeft, hasRight, hasTop, hasBottom)
    local validRooms = self:GetAllRoomsWithExits(rooms, hasLeft, hasRight, hasTop, hasBottom)
    local randomIndex = math.random(1, #validRooms)
    return validRooms[randomIndex]
end
function RoomGenerator:GetRoomWithSpecificExits(rooms, hasLeft, hasRight, hasTop, hasBottom)
    local validRooms = self:GetAllRoomsWithExits(rooms, hasLeft, hasRight, hasTop, hasBottom)
    local actualValidRooms = {}

    for i = 1, #validRooms do
        local roomMarkedForRemoval = false

        if not hasLeft and mod.RoomHasLeftExit(validRooms[i]) then
            roomMarkedForRemoval = true    
        end

        if not hasRight and mod.RoomHasRightExit(validRooms[i]) then
            roomMarkedForRemoval = true
        end

        if not hasTop and mod.RoomHasTopExit(validRooms[i]) then
            roomMarkedForRemoval = true
        end

        if not hasBottom and mod.RoomHasBottomExit(validRooms[i]) then
            roomMarkedForRemoval = true
        end

        if not roomMarkedForRemoval then
            table.insert(actualValidRooms, validRooms[i])
        end
    end

    local randomIndex = math.random(1, #actualValidRooms)
    return actualValidRooms[randomIndex]
end
function RoomGenerator:GetRoomsWithLeftExit(rooms)
    local validRooms = {}

    for i, room in ipairs(rooms) do
        if mod.RoomHasLeftExit(room) then
            table.insert(validRooms, room)
        end
    end

    return validRooms
end
function RoomGenerator:GetRoomsWithRightExit(rooms)
    local validRooms = {}

    for i, room in ipairs(rooms) do
        if mod.RoomHasRightExit(room) then
            table.insert(validRooms, room)
        end
    end

    return validRooms
end
function RoomGenerator:GetRoomsWithTopExit(rooms)
    local validRooms = {}

    for i, room in ipairs(rooms) do
        if mod.RoomHasTopExit(room) then
            table.insert(validRooms, room)
        end
    end

    return validRooms
end
function RoomGenerator:GetRoomsWithBottomExit(rooms)
    local validRooms = {}

    for i, room in ipairs(rooms) do
        if mod.RoomHasBottomExit(room) then
            table.insert(validRooms, room)
        end
    end

    return validRooms
end
function RoomGenerator:PrintSpawnAndExit()
    local spawnRow = self.spawnRoomRow
    local spawnColumn = self.spawnRoomColumn
    local exitRow = self.exitRoomRow
    local exitColumn = self.exitRoomColumn

    if exitRow ~= -1 and exitColumn ~= -1 then
        DCEI.LogMessage("Exit Room: " .. self.roomMatrix[exitRow][exitColumn] .. ", I: " .. exitRow .. ", J: " .. exitColumn)
    end
    DCEI.LogMessage("Spawn Room: " .. self.roomMatrix[spawnRow][spawnColumn] .. ", I: " .. spawnRow .. ", J: " .. spawnColumn)
end
function RoomGenerator:PrintRooms()
    DCEI.LogMessage("Printing Rooms")

    for i = self.minRow, self.maxRow do
        local stringValue = ""
        
        for j = self.minColumn, self.maxColumn do
            if self.roomMatrix[i][j] ~= nil then
                stringValue = stringValue .. self.roomMatrix[i][j] .. " "
            else
                stringValue = stringValue .. "*** "
            end
        end

        DCEI.LogMessage(stringValue)
    end
end
function RoomGenerator:PrintRoomCounters()
    DCEI.LogMessage("Printing Room Counters")

    for i = self.minRow, self.maxRow do
        local stringValue = ""

        for j = self.minColumn, self.maxColumn do
            if self.roomMatrixCounter[i] ~= nil then
                if self.roomMatrixCounter[i][j] ~= nil then
                    stringValue = stringValue .. self.roomMatrixCounter[i][j] .. " "
                else
                    stringValue = stringValue .. "*** "
                end
            end
        end

        DCEI.LogMessage(stringValue)
    end
end
function RoomGenerator:PrintRoomAdjacenyList()
    DCEI.LogMessage("Prining Room Adjaceny List")

    for key, value in pairs(self.roomAdjacencyList) do
        local stringValue = key .. ": "
        for i, room in ipairs(value) do
            stringValue = stringValue .. room .. " "
        end

        DCEI.LogMessage(stringValue)
    end
end
function RoomGenerator:SelectRandomExit(roomName)
    local randomArray = { 0, 0, 0, 0 }
    
    if mod.RoomHasLeftExit(roomName) then
        randomArray[1] = 1
    end
    if mod.RoomHasRightExit(roomName) then
        randomArray[2] = 1
    end
    if mod.RoomHasTopExit(roomName) then
        randomArray[3] = 1
    end
    if mod.RoomHasBottomExit(roomName) then
        randomArray[4] = 1
    end

    local validIndexes = {}
    for i = 1, #randomArray do
        if randomArray[i] == 1 then
            table.insert(validIndexes, i)
        end
    end

    if #validIndexes == 0 then
        DCEI.LogError("Room has no exit?... Exiting")
        return
    end

    local randomIndex = math.random(1, #validIndexes)
    local randomSide = validIndexes[randomIndex]

    if randomSide == 1 then
        return LEFT
    elseif randomSide == 2 then
        return RIGHT
    elseif randomSide == 3 then
        return TOP
    else
        return BOTTOM
    end
end

function mod.RoomHasLeftExit(value)
    return string.find(value, "_.*L.*_")
end
  
function mod.RoomHasRightExit(value)
    return string.find(value, "_.*R.*_")
end
  
function mod.RoomHasTopExit(value)
    return string.find(value, "_.*T.*_")
end

function mod.RoomHasBottomExit(value)
    return string.find(value, "_.*B.*_")
end

function mod.Convert2DMatrixToString(matrix, minRow, maxRow, minColumn, maxColumn)
    local stringValue = ""

    for i = minRow, maxRow do    
        for j = minColumn, maxColumn do
            if matrix[i] ~= nil then
                if matrix[i][j] ~= nil then
                    stringValue = stringValue .. matrix[i][j] .. "," .. i .. "," .. j .. ":"
                end
            end
        end
        stringValue = stringValue .. "|"
    end

    return stringValue
end

function mod.ConvertStringTo2DMatrix(stringValue)
    local matrix = {}
    local rows = mod.split(stringValue, "|")

    for _, value in pairs(rows) do
        local columns = mod.split(value, ":")

        for _, colValue in pairs(columns) do
            local data = mod.split(colValue, ",")
            local i = tonumber(data[2])
            local j = tonumber(data[3])

            if matrix[i] == nil then
                matrix[i] = {}
            end

            matrix[i][j] = data[1]
        end
    end

    return matrix
end

function mod.ConvertAdjacencyListToString(adjacencyList)
    local stringValue = ""

    for key, value in pairs(adjacencyList) do
        stringValue = stringValue .. key .. ":"
        for i, room in ipairs(value) do
            stringValue = stringValue .. room .. ","
        end

        stringValue = stringValue .. "|"
    end

    return stringValue
end

function mod.ConvertStringToAdjacencyList(stringValue)
    local listArray = mod.split(stringValue, "|")
    local adjacencyList = {}

    for _, value in pairs(listArray) do
        local data = mod.split(value, ":")

        local key = tonumber(data[1])
        local roomStrings = mod.split(data[2], ",")
        
        local adjacentRooms = {}

        for _, room in pairs(roomStrings) do
            local roomNumber = tonumber(room)
            table.insert(adjacentRooms, roomNumber)
        end

        adjacencyList[key] = adjacentRooms
    end

    return adjacencyList
end

function mod.GetRoomPath(roomName)
    if mod.IsCommonRoom(roomName) then
        return COMMON_ROOM_PATH .. "/" .. roomName
    elseif mod.IsMerchantRoom(roomName) then
        return MERCHANT_ROOM_PATH .. "/" .. roomName
    elseif mod.IsSecretRoom(roomName) then
        return SECRET_ROOM_PATH .. "/" .. roomName
    else
        DCEI.LogError("Invalid Room Name!!!")
    end
end

function mod.IsCommonRoom(value)
    return string.find(value, "CR")
end

function mod.IsMerchantRoom(value)
    return string.find(value, "MR")
end

function mod.IsSecretRoom(value)
    return string.find(value, "SR")
end

function mod.ArrayHasValue(array, value)
    for i, data in ipairs(array) do
        if data == value then
            return true
        end
    end

    return false
end

mod.RoomGenerator = RoomGenerator

mod.EnemyHobGoblin = nil
mod.EnemyGoblinChef = nil
mod.EnemyGoblin = nil
mod.EnemyGoblinSapper = nil
mod.EnemyOoze = nil

mod.split = nil

return mod