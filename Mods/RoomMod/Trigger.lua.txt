-- NOTE: ROWS AND COLUMNS ARE FLIPPED
-- KEEP A NOTE OF THIS
-- i IS y AND j IS x

local ArcadeCore = GameModules["Arcade/Core"]

-- #region Room Templates

local CROSS_ROAD_ROOMS = {
    {
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 9, 0, 0, 9, 0, 0, 0 },
        { 0, 0, 0, 0, 9, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 9, 0, 0, 0, 0 },
        { 0, 0, 0, 9, 0, 0, 9, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
    },

    {
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 9, 0, 0, 0, 0, 9, 0, 1 },
        { 0, 0, 0, 2, 2, 2, 2, 0, 0, 0 },
        { 1, 0, 0, 2, 2, 2, 2, 0, 0, 0 },
        { 0, 0, 0, 2, 2, 2, 2, 0, 0, 0 },
        { 0, 0, 0, 2, 2, 2, 2, 0, 0, 0 },
        { 1, 0, 9, 0, 0, 0, 0, 9, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
    }
}

local SECRET_ROOMS_LEFT_EXIT = {
    {
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 9, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 9, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 9, 0, 0, 1 },
        { 0, 0, 0, 0, 9, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    }
}

local SECRET_ROOMS_RIGHT_EXIT = {
    {
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 9, 0, 0, 0, 0 },
        { 1, 0, 0, 9, 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 9, 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 9, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    }
}

local SECRET_ROOMS_TOP_EXIT = {
    {
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 9, 0, 0, 9, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 9, 9, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    }
}

local SECRET_ROOMS_BOTTOM_EXIT = {
    {
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 9, 9, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 9, 0, 0, 9, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
    }
}

local PATHWAY_ROOMS = {
    {
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 9, 0, 0, 0, 0, 0, 0, 9, 1 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 1, 9, 9, 0, 0, 0, 0, 9, 9, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    },
    
    {
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 9, 0, 0, 0, 1 },
        { 0, 0, 1, 0, 0, 0, 0, 1, 0, 0 },
        { 0, 0, 0, 9, 2, 2, 9, 0, 0, 0 },
        { 0, 0, 0, 9, 2, 2, 9, 0, 0, 0 },
        { 0, 0, 1, 0, 0, 0, 0, 1, 0, 0 },
        { 1, 0, 0, 0, 9, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    }
}

local CONNECTOR_UP_ROOMS = {
    {
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 9, 0, 0, 9, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 9, 0, 0, 9, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    }
}

local CONNECTOR_DOWN_ROOMS = {
    {
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 9, 0, 0, 9, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 9, 0, 0, 9, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
    }
}

local EXIT_ROOMS = {
    {
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 3, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
    }
}

local BEGINNING_ROOMS = {
    {
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 4, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
    }
}

-- #endregion Room Templates

-- #region Enemy Sets
-- 0: Goblin Chef, 1: Hob Goblin, 2: Goblin, 3: Goblin Sapper, 4: Slime

local ENEMY_PREFABS = { 0, 1, 2, 3, 4 }

local LEVEL_1_ENEMY_SETS = {
    { 2, 2 },
    { 2, 0 },
    { 3, 3, 4 },
    { 0, 0, 0 },
    { 2, 4 },
}

local LEVEL_2_ENEMY_SETS = {
    { 4, 4, 3, 3 },
    { 1, 1, 0 },
    { 2, 2, 1, 0 },
    { 3, 3, 4, 4 },
    { 2, 2, 3, 3 },
}

local LEVEL_3_ENEMY_SETS = {
    { 0, 0, 0, 3, 3 },
    { 1, 1, 0, 0 },
    { 2, 2, 1, 0, 0 },
    { 3, 3, 1, 1, 4 },
    { 2, 2, 1, 4, 4 },
}

-- #endregion Enemy Sets

local BASE_ROOM_SIZE = 10

local SOLID_WALL_PREFAB = "_Wall_SolidWall"
local BREAKABLE_WALL_PREFAB = "_Wall_BreakableWall"
local DOORWAY = "_Wall_Doorway"
local EXIT_DOORWAY = "_ExitDoorway"
local ENTRY_DOORWAY = "_EntryDoorway"

local DOORWAY_OPEN = "_DoorwayOpen"
local DOORWAY_CLOSE = "_DoorwayClose"

local PR = "PR"
local SR = "SR"
local CUP = "CUP"
local CDR = "CDR"
local CSR = "CSR"
local ER =  "ER"
local BR = "BR"
local MAX_ROWS = 3
local MAX_COLUMNS = 3

local MAX_WAVE_COUNT = 5
local ROOM_ENTRY_DETECT_OFFSET = 3

local mod = {}

-- Room Template Definition
-- 0: Empty Space
-- 1: Solid Wall
-- 2: Destructible Wall
-- 3: Exit Doorway
-- 4: Entry Doorway
-- 9: Enemy Spawn Positions
local Room = {
    rect = nil,
    roomType = "",

    -- Positions
    emptyPositions = {},
    enemySpawnPositions = {},
    destructiblePositions = {},
    solidWallPositions = {},
    doorwayPositions = {},
    exitPosition = nil,
    entryPosition = nil,

    -- Walls
    solidWallUnits = {},
    doorwayUnits = {},
    destructibleWallUnits = {},
    exitUnit = nil,
    entryUnit = nil,

    -- Template Info
    roomTemplate = {},
    hasLeftExit = false,
    hasRightExit = false,
    hasTopExit = false,
    hasBottomExit = false,

    -- Spawn Info
    playerInRoom = false,
    roomCleared = false,

    -- Room Enemies
    enemies = {},
    totalWaveCount = 0,
    currentWaveCount = 0,
    roomLevel = 0 
}
Room.__index = Room
function Room:new(roomTemplate, rect, roomType, roomLevel)
    local room = {}
    setmetatable(room, Room)

    room.rect = rect
    room.roomType = roomType

    room.emptyPositions = {}
    room.enemySpawnPositions = {}
    room.destructiblePositions = {}
    room.solidWallPositions = {}
    room.doorwayPositions = {}
    room.exitPosition = nil
    room.entryPosition = nil

    room.solidWallUnits = {}
    room.doorwayUnits = {}
    room.destructibleWallUnits = {}
    room.exitUnit = nil
    room.entryUnit = nil

    room.roomTemplate = mod.CopyRoomTemplate(roomTemplate) -- Copy templates as tables are sent via reference
    room.hasLeftExit = false
    room.hasRightExit = false
    room.hasTopExit = false
    room.hasBottomExit = false

    room.playerInRoom = false
    
    if roomType == ER or roomType == BR then
        room.roomCleared = true
    else
        room.roomCleared = false
    end

    room.enemies = {}
    room.totalWaveCount = 1 -- Kept in case waves are required to be added later on...
    room.currentWaveCount = 0
    room.roomLevel = roomLevel

    room:RecalculateRoomSpaces()

    return room
end
function Room:UpdateEnemies(deltaTime, player)
    local playerPosition = DCEI.GetUnitPosition2D(player)
    for i, enemy in ipairs(self.enemies) do

        -- This is a fallback check in case a dead enemy still remains in queue
        local mainUnit = enemy:GetMainUnit()
        if not ArcadeCore.UnitIsAlive(mainUnit) then
            self:ForceRemoveUnitAtIndex(i)
            break
        end

        enemy:Update(deltaTime, playerPosition)
    end
end
function Room:UpdateEnemyStunState(enemyUnit)
    for i, enemy in ipairs(self.enemies) do
        local success = enemy:CheckAndActivateStunnedState(enemyUnit)
        if success then
            break
        end
    end
end
function Room:IsPlayerInRoom(player)
    local playerPosition = DCEI.GetUnitPosition2D(player)
    if self.rect:containsWithOffset(playerPosition.x, playerPosition.y, ROOM_ENTRY_DETECT_OFFSET) then
        return true
    end

    return false
end
function Room:UpdatePlayerInRoom(player)
    if player == nil then
        return
    end

    if self.playerInRoom then
        return
    end

    local playerPosition = DCEI.GetUnitPosition2D(player)
    if self.rect:containsWithOffset(playerPosition.x, playerPosition.y, ROOM_ENTRY_DETECT_OFFSET) then
        self:InitializePlayerEntered()
    end
end
function Room:InitializePlayerEntered()
    if self.roomCleared then
        return -- Don't do anything as the player has already cleared the room
    end

    DCEI.LogMessage("Player In Room")

    self.playerInRoom = true
    self:CreateDoors()
    self:SpawnNextWave()
end
function Room:RemoveDeadEnemy(enemyUnit)
    if not self.playerInRoom then
        return
    end

    local index = -1
    for i, enemy in ipairs(self.enemies) do
        if enemy:GetMainUnit() == enemyUnit then
            index = i
            break
        end
    end

    if index ~= -1 then
        local enemyClassInstance = self.enemies[index]
        enemyClassInstance:CleanupEnemyDied()
        table.remove(self.enemies, index)
    end

    local totalEnemyCount = #self.enemies
    if totalEnemyCount == 0 then
        self:SpawnNextWave()
    end
end
function Room:ForceRemoveUnitAtIndex(index)
    if index == -1 then
        return
    end

    table.remove(self.enemies, index)
    local totalEnemyCount = #self.enemies
    if totalEnemyCount == 0 then
        self:SpawnNextWave()
    end
end
function Room:SpawnNextWave()
    if self.currentWaveCount >= self.totalWaveCount then
        self:MarkRoomCleared()
        return
    end

    local startX = self.rect.x
    local startY = self.rect.y
    local randomEnemySpawns = mod.ShuffleTable(self.enemySpawnPositions)

    local enemySet
    if self.roomLevel == 0 then
        enemySet = LEVEL_1_ENEMY_SETS
    elseif self.roomLevel == 1 then
        enemySet = LEVEL_2_ENEMY_SETS
    else 
        enemySet = LEVEL_3_ENEMY_SETS
    end

    DCEI.LogMessage("Room Level: " .. self.roomLevel)

    local randomEnemySet = math.random(1, #enemySet)

    for i, enemyType in ipairs(enemySet[randomEnemySet]) do
        if i > #randomEnemySpawns then
            break
        end

        local xPosition = startX + randomEnemySpawns[i][1]
        local yPosition = startY + randomEnemySpawns[i][2]

        if enemyType == 0 then
            enemy = mod.EnemyGoblinChef:new(self, xPosition, yPosition)
        elseif enemyType == 1 then
            enemy = mod.EnemyHobGoblin:new(self, xPosition, yPosition)
        elseif enemyType == 2 then
            enemy = mod.EnemyGoblin:new(self, xPosition, yPosition)
        end

        table.insert(self.enemies, enemy)
    end

    self.currentWaveCount = self.currentWaveCount + 1
end
function Room:MarkRoomCleared()
    self.roomCleared = true
    self:RemoveDoors()
end
function Room:CreateDoors()
    local startX = self.rect.x
    local startY = self.rect.y

    for i, doorwayPosition in ipairs(self.doorwayPositions) do
        local xPosition = startX + doorwayPosition[1]
        local yPosition = startY + doorwayPosition[2]

        local doorway = DCEI.CreateUnit(0, 0, DOORWAY, xPosition, yPosition)
        table.insert(self.doorwayUnits, doorway)
    end
end
function Room:RemoveDoors()
    for i, doorway in ipairs(self.doorwayUnits) do
        DCEI.RemoveUnit(doorway)
    end

    self.doorwayUnits = {}
end
function Room:GetNearestEnemy(player)
    if not self.playerInRoom then
        return nil
    end

    local playerPosition = DCEI.GetUnitPosition2D(player)
    local lastNearestEnemy = nil
    local lastEnemyDistance = 100

    for i, enemyUnit in ipairs(self.enemies) do
        local enemyPosition = DCEI.GetUnitPosition2D(enemyUnit:GetMainUnit())
        local distance = mod.VectorDistance(playerPosition, enemyPosition)
        
        if distance < lastEnemyDistance then
            lastNearestEnemy = enemyUnit:GetMainUnit()
            lastEnemyDistance = distance
        end
    end

    return lastNearestEnemy
end
function Room:ClearEnemies()
    for i, enemy in ipairs(self.enemies) do
        local mainUnit = enemy:GetMainUnit()
        DCEI.RemoveUnit(mainUnit)
        enemy:CleanupEnemyDied()
    end

    self.enemies = {}
end
function Room:DestroyRoom()
    self:ClearEnemies()
    self:RemoveDoors()

    for i, solidWallUnit in ipairs(self.solidWallUnits) do
        DCEI.RemoveUnit(solidWallUnit)
    end

    for i, destructibleUnit in ipairs(self.destructibleWallUnits) do
        DCEI.RemoveUnit(destructibleUnit)
    end

    if self.exitUnit ~= nil then
        DCEI.RemoveUnit(self.exitUnit)
    end

    if self.entryUnit ~= nil then
        DCEI.RemoveUnit(self.entryUnit)
    end

    self.solidWallUnits = {}
    self.destructibleWallUnits = {}
    self.exitUnit = nil
    self.entryUnit = nil
end
function Room:BlockTopWalls()
    local totalColumns = #self.roomTemplate[1]
    for i = 1, totalColumns do
        self.roomTemplate[1][i] = 1
    end

    self:RecalculateRoomSpaces()
end
function Room:BlockBottomWalls()
    local totalColumns = #self.roomTemplate[1]
    local lastRow = #self.roomTemplate

    for i = 1, totalColumns do
        self.roomTemplate[lastRow][i] = 1
    end

    self:RecalculateRoomSpaces()
end
function Room:BlockLeftWalls()
    for i = 1, #self.roomTemplate do
        self.roomTemplate[i][1] = 1
    end

    self:RecalculateRoomSpaces()
end
function Room:BlockRightWalls()
    local lastColumn = #self.roomTemplate[1]

    for i = 1, #self.roomTemplate do
        self.roomTemplate[i][lastColumn] = 1
    end

    self:RecalculateRoomSpaces()
end
function Room:RecalculateRoomSpaces()
    self.emptyPositions = {}
    self.destructiblePositions = {}
    self.solidWallPositions = {}
    self.exitPosition = nil
    self.entryPosition = nil

    for i = 1, #self.roomTemplate do
        for j = 1, #self.roomTemplate[i] do
            local xPosition = j
            local yPosition = BASE_ROOM_SIZE - i

            if self.roomTemplate[i][j] == 0 then
                if i == 1 or i == #self.roomTemplate or j == 1 or j == #self.roomTemplate[i] then
                    table.insert(self.doorwayPositions, { xPosition, yPosition })
                else
                    table.insert(self.emptyPositions,  { xPosition, yPosition })
                end

            elseif self.roomTemplate[i][j] == 1 then
                table.insert(self.solidWallPositions, { xPosition, yPosition })
            elseif self.roomTemplate[i][j] == 2 then
                table.insert(self.destructiblePositions, { xPosition, yPosition })
            elseif self.roomTemplate[i][j] == 3 then
                self.exitPosition = { xPosition, yPosition }
            elseif self.roomTemplate[i][j] == 4 then
                self.entryPosition = { xPosition, yPosition }
            elseif self.roomTemplate[i][j] == 9 then
                table.insert(self.enemySpawnPositions, { xPosition, yPosition })
            end
        end
    end

    self.hasLeftExit = mod.RoomHasLeftExit(self.roomTemplate)
    self.hasRightExit = mod.RoomHasRightExit(self.roomTemplate)
    self.hasTopExit = mod.RoomHasTopExit(self.roomTemplate)
    self.hasBottomExit = mod.RoomHasBottomExit(self.roomTemplate)
end
function Room:GetEmptyPositions()
    return self.emptyPositions, self.rect
end
function Room:GenerateRoomModels()
    local startX = self.rect.x
    local startY = self.rect.y

    -- Solid Walls
    for i = 1, #self.solidWallPositions do
        local xPosition = startX + self.solidWallPositions[i][1]
        local yPosition = startY + self.solidWallPositions[i][2]

        local solidWallInstance = DCEI.CreateUnit(0, 0, SOLID_WALL_PREFAB, xPosition, yPosition)
        table.insert(self.solidWallUnits, solidWallInstance)
    end

    -- Destructible Walls
    for i = 1, #self.destructiblePositions do
        local xPosition = startX + self.destructiblePositions[i][1]
        local yPosition = startY + self.destructiblePositions[i][2]

        local destructibleWallInstance = DCEI.CreateUnit(0, 0, BREAKABLE_WALL_PREFAB, xPosition, yPosition)
        table.insert(self.destructibleWallUnits, destructibleWallInstance)
    end

    if self.exitPosition ~= nil then
        local exitPositionX = startX + self.exitPosition[1]
        local exitPositionY = startY + self.exitPosition[2]
        self.exitUnit = DCEI.CreateUnit(0, 0, EXIT_DOORWAY, exitPositionX, exitPositionY)
    end

    if self.entryPosition ~= nil then
        local entryPositionX = startX + self.entryPosition[1]
        local entryPositionY = startY + self.entryPosition[2]
        self.entryUnit = DCEI.CreateUnit(0, 0, ENTRY_DOORWAY, entryPositionX, entryPositionY)
    end
end
function Room:GetRoomTemplate()
    return self.roomTemplate
end
function Room:GetEntryPosition()
    return self.entryPosition
end
function Room:GetEntryDoor()
    return self.entryUnit
end
function Room:PlayEntryDoorCloseAnimation()
    if self.entryUnit ~= nil then
        DCEI.CastAbilityAtPosition(DOORWAY_CLOSE, self.entryUnit, self.entryPosition[1], self.entryPosition[2])
    end
end
function Room:PlayExitDoorOpenAnimation()
    if self.exitUnit ~= nil then
        DCEI.CastAbilityAtPosition(DOORWAY_OPEN, self.exitUnit, self.exitPosition[1], self.exitPosition[2])
    end
end
function Room:GetExitDoor()
    return self.exitUnit
end
function Room:GetRoomType()
    return self.roomType
end

-- Room Identifiers:
-- SR: Secret Room
-- PR: Pathway Room
-- CUP: Connector Up Room
-- CDR: Connector Down Room
-- CSR: Cross Section Room
-- ER: Exit Room
local RoomGenerator = { rooms = {}, roomMatrix = {}, roomLevel = 0 }
RoomGenerator.__index = RoomGenerator
function RoomGenerator:new(roomLevel)
    local roomGenerator = {}
    setmetatable(roomGenerator, RoomGenerator)

    roomGenerator.rooms = {
        { nil, nil, nil },
        { nil, nil, nil },
        { nil, nil, nil }
    }
    roomGenerator.roomMatrix = {
        { "*", "*", "*" },
        { "*", "*", "*" },
        { "*", "*", "*" }
    }
    roomGenerator.roomLevel = roomLevel

    roomGenerator:GenerateRooms(roomLevel)

    return roomGenerator
end
function RoomGenerator:GenerateRooms(roomLevel)
    self.roomLevel = roomLevel

    self:GenerateBaseRoomMatrix()
    self:GenerateActualBasicRooms()
    self:GenerateSecretRooms()
    self:CreateRoomWalls()
    self:GenerateRoomsModels()
    self:PrintRoomMatrix()
    self:PrintActualRoomMatrix()
end
function RoomGenerator:DestroyRooms()
    for i = 1, #self.rooms do
        for j = 1, #self.rooms[i] do
            self.rooms[i][j]:DestroyRoom()
        end
    end

    self.rooms = {
        { nil, nil, nil },
        { nil, nil, nil },
        { nil, nil, nil }
    }
    self.roomMatrix = {
        { "*", "*", "*" },
        { "*", "*", "*" },
        { "*", "*", "*" }
    }
end
function RoomGenerator:UpdateRooms(deltaTime, player)
    for i = 1, #self.rooms do
        for j = 1, #self.rooms[i] do
            if self.rooms[i][j] ~= nil then
                self.rooms[i][j]:UpdatePlayerInRoom(player)
                self.rooms[i][j]:UpdateEnemies(deltaTime, player)
            end
        end
    end
end
function RoomGenerator:GetRoomNearestEnemy(player)
    for i = 1, #self.rooms do
        for j = 1, #self.rooms[i] do
            local enemy = self.rooms[i][j]:GetNearestEnemy(player)
            if enemy ~= nil then
                return enemy
            end
        end
    end

    return nil
end
function RoomGenerator:UpdateEnemyStunState(enemyUnit)
    -- Just iterate through all rooms when the behaviour is activated
    for i = 1, #self.rooms do
        for j = 1, #self.rooms[i] do
            self.rooms[i][j]:UpdateEnemyStunState(enemyUnit)
        end
    end
end
function RoomGenerator:RemoveDeadEnemy(enemyUnit)
    for i = 1, #self.rooms do
        for j = 1, #self.rooms[i] do
            self.rooms[i][j]:RemoveDeadEnemy(enemyUnit)
        end
    end
end
function RoomGenerator:GetBeginningRoomIndex()
    for i = 1, MAX_ROWS do
        for j = 1, MAX_COLUMNS do
            if self.rooms[i][j]:GetRoomType() == BR then
                return i, j
            end
        end
    end

    DCEI.LogError("No Beginning Room")
    return nil, nil
end
function RoomGenerator:GetExitRoomIndex()
    for i = 1, MAX_ROWS do
        for j = 1, MAX_COLUMNS do
            if self.rooms[i][j]:GetRoomType() == ER then
                return i, j
            end
        end
    end

    DCEI.LogError("No Beginning Room")
    return nil, nil
end
function RoomGenerator:GetBeginningRoomEntryPosition()
    local rowIndex, columnIndex = self:GetBeginningRoomIndex()
    return self.rooms[rowIndex][columnIndex]:GetEntryPosition()
end
function RoomGenerator:GetRoomRect(rowIndex, columnIndex)
    return self.rooms[rowIndex][columnIndex].rect
end
function RoomGenerator:MakeSafeRoom(rowIndex, columnIndex)
    self.rooms[rowIndex][columnIndex].roomCleared = true
end
function RoomGenerator:GetRoomEmptyPositions(rowIndex, columnIndex)
    return self.rooms[rowIndex][columnIndex]:GetEmptyPositions()
end
function RoomGenerator:GenerateBaseRoomMatrix()
    local currentRowIndex = 1
    local currentColumnIndex = math.random(1, MAX_COLUMNS) -- Probably read from Matrix Length?
    local generationComplete = false

    self.roomMatrix[currentRowIndex][currentColumnIndex] = BR
    self:PrintRoomMatrix()

    while true do
        local randomNumber = math.random()
        if randomNumber <= 0.4 then -- Left
            local nextColumnIndex = currentColumnIndex - 1

            if nextColumnIndex < 1 then
                currentRowIndex, currentColumnIndex, generationComplete = self:PlaceRoomBelow(currentRowIndex, currentColumnIndex)
            else
                currentColumnIndex = nextColumnIndex
                self:PlaceRoomLeftOrRight(currentRowIndex, currentColumnIndex, true)
            end

        elseif randomNumber <= 0.8 then -- Right
            local nextColumnIndex = currentColumnIndex + 1

            if nextColumnIndex > MAX_COLUMNS then
                currentRowIndex, currentColumnIndex, generationComplete = self:PlaceRoomBelow(currentRowIndex, currentColumnIndex)
            else
                currentColumnIndex = nextColumnIndex
                self:PlaceRoomLeftOrRight(currentRowIndex, currentColumnIndex, false)
            end
        else -- Down
            currentRowIndex, currentColumnIndex, generationComplete = self:PlaceRoomBelow(currentRowIndex, currentColumnIndex)
        end

        if generationComplete then
            break
        else
            self:PrintRoomMatrix()
        end
    end

    for i = 1, MAX_ROWS do
        for j = 1, MAX_COLUMNS do
            if self.roomMatrix[i][j] == "*" then
                self.roomMatrix[i][j] = SR
            end
        end
    end

    self:PrintRoomMatrix()
    self:ConnectSecretRooms()
end
function RoomGenerator:GenerateActualBasicRooms()
    for i = 1, #self.roomMatrix do
        for j = 1, #self.roomMatrix[i] do
            local mappedI = #self.roomMatrix - i + 1 -- Flip when searching for room
            local roomType = self.roomMatrix[mappedI][j] 
            -- Keep the Room Matrix same as the Normal Matrix
            local rect = mod.Rect:new((j - 1) * BASE_ROOM_SIZE, (i - 1) * BASE_ROOM_SIZE, BASE_ROOM_SIZE, BASE_ROOM_SIZE)
            
            if roomType == PR then
                local randomIndex = math.random(1, #PATHWAY_ROOMS)
                local room = Room:new(PATHWAY_ROOMS[randomIndex], rect, PR, self.roomLevel)
                self.rooms[mappedI][j] = room
            elseif roomType == CUP then
                local randomIndex = math.random(1, #CONNECTOR_UP_ROOMS)
                local room = Room:new(CONNECTOR_UP_ROOMS[randomIndex], rect, CUP, self.roomLevel)
                self.rooms[mappedI][j] = room
            elseif roomType == CDR then
                local randomIndex = math.random(1, #CONNECTOR_DOWN_ROOMS)
                local room = Room:new(CONNECTOR_DOWN_ROOMS[randomIndex], rect, CDR, self.roomLevel)
                self.rooms[mappedI][j] = room
            elseif roomType == CSR then
                local randomIndex = math.random(1, #CROSS_ROAD_ROOMS)
                local room = Room:new(CROSS_ROAD_ROOMS[randomIndex], rect, CSR, self.roomLevel)
                self.rooms[mappedI][j] = room
            elseif roomType == ER then
                local randomIndex = math.random(1, #EXIT_ROOMS)
                local room = Room:new(EXIT_ROOMS[randomIndex], rect, ER, self.roomLevel)
                self.rooms[mappedI][j] = room
            elseif roomType == BR then
                local randomIndex = math.random(1, #BEGINNING_ROOMS)
                local room = Room:new(BEGINNING_ROOMS[randomIndex], rect, BR, self.roomLevel)
                self.rooms[mappedI][j] = room
            elseif roomType == SR then
                DCEI.LogMessage("Generating Secret Rooms Later")
            else
                DCEI.LogError("Invalid Room Type")
            end
        end
    end
end
function RoomGenerator:GenerateSecretRooms()
    for x = 1, #self.roomMatrix do
        for j = 1, #self.roomMatrix[x] do
            -- Only handle secret rooms here
            -- This can be made clear by dynamically finding the side
            -- But if manual values can tell the info why not use it?

            local i = #self.roomMatrix - x + 1
            if self.roomMatrix[i][j] == SR then

                if i == 1 then -- Top Side
                    if j == 1 then -- Top Left Side
                        local hasLeftExit = self.rooms[i][j + 1] and self.rooms[i][j + 1].hasLeftExit or false
                        local hasTopExit = self.rooms[i + 1][j] and self.rooms[i + 1][j].hasTopExit or false
                        self:GenerateRandomSecretRoom(hasLeftExit, false, hasTopExit, false, x, i, j)

                    elseif j == #self.roomMatrix[i] then -- Top Right Side
                        local hasRightExit = self.rooms[i][j - 1] and self.rooms[i][j - 1].hasRightExit or false
                        local hasTopExit = self.rooms[i + 1][j] and self.rooms[i + 1][j].hasTopExit or false
                        self:GenerateRandomSecretRoom(false, hasRightExit, hasTopExit, false, x, i, j)
                        
                    else -- Side in the middle
                        local hasLeftExit = self.rooms[i][j - 1] and self.rooms[i][j - 1].hasLeftExit or false
                        local hasRightExit = self.rooms[i][j + 1] and self.rooms[i][j + 1].hasRightExit or false
                        local hasTopExit = self.rooms[i + 1][j] and self.rooms[i + 1][j].hasTopExit or false
                        self:GenerateRandomSecretRoom(hasLeftExit, hasRightExit, hasTopExit, false, x, i, j)
                    end
                elseif i == #self.roomMatrix then -- Bottom Side
                    if j == 1 then -- Bottom Left Side
                        local hasLeftExit = self.rooms[i][j + 1] and self.rooms[i][j + 1].hasLeftExit or false
                        local hasBottomExit = self.rooms[i - 1][j] and self.rooms[i - 1][j].hasBottomExit or false
                        self:GenerateRandomSecretRoom(hasLeftExit, false, false, hasBottomExit, x, i, j)

                    elseif j == #self.roomMatrix[i] then -- Bottom Right Side
                        local hasRightExit = self.rooms[i][j - 1] and self.rooms[i][j - 1].hasRightExit or false
                        local hasBottomExit = self.rooms[i - 1][j] and self.rooms[i - 1][j].hasBottomExit or false
                        self:GenerateRandomSecretRoom(false, hasRightExit, false, hasBottomExit, x, i, j)

                    else -- Side in the middle
                        local hasLeftExit = self.rooms[i][j - 1] and self.rooms[i][j - 1].hasLeftExit or false
                        local hasRightExit = self.rooms[i][j + 1] and self.rooms[i][j + 1].hasRightExit or false
                        local hasBottomExit = self.rooms[i - 1][j] and self.rooms[i - 1][j].hasBottomExit or false
                        self:GenerateRandomSecretRoom(hasLeftExit, hasRightExit, false, hasBottomExit, x, i, j)
                    end
                else -- Side in the middle
                    if j == 1 then -- Middle Left Side
                        local hasTopExit = self.rooms[i + 1][j] and self.rooms[i + 1][j].hasTopExit or false
                        local hasBottomExit = self.rooms[i - 1][j] and self.rooms[i - 1][j].hasBottomExit or false
                        local hasLeftExit = self.rooms[i][j + 1] and self.rooms[i][j + 1].hasLeftExit or false
                        self:GenerateRandomSecretRoom(hasLeftExit, false, hasTopExit, hasBottomExit, x, i, j)

                    elseif j == #self.roomMatrix[i] then -- Middle Right Side
                        local hasTopExit = self.rooms[i + 1][j] and self.rooms[i + 1][j].hasTopExit or false
                        local hasBottomExit = self.rooms[i - 1][j] and self.rooms[i - 1][j].hasBottomExit or false
                        local hasRightExit = self.rooms[i][j - 1] and self.rooms[i][j - 1].hasRightExit or false
                        self:GenerateRandomSecretRoom(false, hasRightExit, hasTopExit, hasBottomExit, x, i, j)

                    else -- Side in the middle
                        local hasTopExit = self.rooms[i + 1][j] and self.rooms[i + 1][j].hasTopExit or false
                        local hasBottomExit = self.rooms[i - 1][j] and self.rooms[i - 1][j].hasBottomExit or false
                        local hasLeftExit = self.rooms[i][j + 1] and self.rooms[i][j + 1].hasLeftExit or false
                        local hasRightExit = self.rooms[i][j - 1] and self.rooms[i][j - 1].hasRightExit or false
                        self:GenerateRandomSecretRoom(hasLeftExit, hasRightExit, hasTopExit, hasBottomExit, x, i, j)
                    end
                end
            end
        end
    end
end
function RoomGenerator:CreateRoomWalls()
    local stringValue = ""
    
    -- Top Row
    stringValue = ""
    for i = 1, #self.roomMatrix[1] do
        if self.rooms[1][i] then
            self.rooms[1][i]:BlockTopWalls()
            stringValue = stringValue .. self.rooms[1][i]:GetRoomType() .. " "
        end
    end
    DCEI.LogMessage("Top Row Rooms: " .. stringValue)

    -- Bottom Row
    local lastRow = #self.roomMatrix
    stringValue = ""
    for i = 1, #self.roomMatrix[lastRow] do
        if self.rooms[lastRow][i] then
            self.rooms[lastRow][i]:BlockBottomWalls()
            stringValue = stringValue .. self.rooms[lastRow][i]:GetRoomType() .. " "
        end
    end
    DCEI.LogMessage("Bottom Row Rooms: " .. stringValue)

    -- Left Column
    stringValue = ""
    for i = 1, #self.roomMatrix do
        if self.rooms[i][1] then
            self.rooms[i][1]:BlockLeftWalls()
            stringValue = stringValue .. self.rooms[i][1]:GetRoomType() .. " "
        end
    end
    DCEI.LogMessage("Left Column Rooms: " .. stringValue)

    -- Right Column
    stringValue = ""
    local lastColumn = #self.roomMatrix[1]
    for i = 1, #self.roomMatrix do
        if self.rooms[i][lastColumn] then
            self.rooms[i][lastColumn]:BlockRightWalls()
            stringValue = stringValue .. self.rooms[i][lastColumn]:GetRoomType() .. " "
        end
    end
    DCEI.LogMessage("Right Column Rooms: " .. stringValue)
end
function RoomGenerator:GenerateRoomsModels()
    for i = 1, #self.rooms do
        for j = 1, #self.roomMatrix[i] do
            if self.rooms[i][j] then
                self.rooms[i][j]:GenerateRoomModels()
            end
        end
    end
end
function RoomGenerator:GenerateRandomSecretRoom(hasLeftExit, hasRightExit, hasTopExit, hasBottomExit, actualRowIndex, rowIndex, columnIndex)
    DCEI.LogMessage("Generating Secret Rooms")

    local randomArray = { 0, 0, 0, 0 }
    if hasLeftExit then
        randomArray[1] = 1
    end
    if hasRightExit then
        randomArray[2] = 1
    end
    if hasTopExit then
        randomArray[3] = 1
    end
    if hasBottomExit then
        randomArray[4] = 1
    end

    -- Find valid sides where the secret rooms can be placed
    local validIndexes = {}
    for i = 1, #randomArray do
        if randomArray[i] == 1 then
            table.insert(validIndexes, i)
        end
    end

    if #validIndexes == 0 then
        DCEI.LogMessage("Row: " .. rowIndex .. ", Column: " .. columnIndex)
        self:PrintRoomMatrix()
        DCEI.LogError("Inaccessible Secret Room")
        return
    end
    
    local rect = mod.Rect:new((columnIndex - 1) * BASE_ROOM_SIZE, (actualRowIndex - 1) * BASE_ROOM_SIZE, BASE_ROOM_SIZE, BASE_ROOM_SIZE)
    local randomIndex = math.random(1, #validIndexes)
    local randomValue = validIndexes[randomIndex]

    if randomValue == 1 then
        local randomRoomIndex = math.random(1, #SECRET_ROOMS_RIGHT_EXIT)
        local room = Room:new(SECRET_ROOMS_RIGHT_EXIT[randomRoomIndex], rect, SR, self.roomLevel)
        self.rooms[rowIndex][columnIndex] = room
    elseif randomValue == 2 then
        local randomRoomIndex = math.random(1, #SECRET_ROOMS_LEFT_EXIT)
        local room = Room:new(SECRET_ROOMS_LEFT_EXIT[randomRoomIndex], rect, SR, self.roomLevel)
        self.rooms[rowIndex][columnIndex] = room
    elseif randomValue == 3 then
        local randomRoomIndex = math.random(1, #SECRET_ROOMS_BOTTOM_EXIT)
        local room = Room:new(SECRET_ROOMS_BOTTOM_EXIT[randomRoomIndex], rect, SR, self.roomLevel)
        self.rooms[rowIndex][columnIndex] = room
    else
        local randomRoomIndex = math.random(1, #SECRET_ROOMS_TOP_EXIT)
        local room = Room:new(SECRET_ROOMS_TOP_EXIT[randomRoomIndex], rect, SR, self.roomLevel)
        self.rooms[rowIndex][columnIndex] = room
    end
end
function RoomGenerator:ConnectSecretRooms()
    for i = 1, MAX_ROWS do
        for j = 1, MAX_COLUMNS do
            if self.roomMatrix[i][j] == SR then
                local hasExit = false

                if i == 1 then -- Top Row
                    local hasTopExit = mod.StringRoomHasTopExit(self.roomMatrix[i + 1][j])

                    if j == 1 then -- Left Column
                        local hasLeftExit = mod.StringRoomHasLeftExit(self.roomMatrix[i][j + 1])

                        if hasLeftExit or hasTopExit then
                            -- Do nothing here..
                            hasExit = true
                        elseif not hasLeftExit then
                            self.roomMatrix[i][j + 1] = PR
                            hasExit = true
                        end
                    elseif j == MAX_COLUMNS then -- Right Column
                        local hasRightExit = mod.StringRoomHasRightExit(self.roomMatrix[i][j - 1])

                        if hasRightExit or hasTopExit then
                            -- Do nothing here...
                            hasExit = true
                        elseif not hasRightExit then
                            self.roomMatrix[i][j - 1] = PR
                            hasExit = true
                        end
                    else -- Middle Column
                        local hasLeftExit = mod.StringRoomHasLeftExit(self.roomMatrix[i][j + 1])
                        local hasRightExit = mod.StringRoomHasRightExit(self.roomMatrix[i][j - 1])

                        if hasLeftExit or hasRightExit or hasTopExit then
                            -- Do nothing here...
                            hasExit = true
                        elseif not hasLeftExit then
                            self.roomMatrix[i][j + 1] = PR
                            hasExit = true
                        elseif not hasRightExit then
                            self.roomMatrix[i][j - 1] = PR
                            hasExit = true
                        end
                    end

                    if not hasExit then
                        local belowRoom = self.roomMatrix[i + 1][j]
                        if belowRoom == CSR or belowRoom == ER then
                            -- Do Nothing Here...
                        elseif belowRoom == CUP or belowRoom == CDR then
                            self.roomMatrix[i + 1][j] = CSR
                        else
                            self.roomMatrix[i + 1][j] = CUP
                        end
                    end

                elseif i == MAX_ROWS then -- Bottom Row
                    local hasBottomExit = mod.StringRoomHasBottomExit(self.roomMatrix[i - 1][j])

                    if j == 1 then -- Left Column
                        local hasLeftExit = mod.StringRoomHasLeftExit(self.roomMatrix[i][j + 1])

                        if hasLeftExit or hasBottomExit then
                            -- Do nothing here..
                            hasExit = true
                        elseif not hasLeftExit then
                            self.roomMatrix[i][j + 1] = PR
                            hasExit = true
                        end
                    elseif j == MAX_COLUMNS then -- Right Column
                        local hasRightExit = mod.StringRoomHasRightExit(self.roomMatrix[i][j - 1])

                        if hasRightExit or hasBottomExit then
                            -- Do nothing here...
                            hasExit = true
                        elseif not hasRightExit then
                            self.roomMatrix[i][j - 1] = PR
                            hasExit = true
                        end
                    else -- Middle Column
                        local hasLeftExit = mod.StringRoomHasLeftExit(self.roomMatrix[i][j + 1])
                        local hasRightExit = mod.StringRoomHasRightExit(self.roomMatrix[i][j - 1])

                        if hasLeftExit or hasRightExit or hasBottomExit then
                            -- DO nothing here...
                            hasExit = true
                        elseif not hasLeftExit then
                            self.roomMatrix[i][j + 1] = PR
                            hasExit = true
                        elseif not hasRightExit then
                            self.roomMatrix[i][j - 1] = PR
                            hasExit = true
                        end
                    end

                    if not hasExit then
                        local aboveRoom = self.roomMatrix[i - 1][j]
                        if aboveRoom == CSR or aboveRoom == ER then
                            -- Do Nothing Here...
                        elseif aboveRoom == CDR or aboveRoom == CUP then
                            self.roomMatrix[i - 1][j] = CSR
                        else
                            self.roomMatrix[i - 1][j] = CDR
                        end
                    end

                else -- Middle Row
                    local hasTopExit = mod.StringRoomHasTopExit(self.roomMatrix[i + 1][j])
                    local hasBottomExit = mod.StringRoomHasBottomExit(self.roomMatrix[i - 1][j])

                    if j == 1 then -- Left Column
                        local hasLeftExit = mod.StringRoomHasLeftExit(self.roomMatrix[i][j + 1])

                        if hasLeftExit or hasTopExit or hasBottomExit then
                            -- Do nothing here..
                            hasExit = true
                        elseif not hasLeftExit then
                            self.roomMatrix[i][j + 1] = PR
                            hasExit = true
                        end
                    elseif j == MAX_COLUMNS then -- Right Column
                        local hasRightExit = mod.StringRoomHasRightExit(self.roomMatrix[i][j - 1])

                        if hasRightExit or hasTopExit or hasBottomExit then
                            -- Do nothing here...
                            hasExit = true
                        elseif not hasRightExit then
                            self.roomMatrix[i][j - 1] = PR
                            hasExit = true
                        end
                    else -- Middle Column
                        local hasLeftExit = mod.StringRoomHasLeftExit(self.roomMatrix[i][j + 1])
                        local hasRightExit = mod.StringRoomHasRightExit(self.roomMatrix[i][j - 1])

                        if hasLeftExit or hasRightExit or hasTopExit or hasBottomExit then
                            -- DO nothing here...
                            hasExit = true
                        elseif not hasLeftExit then
                            self.roomMatrix[i][j + 1] = PR
                            hasExit = true
                        elseif not hasRightExit then
                            self.roomMatrix[i][j - 1] = PR
                            DCEI.LogMessage("Placing Pathway Room. I: " .. i .. ", J: " .. j)
                            hasExit = true
                        end
                    end

                    local aboveRoom = self.roomMatrix[i - 1][j]
                    local belowRoom = self.roomMatrix[i + 1][j]

                    if not hasExit then
                        local aboveRoom = self.roomMatrix[i - 1][j]
                        if aboveRoom == CSR or aboveRoom == ER then
                            -- Do Nothing Here...
                        elseif aboveRoom == CDR or aboveRoom == CUP then
                            self.roomMatrix[i - 1][j] = CSR
                        else
                            self.roomMatrix[i - 1][j] = CDR
                        end

                        hasExit = true
                    end

                    if not hasExit then
                        local belowRoom = self.roomMatrix[i + 1][j]
                        if belowRoom == CSR or belowRoom == ER then
                            -- Do Nothing Here...
                        elseif belowRoom == CUP or belowRoom == CDR then
                            self.roomMatrix[i + 1][j] = CSR
                        else
                            self.roomMatrix[i + 1][j] = CUP
                        end

                        hasExit = true
                    end
                end

                self:PrintRoomMatrix()
            end
        end
    end
end
function RoomGenerator:PlaceRoomBelow(currentRowIndex, currentColumnIndex)
    DCEI.LogMessage("Placing Room Below")
    local nextRowIndex = currentRowIndex + 1

    if nextRowIndex > MAX_ROWS then -- This means it went out of bounds
        self.roomMatrix[currentRowIndex][currentColumnIndex] = ER
        return currentRowIndex, currentColumnIndex, true
    end

    if self.roomMatrix[currentRowIndex][currentColumnIndex] == CUP then
        self.roomMatrix[currentRowIndex][currentColumnIndex] = CSR
    elseif self.roomMatrix[currentRowIndex][currentColumnIndex] == BR then
        -- Do nothing here...
    else
        self.roomMatrix[currentRowIndex][currentColumnIndex] = CDR
    end

    currentRowIndex = nextRowIndex
    self.roomMatrix[currentRowIndex][currentColumnIndex] = CUP

    return currentRowIndex, currentColumnIndex, false
end
function RoomGenerator:PlaceRoomLeftOrRight(currentRowIndex, currentColumnIndex, isLeft)
    DCEI.LogMessage("Placing Room Left or Right. IsLeft: " .. tostring(isLeft))

    local roomType = self.roomMatrix[currentRowIndex][currentColumnIndex]
    if mod.StringRoomHasLeftExit(roomType) and mod.StringRoomHasRightExit(roomType) then
        return
    end
    
    local randomNumber = math.random()
    if randomNumber <= 0.5 then
        self.roomMatrix[currentRowIndex][currentColumnIndex] = CUP
    else
        self.roomMatrix[currentRowIndex][currentColumnIndex] = PR
    end
end
function RoomGenerator:PrintRoomMatrix()
    DCEI.LogMessage("Normal Room Matrix")
    for i = 1, MAX_ROWS do
        local stringValue = ""
        for j = 1, MAX_COLUMNS do
            stringValue = stringValue .. self.roomMatrix[i][j] .. " "
        end
        DCEI.LogMessage(stringValue)
    end
end
function RoomGenerator:PrintActualRoomMatrix()
    DCEI.LogMessage("Actual Room Matrix")
    for i = 1, MAX_ROWS do
        local stringValue = ""
        for j = 1, MAX_COLUMNS do
            local roomType = self.rooms[i][j] and self.rooms[i][j]:GetRoomType() or "SR"
            stringValue = stringValue .. roomType .. " "
        end
        DCEI.LogMessage(stringValue)
    end
end

function mod.StringRoomHasLeftExit(roomName)
    if roomName == PR or roomName == CDR or roomName == CUP or roomName == CSR or roomName == ER or roomName == BR then
        return true
    end

    return false
end
function mod.StringRoomHasRightExit(roomName)
    if roomName == PR or roomName == CDR or roomName == CUP or roomName == CSR or roomName == ER or roomName == BR then
        return true
    end

    return false
end
function mod.StringRoomHasTopExit(roomName)
    if roomName == CUP or roomName == CSR or roomName == ER then
        return true
    end

    return false
end
function mod.StringRoomHasBottomExit(roomName)
    if roomName == CDR or roomName == CSR or roomName == ER or roomName == BR then
        return true
    end

    return false
end


function mod.RoomHasLeftExit(roomTemplate)
    for i = 1, #roomTemplate do
        if roomTemplate[i][1] == 0 then
            return true
        end
    end

    return false
end
function mod.RoomHasRightExit(roomTemplate)
    local lastColumn = #roomTemplate[1]
    for i = 1, #roomTemplate do
        if roomTemplate[i][lastColumn] == 0 then
            return true
        end
    end

    return false
end
function mod.RoomHasTopExit(roomTemplate)
    local totalColumns = #roomTemplate[1]

    for i = 1, totalColumns do
        if roomTemplate[1][i] == 0 then
            return true
        end
    end
    
    return false
end
function mod.RoomHasBottomExit(roomTemplate)
    local totalColumns = #roomTemplate[1]
    local lastRow = #roomTemplate

    for i = 1, totalColumns do
        if roomTemplate[lastRow][i] == 0 then
            return true
        end
    end

    return false
end

function mod.CopyRoomTemplate(roomTemplate)
    local newTemplate = {}
    
    for i = 1, #roomTemplate do
        table.insert(newTemplate, {})
        for j = 1, #roomTemplate[i] do
            table.insert(newTemplate[i], roomTemplate[i][j])
        end
    end

    return newTemplate
end


mod.RoomGenerator = RoomGenerator
mod.Room = Room

mod.VectorDistance = nil
mod.ShuffleTable = nil
mod.Rect = nil

mod.EnemyHobGoblin = nil
mod.EnemyGoblinChef = nil
mod.EnemyGoblin = nil

return mod