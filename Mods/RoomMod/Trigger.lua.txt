-- NOTE: ROWS AND COLUMNS ARE FLIPPED
-- KEEP A NOTE OF THIS
-- i IS y AND j IS x    

-- #region Room Templates

local CROSS_ROAD_ROOMS = {
    {
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
    },

    {
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 2, 2, 2, 2, 0, 0, 0 },
        { 1, 0, 0, 2, 2, 2, 2, 0, 0, 0 },
        { 0, 0, 0, 2, 2, 2, 2, 0, 0, 0 },
        { 0, 0, 0, 2, 2, 2, 2, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
    }
}

local SECRET_ROOMS_LEFT_EXIT = {
    {
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    }
}

local SECRET_ROOMS_RIGHT_EXIT = {
    {
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    }
}

local SECRET_ROOMS_TOP_EXIT = {
    {
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    }
}

local SECRET_ROOMS_BOTTOM_EXIT = {
    {
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
    }
}

local PATHWAY_ROOMS = {
    {
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    },
    
    {
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 1, 0, 0, 1, 0, 0, 0 },
        { 0, 0, 0, 0, 2, 2, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 2, 2, 0, 0, 0, 0 },
        { 0, 0, 0, 1, 0, 0, 1, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    }
}

local CONNECTOR_UP_ROOMS = {
    {
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    }
}

local CONNECTOR_DOWN_ROOMS = {
    {
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
    }
}

local EXIT_ROOMS = {
    {
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 3, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
        { 1, 1, 1, 0, 0, 0, 0, 1, 1, 1 },
    }
}

-- #endregion

-- 0: Goblin Chef, 1: Hob Goblin
-- TODO: Think of a better way to do this...
local ENEMY_PREFABS = { 0, 1 }
local BASE_ROOM_SIZE = 10

local SOLID_WALL_PREFAB = "_Wall_SolidWall"
local BREAKABLE_WALL_PREFAB = "_Wall_BreakableWall"
local DOORWAY = "_Wall_Doorway"

local PR = "PR"
local SR = "SR"
local CUP = "CUP"
local CDR = "CDR"
local CSR = "CSR"
local ER =  "ER"
local MAX_ROWS = 3
local MAX_COLUMNS = 3

local mod = {}

-- Room Template Definition
-- 0: Empty Space
-- 1: Solid Wall
-- 2: Destructible Wall
-- 3: Exit
local Room = {
    rect = nil,
    roomType = "",

    -- Positions
    emptyPositions = {},
    destructiblePositions = {},
    solidWallPositions = {},
    exitPosition = nil,

    -- Walls
    solidWallUnits = {},
    doorwayUnits = {},
    destructibleWallUnits = {},
    exitUnit = nil,

    -- Template Info
    roomTemplate = {},
    hasLeftExit = false,
    hasRightExit = false,
    hasTopExit = false,
    hasBottomExit = false
}
Room.__index = Room
function Room:new(roomTemplate, rect, roomType)
    local room = {}
    setmetatable(room, Room)

    room.rect = rect
    room.roomType = roomType

    room.emptyPositions = {}
    room.destructiblePositions = {}
    room.solidWallPositions = {}
    room.exitPosition = nil

    room.solidWallUnits = {}
    room.doorwayUnits = {}
    room.destructibleWallUnits = {}
    room.exitUnit = nil

    room.roomTemplate = mod.CopyRoomTemplate(roomTemplate) -- Copy templates as tables are sent via reference
    room.hasLeftExit = false
    room.hasRightExit = false
    room.hasTopExit = false
    room.hasBottomExit = false

    room:RecalculateRoomSpaces()

    return room
end
function Room:BlockTopWalls()
    local totalColumns = #self.roomTemplate[1]
    for i = 1, totalColumns do
        self.roomTemplate[1][i] = 1
    end

    self:RecalculateRoomSpaces()
end
function Room:BlockBottomWalls()
    local totalColumns = #self.roomTemplate[1]
    local lastRow = #self.roomTemplate

    for i = 1, totalColumns do
        self.roomTemplate[lastRow][i] = 1
    end

    self:RecalculateRoomSpaces()
end
function Room:BlockLeftWalls()
    for i = 1, #self.roomTemplate do
        self.roomTemplate[i][1] = 1
    end

    self:RecalculateRoomSpaces()
end
function Room:BlockRightWalls()
    local lastColumn = #self.roomTemplate[1]

    for i = 1, #self.roomTemplate do
        self.roomTemplate[i][lastColumn] = 1
    end

    self:RecalculateRoomSpaces()
end
function Room:RecalculateRoomSpaces()
    self.emptyPositions = {}
    self.destructiblePositions = {}
    self.solidWallPositions = {}
    self.exitPosition = {}

    for i = 1, #self.roomTemplate do
        for j = 1, #self.roomTemplate[i] do
            local xPosition = j
            local yPosition = BASE_ROOM_SIZE - i

            if self.roomTemplate[i][j] == 0 then
                table.insert(self.emptyPositions, { xPosition, yPosition })
            elseif self.roomTemplate[i][j] == 1 then
                table.insert(self.solidWallPositions, { xPosition, yPosition })
            elseif self.roomTemplate[i][j] == 2 then
                table.insert(self.destructiblePositions, { xPosition, yPosition })
            elseif self.roomTemplate[i][j] == 3 then
                self.exitPosition = { xPosition, yPosition }
            end
        end
    end

    self.hasLeftExit = mod.RoomHasLeftExit(self.roomTemplate)
    self.hasRightExit = mod.RoomHasRightExit(self.roomTemplate)
    self.hasTopExit = mod.RoomHasTopExit(self.roomTemplate)
    self.hasBottomExit = mod.RoomHasBottomExit(self.roomTemplate)
end
function Room:GenerateRoomModels()
    local startX = self.rect.x
    local startY = self.rect.y

    -- Solid Walls
    for i = 1, #self.solidWallPositions do
        local xPosition = startX + self.solidWallPositions[i][1]
        local yPosition = startY + self.solidWallPositions[i][2]

        local solidWallInstance = DCEI.CreateUnit(0, 0, SOLID_WALL_PREFAB, xPosition, yPosition)
        table.insert(self.solidWallUnits, solidWallInstance)
    end

    -- Destructible Walls
    for i = 1, #self.destructiblePositions do
        local xPosition = startX + self.destructiblePositions[i][1]
        local yPosition = startY + self.destructiblePositions[i][2]

        local destructibleWallInstance = DCEI.CreateUnit(0, 0, BREAKABLE_WALL_PREFAB, xPosition, yPosition)
        table.insert(self.destructibleWallUnits, destructibleWallInstance)
    end
end
function Room:GetRoomTemplate()
    return self.roomTemplate
end
function Room:GetRoomType()
    return self.roomType
end

-- Room Identifiers:
-- SR: Secret Room
-- PR: Pathway Room
-- CUP: Connector Up Room
-- CDR: Connector Down Room
-- CSR: Cross Section Room
-- ER: Exit Room
local RoomGenerator = { rooms = {}, roomMatrix = {} }
RoomGenerator.__index = RoomGenerator
function RoomGenerator:new()
    local roomGenerator = {}
    setmetatable(roomGenerator, RoomGenerator)

    roomGenerator.rooms = {
        { nil, nil, nil },
        { nil, nil, nil },
        { nil, nil, nil }
    }
    roomGenerator.roomMatrix = {
        { "", "", "" },
        { "", "", "" },
        { "", "", "" }
    }

    roomGenerator:GenerateBaseRoomMatrix()
    roomGenerator:GenerateActualBasicRooms()
    roomGenerator:GenerateSecretRooms()
    roomGenerator:CreateRoomWalls()
    roomGenerator:GenerateRoomsModels()
    roomGenerator:PrintRoomMatrix()
    roomGenerator:PrintActualRoomMatrix()

    return roomGenerator
end
function RoomGenerator:GenerateBaseRoomMatrix()
    local currentRowIndex = 1
    local currentColumnIndex = math.random(1, MAX_COLUMNS) -- Probably read from Matrix Length?
    local generationComplete = false

    self.roomMatrix[currentRowIndex][currentColumnIndex] = PR

    while true do
        local randomNumber = math.random()
        if randomNumber <= 0.4 then -- Left
            local nextColumnIndex = currentColumnIndex - 1

            if nextColumnIndex < 1 then
                currentRowIndex, currentColumnIndex, generationComplete = self:PlaceRoomDown(currentRowIndex, currentColumnIndex)
            else
                currentColumnIndex = nextColumnIndex
                self:PlaceRoomLeftOrRight(currentRowIndex, currentColumnIndex)
            end

        elseif randomNumber <= 0.8 then -- Right
            local nextColumnIndex = currentColumnIndex + 1

            if nextColumnIndex > MAX_COLUMNS then
                currentRowIndex, currentColumnIndex, generationComplete = self:PlaceRoomDown(currentRowIndex, currentColumnIndex)
            else
                currentColumnIndex = nextColumnIndex
                self:PlaceRoomLeftOrRight(currentRowIndex, currentColumnIndex)
            end
        else -- Down
            currentRowIndex, currentColumnIndex, generationComplete = self:PlaceRoomDown(currentRowIndex, currentColumnIndex)
        end

        if generationComplete then
            break
        end
    end

    for i = 1, MAX_ROWS do
        for j = 1, MAX_COLUMNS do
            if self.roomMatrix[i][j] == "" then
                self.roomMatrix[i][j] = SR
            end
        end
    end
end
function RoomGenerator:GenerateActualBasicRooms()
    for i = 1, #self.roomMatrix do
        for j = 1, #self.roomMatrix[i] do
            local mappedI = #self.roomMatrix - i + 1 -- Flip when searching for room
            local roomType = self.roomMatrix[mappedI][j] 
            -- Keep the Room Matrix same as the Normal Matrix
            local rect = mod.Rect:new((j - 1) * BASE_ROOM_SIZE, (i - 1) * BASE_ROOM_SIZE, BASE_ROOM_SIZE, BASE_ROOM_SIZE)
            
            if roomType == PR then
                local randomIndex = math.random(1, #PATHWAY_ROOMS)
                local room = Room:new(PATHWAY_ROOMS[randomIndex], rect, PR)
                self.rooms[mappedI][j] = room
            elseif roomType == CUP then
                local randomIndex = math.random(1, #CONNECTOR_UP_ROOMS)
                local room = Room:new(CONNECTOR_UP_ROOMS[randomIndex], rect, CUP)
                self.rooms[mappedI][j] = room
            elseif roomType == CDR then
                local randomIndex = math.random(1, #CONNECTOR_DOWN_ROOMS)
                local room = Room:new(CONNECTOR_DOWN_ROOMS[randomIndex], rect, CDR)
                self.rooms[mappedI][j] = room
            elseif roomType == CSR then
                local randomIndex = math.random(1, #CROSS_ROAD_ROOMS)
                local room = Room:new(CROSS_ROAD_ROOMS[randomIndex], rect, CSR)
                self.rooms[mappedI][j] = room
            elseif roomType == ER then
                local randomIndex = math.random(1, #EXIT_ROOMS)
                local room = Room:new(EXIT_ROOMS[randomIndex], rect, ER)
                self.rooms[mappedI][j] = room
            elseif roomType == SR then
                DCEI.LogMessage("Generating Secret Rooms Later")
            else
                DCEI.LogError("Invalid Room Type")
            end
        end
    end
end
function RoomGenerator:GenerateSecretRooms()
    for x = 1, #self.roomMatrix do
        for j = 1, #self.roomMatrix[x] do
            -- Only handle secret rooms here
            -- This can be made clear by dynamically finding the side
            -- But if manual values can tell the info why not use it?

            local i = #self.roomMatrix - x + 1
            if self.roomMatrix[i][j] == SR then

                if i == 1 then -- Top Side
                    if j == 1 then -- Top Left Side
                        local hasLeftExit = self.rooms[i][j + 1] and self.rooms[i][j + 1].hasLeftExit or false
                        local hasTopExit = self.rooms[i + 1][j] and self.rooms[i + 1][j].hasTopExit or false
                        self:GenerateRandomSecretRoom(hasLeftExit, false, hasTopExit, false, x, i, j)

                    elseif j == #self.roomMatrix[i] then -- Top Right Side
                        local hasRightExit = self.rooms[i][j - 1] and self.rooms[i][j - 1].hasRightExit or false
                        local hasTopExit = self.rooms[i + 1][j] and self.rooms[i + 1][j].hasTopExit or false
                        self:GenerateRandomSecretRoom(false, hasRightExit, hasTopExit, false, x, i, j)
                        
                    else -- Side in the middle
                        local hasLeftExit = self.rooms[i][j - 1] and self.rooms[i][j - 1].hasLeftExit or false
                        local hasRightExit = self.rooms[i][j + 1] and self.rooms[i][j + 1].hasRightExit or false
                        local hasTopExit = self.rooms[i + 1][j] and self.rooms[i + 1][j].hasTopExit or false
                        self:GenerateRandomSecretRoom(hasLeftExit, hasRightExit, hasTopExit, false, x, i, j)
                    end
                elseif i == #self.roomMatrix then -- Bottom Side
                    if j == 1 then -- Bottom Left Side
                        local hasLeftExit = self.rooms[i][j + 1] and self.rooms[i][j + 1].hasLeftExit or false
                        local hasBottomExit = self.rooms[i - 1][j] and self.rooms[i - 1][j].hasBottomExit or false
                        self:GenerateRandomSecretRoom(hasLeftExit, false, false, hasBottomExit, x, i, j)

                    elseif j == #self.roomMatrix[i] then -- Bottom Right Side
                        local hasRightExit = self.rooms[i][j - 1] and self.rooms[i][j - 1].hasRightExit or false
                        local hasBottomExit = self.rooms[i - 1][j] and self.rooms[i - 1][j].hasBottomExit or false
                        self:GenerateRandomSecretRoom(false, hasRightExit, false, hasBottomExit, x, i, j)

                    else -- Side in the middle
                        local hasLeftExit = self.rooms[i][j - 1] and self.rooms[i][j - 1].hasLeftExit or false
                        local hasRightExit = self.rooms[i][j + 1] and self.rooms[i][j + 1].hasRightExit or false
                        local hasBottomExit = self.rooms[i - 1][j] and self.rooms[i - 1][j].hasBottomExit or false
                        self:GenerateRandomSecretRoom(hasLeftExit, hasRightExit, false, hasBottomExit, x, i, j)
                    end
                else -- Side in the middle
                    if j == 1 then -- Middle Left Side
                        local hasTopExit = self.rooms[i + 1][j] and self.rooms[i + 1][j].hasTopExit or false
                        local hasBottomExit = self.rooms[i - 1][j] and self.rooms[i - 1][j].hasBottomExit or false
                        local hasLeftExit = self.rooms[i][j + 1] and self.rooms[i][j + 1].hasLeftExit or false
                        self:GenerateRandomSecretRoom(hasLeftExit, false, hasTopExit, hasBottomExit, x, i, j)

                    elseif j == #self.roomMatrix[i] then -- Middle Right Side
                        local hasTopExit = self.rooms[i + 1][j] and self.rooms[i + 1][j].hasTopExit or false
                        local hasBottomExit = self.rooms[i - 1][j] and self.rooms[i - 1][j].hasBottomExit or false
                        local hasRightExit = self.rooms[i][j - 1] and self.rooms[i][j - 1].hasRightExit or false
                        self:GenerateRandomSecretRoom(false, hasRightExit, hasTopExit, hasBottomExit, x, i, j)

                    else -- Side in the middle
                        local hasTopExit = self.rooms[i + 1][j] and self.rooms[i + 1][j].hasTopExit or false
                        local hasBottomExit = self.rooms[i - 1][j] and self.rooms[i - 1][j].hasBottomExit or false
                        local hasLeftExit = self.rooms[i][j + 1] and self.rooms[i][j + 1].hasLeftExit or false
                        local hasRightExit = self.rooms[i][j - 1] and self.rooms[i][j - 1].hasRightExit or false
                        self:GenerateRandomSecretRoom(hasLeftExit, hasRightExit, hasTopExit, hasBottomExit, x, i, j)
                    end
                end
            end
        end
    end
end
function RoomGenerator:CreateRoomWalls()
    local stringValue = ""
    
    -- Top Row
    stringValue = ""
    for i = 1, #self.roomMatrix[1] do
        if self.rooms[1][i] then
            self.rooms[1][i]:BlockTopWalls()
            stringValue = stringValue .. self.rooms[1][i]:GetRoomType() .. " "
        end
    end
    DCEI.LogMessage("Top Row Rooms: " .. stringValue)

    -- Bottom Row
    local lastRow = #self.roomMatrix
    stringValue = ""
    for i = 1, #self.roomMatrix[lastRow] do
        if self.rooms[lastRow][i] then
            self.rooms[lastRow][i]:BlockBottomWalls()
            stringValue = stringValue .. self.rooms[lastRow][i]:GetRoomType() .. " "
        end
    end
    DCEI.LogMessage("Bottom Row Rooms: " .. stringValue)

    -- Left Column
    stringValue = ""
    for i = 1, #self.roomMatrix do
        if self.rooms[i][1] then
            self.rooms[i][1]:BlockLeftWalls()
            stringValue = stringValue .. self.rooms[i][1]:GetRoomType() .. " "
        end
    end
    DCEI.LogMessage("Left Column Rooms: " .. stringValue)

    -- Right Column
    stringValue = ""
    local lastColumn = #self.roomMatrix[1]
    for i = 1, #self.roomMatrix do
        if self.rooms[i][lastColumn] then
            self.rooms[i][lastColumn]:BlockRightWalls()
            stringValue = stringValue .. self.rooms[i][lastColumn]:GetRoomType() .. " "
        end
    end
    DCEI.LogMessage("Right Column Rooms: " .. stringValue)
end
function RoomGenerator:GenerateRoomsModels()
    for i = 1, #self.rooms do
        for j = 1, #self.roomMatrix[i] do
            if self.rooms[i][j] then
                self.rooms[i][j]:GenerateRoomModels()
            end
        end
    end
end
function RoomGenerator:GenerateRandomSecretRoom(hasLeftExit, hasRightExit, hasTopExit, hasBottomExit, actualRowIndex, rowIndex, columnIndex)
    DCEI.LogMessage("Generating Secret Rooms")

    local randomArray = { 0, 0, 0, 0 }
    if hasLeftExit then
        randomArray[1] = 1
    end
    if hasRightExit then
        randomArray[2] = 1
    end
    if hasTopExit then
        randomArray[3] = 1
    end
    if hasBottomExit then
        randomArray[4] = 1
    end

    -- Find valid sides where the secret rooms can be placed
    local validIndexes = {}
    for i = 1, #randomArray do
        if randomArray[i] == 1 then
            table.insert(validIndexes, i)
        end
    end

    if #validIndexes == 0 then
        DCEI.LogMessage("Row: " .. rowIndex .. ", Column: " .. columnIndex)
        self:PrintRoomMatrix()
        DCEI.LogError("Inaccessible Secret Room")
        return
    end
    
    local rect = mod.Rect:new((columnIndex - 1) * BASE_ROOM_SIZE, (actualRowIndex - 1) * BASE_ROOM_SIZE, BASE_ROOM_SIZE, BASE_ROOM_SIZE)
    local randomIndex = math.random(1, #validIndexes)
    local randomValue = validIndexes[randomIndex]

    if randomValue == 1 then
        local randomRoomIndex = math.random(1, #SECRET_ROOMS_RIGHT_EXIT)
        local room = Room:new(SECRET_ROOMS_RIGHT_EXIT[randomRoomIndex], rect, SR)
        self.rooms[rowIndex][columnIndex] = room
    elseif randomValue == 2 then
        local randomRoomIndex = math.random(1, #SECRET_ROOMS_LEFT_EXIT)
        local room = Room:new(SECRET_ROOMS_LEFT_EXIT[randomRoomIndex], rect, SR)
        self.rooms[rowIndex][columnIndex] = room
    elseif randomValue == 3 then
        local randomRoomIndex = math.random(1, #SECRET_ROOMS_BOTTOM_EXIT)
        local room = Room:new(SECRET_ROOMS_BOTTOM_EXIT[randomRoomIndex], rect, SR)
        self.rooms[rowIndex][columnIndex] = room
    else
        local randomRoomIndex = math.random(1, #SECRET_ROOMS_TOP_EXIT)
        local room = Room:new(SECRET_ROOMS_TOP_EXIT[randomRoomIndex], rect, SR)
        self.rooms[rowIndex][columnIndex] = room
    end
end
function RoomGenerator:PlaceRoomDown(currentRowIndex, currentColumnIndex)
    local nextRowIndex = currentRowIndex + 1

    if nextRowIndex > MAX_ROWS then -- This means it went out of bounds
        self.roomMatrix[currentRowIndex][currentColumnIndex] = ER
        return currentRowIndex, currentColumnIndex, true
    end

    if self.roomMatrix[currentRowIndex][currentColumnIndex] == CUP then
        self.roomMatrix[currentRowIndex][currentColumnIndex] = CSR
    else
        self.roomMatrix[currentRowIndex][currentColumnIndex] = CDR
    end

    currentRowIndex = nextRowIndex
    self.roomMatrix[currentRowIndex][currentColumnIndex] = CUP

    return currentRowIndex, currentColumnIndex, false
end
function RoomGenerator:PlaceRoomLeftOrRight(currentRowIndex, currentColumnIndex)
    local randomNumber = math.random()
    
    if randomNumber <= 0.5 then
        self.roomMatrix[currentRowIndex][currentColumnIndex] = CUP
    else
        self.roomMatrix[currentRowIndex][currentColumnIndex] = PR
    end
end
function RoomGenerator:PrintRoomMatrix()
    DCEI.LogMessage("Normal Room Matrix")
    for i = 1, MAX_ROWS do
        local stringValue = ""
        for j = 1, MAX_COLUMNS do
            stringValue = stringValue .. self.roomMatrix[i][j] .. " "
        end
        DCEI.LogMessage(stringValue)
    end
end
function RoomGenerator:PrintActualRoomMatrix()
    DCEI.LogMessage("Actual Room Matrix")
    for i = 1, MAX_ROWS do
        local stringValue = ""
        for j = 1, MAX_COLUMNS do
            local roomType = self.rooms[i][j] and self.rooms[i][j]:GetRoomType() or "SR"
            stringValue = stringValue .. roomType .. " "
        end
        DCEI.LogMessage(stringValue)
    end
end

function mod.RoomHasLeftExit(roomTemplate)
    for i = 1, #roomTemplate do
        if roomTemplate[i][1] == 0 then
            return true
        end
    end

    return false
end
function mod.RoomHasRightExit(roomTemplate)
    local lastColumn = #roomTemplate[1]
    for i = 1, #roomTemplate do
        if roomTemplate[i][lastColumn] == 0 then
            return true
        end
    end

    return false
end
function mod.RoomHasTopExit(roomTemplate)
    local totalColumns = #roomTemplate[1]

    for i = 1, totalColumns do
        if roomTemplate[1][i] == 0 then
            return true
        end
    end
    
    return false
end
function mod.RoomHasBottomExit(roomTemplate)
    local totalColumns = #roomTemplate[1]
    local lastRow = #roomTemplate

    for i = 1, totalColumns do
        if roomTemplate[lastRow][i] == 0 then
            return true
        end
    end

    return false
end

function mod.CopyRoomTemplate(roomTemplate)
    local newTemplate = {}
    
    for i = 1, #roomTemplate do
        table.insert(newTemplate, {})
        for j = 1, #roomTemplate[i] do
            table.insert(newTemplate[i], roomTemplate[i][j])
        end
    end

    return newTemplate
end


mod.RoomGenerator = RoomGenerator
mod.Room = Room

mod.VectorDistance = nil
mod.Rect = nil

mod.EnemyHobGoblin = nil
mod.EnemyGoblinChef = nil

return mod