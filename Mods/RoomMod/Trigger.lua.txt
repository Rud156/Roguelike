local ArcadeCore = GameModules["Arcade/Core"]
local mod = {}

local ROOM_ENTRY_DETECT_OFFSET = 2

-- #region Room Data Class
local RoomData = { 
    rect = nil, 
    
    -- Walls
    solidWalls = {}, 
    breakableWalls = {}, 
    
    -- Other Positions
    enemySpawnPositions = {}, 
    collectiblePositions = {},
    emptyPositions = {},

    -- Exits
    roomExits = {},
    roomExitPositions = {},
    roomExitPrefab = "",

    -- Spawn Info
    playerInRoom = false,
    roomCleared = false,

    -- Room Enemies
    enemies = {},
    enemyPositions = {},
    enemyPrefabs = {},
    totalWaveCount = 0,
    currentWaveCount = 0
}
RoomData.__index = RoomData
-- Patterns contains Map Generation data
-- 0: Solid Wall
-- 1: Breakable Wall
-- 2: Doorway
-- 3: Enemy Spawn Positions
-- 4: Collectible Positions
-- This is just a basic map template for testing
function RoomData:new(
    rect, pattern, 
    totalWaveCount,
    solidWallPrefab, breakableWallPrefab, doorwayPrefab,
    enemyPrefabs, collectiblePrefabs
)
    local roomData = {}
    setmetatable(roomData, RoomData)

    roomData.rect = rect

    roomData.solidWalls = {}
    roomData.breakableWalls = {}
    
    roomData.enemySpawnPositions = {}
    roomData.collectiblePositions = {}
    roomData.emptyPositions = {}

    roomData.roomExits = {}
    roomData.roomExitPositions = {}
    roomData.roomExitPrefab = doorwayPrefab
    
    roomData.playerInRoom = false
    roomData.roomCleared = false

    roomData.enemies = {}
    roomData.enemyPositions = {}
    roomData.enemyPrefabs = enemyPrefabs
    roomData.totalWaveCount = totalWaveCount
    roomData.currentWaveCount = 0

    local startX = rect.x
    local startY = rect.y

    for i = 1, #pattern do
        for j = 1, #pattern[i] do
            local patternValue = pattern[i][j]
            local xPosition = startX + i
            local yPosition = startY + j

            if patternValue == 0 then
                local solidWallInstance = DCEI.CreateUnit(0, 0, solidWallPrefab, xPosition, yPosition)
                table.insert(roomData.solidWalls, solidWallInstance)

            elseif patternValue == 1 then
                local breakableWallInstance = DCEI.CreateUnit(0, 0, breakableWallPrefab, xPosition, yPosition)
                table.insert(roomData.breakableWalls, breakableWallInstance)

            elseif patternValue == 2 then
                local doorwayPosition = { x = xPosition, y = yPosition }
                table.insert(roomData.roomExitPositions, doorwayPosition)
                
            elseif patternValue == 3 then
                local enemyPosition = { x = xPosition, y = yPosition }
                table.insert(roomData.enemyPositions, enemyPosition)

            elseif patternValue == 4 then
                -- TODO: Complete this part...

            elseif patternValue == 5 then
                local emptyPosition = { x = xPosition, y = yPosition }
                table.insert(roomData.emptyPositions, emptyPosition)
            else
                DCEI.LogMessage("Invalid Tile ID")
            end
        end
    end

    return roomData
end
function RoomData:UpdateEnemies(deltaTime, player)
    local playerPosition = DCEI.GetUnitPosition2D(player)
    for i, enemy in ipairs(self.enemies) do

        -- This is a fallback check in case a dead enemy still remains in queue
        local mainUnit = enemy:GetMainUnit()
        if not ArcadeCore.UnitIsAlive(mainUnit) then
            self:ForceRemoveUnitAtIndex(i)
            break
        end

        enemy:Update(deltaTime, playerPosition)
    end
end
function RoomData:IsPlayerInRoom(player)
    if self.playerInRoom then
        return
    end

    local playerPosition = DCEI.GetUnitPosition2D(player)
    if self.rect:containsWithOffset(playerPosition.x, playerPosition.y, ROOM_ENTRY_DETECT_OFFSET) then
        self:InitializePlayerEntered()
    end
end
function RoomData:InitializePlayerEntered()
    if self.roomCleared then
        return -- Don't do anything as the player has already cleared the room
    end

    self.playerInRoom = true
    self:CreateDoors()
    self:SpawnNextWave()
end
function RoomData:RemovedDeadEnemy(enemyUnit)
    if not self.playerInRoom then
        return
    end

    local index = -1
    for i, enemy in ipairs(self.enemies) do
        if enemy:GetMainUnit() == enemyUnit then
            index = i
            break
        end
    end

    if index ~= -1 then
        local enemyClassInstance = self.enemies[index]
        enemyClassInstance:CleanupEnemyDied()
        table.remove(self.enemies, index)
    end

    local totalEnemyCount = #self.enemies
    if totalEnemyCount == 0 then
        self:SpawnNextWave()
    end
end
function RoomData:ForceRemoveUnitAtIndex(index)
    if index == -1 then
        return
    end

    table.remove(self.enemies, index)
    local totalEnemyCount = #self.enemies
    if totalEnemyCount == 0 then
        self:SpawnNextWave()
    end
end
function RoomData:SpawnNextWave()
    if self.currentWaveCount >= self.totalWaveCount then
        self:MarkRoomCleared()
        return
    end

    for i, enemyPosition in ipairs(self.enemyPositions) do
        local randomValue = math.random()
        if randomValue <= 0.25 then
            local randomEnemyIndex = math.random(1, #self.enemyPrefabs)
            local randomEnemy = self.enemyPrefabs[randomEnemyIndex]
            local enemy

            if randomEnemy == 0 then
                enemy = mod.EnemyGoblinChef:new(self, enemyPosition.x, enemyPosition.y)
            elseif randomEnemy == 1 then
                enemy = mod.EnemyHobGoblin:new(self, enemyPosition.x, enemyPosition.y)
            end
            
            table.insert(self.enemies, enemy)
        end
    end

    local enemyCount = #self.enemies
    if enemyCount == 0 then
        DCEI.LogMessage("0 enemies were spawned. Force spawning 1 enemy")

        local randomPositionIndex = math.random(1, #self.enemyPositions)
        local enemyPosition = self.enemyPositions[randomPositionIndex]
        local randomEnemyIndex = math.random(1, #self.enemyPrefabs)
        local randomEnemy = self.enemyPrefabs[randomEnemyIndex]
        local enemy

        if randomEnemy == 0 then
            enemy = mod.EnemyGoblinChef:new(self, enemyPosition.x, enemyPosition.y)
        elseif randomEnemy == 1 then
            enemy = mod.EnemyHobGoblin:new(self, enemyPosition.x, enemyPosition.y)
        end
        
        table.insert(self.enemies, enemy)
    end

    self.currentWaveCount = self.currentWaveCount + 1
end
function RoomData:MarkRoomCleared()
    self.roomCleared = true
    self:RemoveDoors()
end
function RoomData:CreateDoors()
    for i, doorwayPosition in ipairs(self.roomExitPositions) do
        local doorway = DCEI.CreateUnit(0, 0, self.roomExitPrefab, doorwayPosition.x, doorwayPosition.y)
        table.insert(self.roomExits, doorway)
    end
end
function RoomData:RemoveDoors()
    for i, doorway in ipairs(self.roomExits) do
        DCEI.RemoveUnit(doorway)
    end

    self.roomExits = {}
end
function RoomData:GetNearestEnemy(player)
    if not self.playerInRoom then
        return nil
    end

    local playerPosition = DCEI.GetUnitPosition2D(player)
    local lastNearestEnemy = nil
    local lastEnemyDistance = 100

    for i, enemyUnit in ipairs(self.enemies) do
        local enemyPosition = DCEI.GetUnitPosition2D(enemyUnit:GetMainUnit())
        local distance = mod.VectorDistance(playerPosition, enemyPosition)
        
        if distance < lastEnemyDistance then
            lastNearestEnemy = enemyUnit:GetMainUnit()
            lastEnemyDistance = distance
        end
    end

    return lastNearestEnemy
end
function RoomData:GetEmptyPositions()
    return self.emptyPositions
end
function RoomData:ClearEnemies()
    for i, enemy in ipairs(self.enemies) do
        local mainUnit = enemy:GetMainUnit()
        DCEI.RemoveUnit(mainUnit)
        enemy:CleanupEnemyDied()
    end

    self.enemies = {}
end
function RoomData:Reset()
    self:ClearEnemies()
    self:RemoveDoors()

    self.currentWaveCount = 0
    self.playerInRoom = false
    self.roomCleared = false
end
-- #endregion


mod.VectorDistance = nil
mod.EnemyHobGoblin = nil
mod.EnemyGoblinChef = nil
mod.RoomData = RoomData
return mod