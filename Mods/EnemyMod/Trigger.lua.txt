local ArcadeCore = GameModules["Arcade/Core"]

-- Constants
-- TODO: Probably put common strings into a Mod and use that?
local ENEMY_STUNNED_BEHAVIOUR = "_Enemy_Stunned"
local ENEMY_INVINCIBLE = "_Unit_Invincible"

local ENEMY_FLASH_BEHAVIOUR = "_Enemy_Damage_Taken"
local ENEMY_FLASH_DURATION = 0.15

local GOBLIN_CHEF = "_Enemy_GoblinChef"
local GOBLIN_CHEF_ATTACK = "_Enemy_GoblinChef_Attack"
local GOBLIN_CHEF_ATTACK_RANGE = 3
local GOBLIN_CHEF_TIME_BETWEEN_ATTACKS = 0.7
local GOBLIN_CHEF_SHOT_COUNT = 3
local GOBLIN_CHEF_ATTACK_COOLDOWN = 5
local GOBLIN_CHEF_ATTACK_RANGE = 7
local GOBLIN_CHEF_MIN_CLOSEST_DISTANCE = 2.5
local GOBLIN_CHEF_MOVEBACK_DISTANCE = 5
local GOBLIN_CHEF_MOVEBACK_TIMER = 3
local GOBLIN_CHEF_STUN_TIME = 3.5
local GOBLIN_CHEF_GOLD = { MinGold = 3, MaxGold = 5 }

local GOBLIN_HOB = "_Enemy_Hobgoblin"
local GOBLIN_HOB_ATTACK = "_Enemy_Hobgoblin_Attack"
local GOBLIN_HOB_ATTACK_RANGE = 1
local GOBLIN_HOB_ATTACK_WAIT_TIMER = 4
local GOBLIN_HOB_MIN_CLOSEST_DISTANCE = 1
local GOBLIN_HOB_STUN_TIME = 2.5
local GOBLIN_HOB_GOLD = { MinGold = 5, MaxGold = 8 }

local GOBLIN = "_Enemy_Goblin"
local GOBLIN_ATTACK = "_Enemy_Goblin_Attack"
local GOBLIN_ATTACK_RANGE = 1
local GOBLIN_ATTACK_WAIT_TIMER = 2
local GOBLIN_MIN_CLOSEST_DISTANCE = 1
local GOBLIN_STUN_TIME = 3.5
local GOBLIN_GOLD = { MinGold = 3, MaxGold = 5 }

local GOBLIN_SAPPER = "_Enemy_GoblinSapper"
local GOBLIN_SAPPER_ATTACK = "_Enemy_GoblinSapper_Attack"
local GOBLIN_SAPPER_MIN_CLOSEST_DISTANCE = 1
local GOBLIN_SAPPER_STUN_TIMER = 3.5

local OOZE = "_Enemy_Ooze"
local OOZE_ATTACK = "_Enemy_Ooze_Attack"
local OOZE_RESPAWN = "_Enemy_Ooze_ReSpawn"
local OOZE_ATTACK_ANIM_TIME = 1
local OOZE_TARGETTING_RANGE = 3
local OOZE_ATTACK_RANGE = 0.8
local OOZE_RANDOM_MOVEMENT_TIMER = 3
local OOZE_JUMP_RADIUS = 1
local OOZE_IDLING_TIME = 1
local OOZE_ATTACK_TIME = 4
local OOZE_GOLD = 1

local GOBLIN_MINER = "_Enemy_GoblinMiner"
local GOBLIN_MINER_LEAP_UNIT = "_Missile_Enemy_GoblinMiner_Leap_Static_Model"
local GOBLIN_MINER_LEAP_AIRSTRAFE = "_Enemy_GoblinMiner_Leap_AirStrafe"
local GOBLIN_MINER_LEAP_START = "_Enemy_GoblinMiner_Leap_Start"
local GOBLIN_MINER_LEAP_END = "_Enemy_GoblinMiner_Leap_End"
local GOBLIN_MINER_ROCKET_BARRAGE = "_Enemy_GoblinMiner_RocketBarrage"
local GOBLIN_MINER_ROCKET_EFFECT = "_Launch_Enemy_GoblinMiner_RocketBarrage"
local GOBLIN_MINER_DRILL = "_Enemy_GoblinMiner_Drill"
local GOBLIN_MINER_DRILL_START = "_Enemy_GoblinMiner_Drill_Start"
local GOBLIN_MINER_DRILL_END  = "_Enemy_GoblinMiner_Drill_End"
local GOBLIN_MINER_LEAP = "_Enemy_GoblinMiner_Leap"
local GOBLIN_MINER_LEAP_EFFECT = "_Launch_Enemy_GoblinMiner_Leap"
local GOBLIN_MINER_RANDOM_MOVEMENT_TIMER = 3
local GOBLIN_MINER_GOBLIN_SPAWN_RADIUS = 5
local GOBLIN_MINER_GOBLIN_COUNT = 3
local GOBLIN_MINER_ROCKET_DELAY = 0.7
local GOBLIN_MINER_MIN_ROCKETS = 4
local GOBLIN_MINER_MAX_ROCKETS = 5
local GOBLIN_MINER_ROCKET_SKY_DELAY = 0.5
local GOBLIN_MINER_DRILL_TIMER = 0.5
local GOBLIN_MINER_MIN_DRILL_COUNT = 5
local GOBLIN_MINER_MAX_DRILL_COUNT = 6
local GOBLIN_MINER_DRILL_WIND_TIME = 0.45
local GOBLIN_MINER_DRILL_FOLLOW_TIME = 0.35
local GOBLIN_MINER_AIR_STRAFE_LERP = 2
local GOBLIN_MINER_LEAP_START_TIME = 1 -- Initial wind up animation time
local GOBLIN_MINER_LEAP_SKY_DELAY = 2 -- How long it takes to go up
local GOBLIN_MINER_LEAP_AIRSTRAFE_TIME = 1 -- How long it tracks the player when in air
local GOBLIN_MINER_LEAP_LAND_TIME = 2.8 -- How it takes to come down. So that the enemy is displayed again
-- Attack Ranges
local GOBLIN_MINER_ROCKET_RANGE = { min = 4 }
local GOBLIN_MINER_DRILL_RANGE = { min = 1, max = 5 }
local GOBLIN_MINER_LEAP_RANGE = { min = 0 } 
local GOBLIN_MINER_GOBLIN_RANGE = {}

local mod = {}

-- #region Goblin Chef Enemy
local GoblinChef = {
    -- Units
    room = nil,
    unit = nil,
    
    enemyState = 0, -- 0: Idle, 1: Targetting Movement, 2: Move Back, 3: Attacking, 4: Stunned

    -- MoveBack
    targetMovebackPoint = nil,
    movebackTimer = 0,

    -- Attack
    attackCooldownTimer = 0,
    currentTimeBetweenAttacks = 0,
    currentShotCount = 0,

    -- Stunned
    stunTimer = 0
}
GoblinChef.__index = GoblinChef
function GoblinChef:new(room, xPosition, yPosition)
    local goblinChef = {}
    setmetatable(goblinChef, GoblinChef)

    local enemyUnit = DCEI.CreateUnit(-1, -1, GOBLIN_CHEF, xPosition, yPosition)
    goblinChef.room = room
    goblinChef.unit = enemyUnit

    goblinChef.enemyState = 0

    goblinChef.targetMovebackPoint = nil

    goblinChef.attackCooldownTimer = 0
    goblinChef.currentTimeBetweenAttacks = 0
    goblinChef.currentShotCount = 0

    goblinChef.stunTimer = 0

    return goblinChef
end
function GoblinChef:Update(deltaTime, playerPosition)
    -- Idle will be the main state switcher...
    if self.enemyState == 0 then
        self:UpdateIdleState(deltaTime, playerPosition)
    elseif self.enemyState == 1 then
        self:TargetPlayer(deltaTime, playerPosition)
    elseif self.enemyState == 2 then
        self:UpdateMoveBackState(deltaTime)
    elseif self.enemyState == 3 then
        self:AttackPlayer(deltaTime, playerPosition)
    elseif self.enemyState == 4 then
        self:UpdateEnemyStunned(deltaTime)
    end

    if self.enemyState ~= 3 then
        self.attackCooldownTimer = self.attackCooldownTimer - deltaTime
    end
end
function GoblinChef:CheckAndActivateStunnedState(enemyUnit)
    if self.unit == enemyUnit then
        local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
        DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)

        self.stunTimer = GOBLIN_CHEF_STUN_TIME
        self:SetEnemyState(4)

        return true
    end

    return false
end
function GoblinChef:UpdateIdleState(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer <= GOBLIN_CHEF_ATTACK_RANGE then
        if self.attackCooldownTimer <= 0 then
            self.currentShotCount = GOBLIN_CHEF_SHOT_COUNT
            self.currentTimeBetweenAttacks = 0
            self.attackCooldownTimer = 0

            local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
            DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)
            self:SetEnemyState(3)
        else
            local randomAwayPoint = self:FindRandomMoveBackPointAroundPlayer(playerPosition)
            self.targetMovebackPoint = randomAwayPoint
            self.movebackTimer = GOBLIN_CHEF_MOVEBACK_TIMER
            self:SetEnemyState(2)    
        end

    elseif distanceFromPlayer < GOBLIN_CHEF_MIN_CLOSEST_DISTANCE then
        local randomAwayPoint = self:FindRandomMoveBackPointAroundPlayer(playerPosition)
        self.targetMovebackPoint = randomAwayPoint
        self.movebackTimer = GOBLIN_CHEF_MOVEBACK_TIMER
        self:SetEnemyState(2)

    else
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
        self:SetEnemyState(1)
    end
end
function GoblinChef:TargetPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer > GOBLIN_CHEF_MIN_CLOSEST_DISTANCE then
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
    end

    -- Switch to Attack State only when moving normally
    if distanceFromPlayer <= GOBLIN_CHEF_ATTACK_RANGE then
        if self.attackCooldownTimer <= 0 then
            self.currentShotCount = GOBLIN_CHEF_SHOT_COUNT
            self.currentTimeBetweenAttacks = 0
            self.attackCooldownTimer = 0

            local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
            DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)
            self:SetEnemyState(3)

        else
            local randomAwayPoint = self:FindRandomMoveBackPointAroundPlayer(playerPosition)
            self.targetMovebackPoint = randomAwayPoint
            self.movebackTimer = GOBLIN_CHEF_MOVEBACK_TIMER
            self:SetEnemyState(2)
        end
    end
end
function GoblinChef:UpdateMoveBackState(deltaTime)
    DCEI.Move(self.unit, self.targetMovebackPoint.x, self.targetMovebackPoint.y)
    self.movebackTimer = self.movebackTimer - deltaTime

    if self.movebackTimer <= 0 then
        self:SetEnemyState(0) -- Reset to Idle State to find a new movement
    end
end
function GoblinChef:AttackPlayer(deltaTime, playerPosition)
    self:LookAtPlayer(playerPosition)

    self.currentTimeBetweenAttacks = self.currentTimeBetweenAttacks - deltaTime
    if self.currentTimeBetweenAttacks <= 0 then
        self:LaunchEnemyAttack(playerPosition)
        self.currentShotCount = self.currentShotCount - 1
        self.currentTimeBetweenAttacks = GOBLIN_CHEF_TIME_BETWEEN_ATTACKS
    end

    if self.currentShotCount < 0 then
        self.attackCooldownTimer = GOBLIN_CHEF_ATTACK_COOLDOWN
        self:SetEnemyState(0)
    end
end
function GoblinChef:LaunchEnemyAttack(playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local direction = mod.VectorSubtract(playerPosition, enemyPosition)
    local yRotation = math.deg(math.atan(direction.x, direction.y))
    
    local xPoint = math.sin(math.rad(yRotation)) * GOBLIN_CHEF_ATTACK_RANGE + enemyPosition.x
    local yPoint = math.cos(math.rad(yRotation)) * GOBLIN_CHEF_ATTACK_RANGE + enemyPosition.y
    DCEI.CastAbilityAtPosition(GOBLIN_CHEF_ATTACK, self.unit, xPoint, yPoint)
end
function GoblinChef:UpdateEnemyStunned(deltaTime)
    self.stunTimer = self.stunTimer - deltaTime
    if self.stunTimer <= 0 then
        DCEI.RemoveBehavior(self.unit, ENEMY_STUNNED_BEHAVIOUR)
        self:SetEnemyState(0)
    end
end
function GoblinChef:LookAtPlayer(playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)

    local direction = mod.VectorSubtract(playerPosition, enemyPosition)
    local angle = math.deg(math.atan(direction.x, direction.y))

    DCEI.SetUnitRotationEuler(self.unit, 0, angle, 0)
end
function GoblinChef:FindRandomMoveBackPointAroundPlayer(playerPosition)
    local radius = GOBLIN_CHEF_MOVEBACK_DISTANCE
    local validPositions = {}

    for i = 0, 360 do
        local xPosition = radius * math.sin(math.rad(i)) + playerPosition.x
        local yPosition = radius * math.cos(math.rad(i)) + playerPosition.y

        if DCEI.IsPointOnNavMesh(xPosition, yPosition) then
            table.insert(validPositions, { x = xPosition, y = yPosition })
        end
    end

    local randomIndex = math.random(1, #validPositions)
    local randomPosition = validPositions[randomIndex]

    return randomPosition
end
function GoblinChef:SetEnemyState(enemyState)
    self.enemyState = enemyState
end
function GoblinChef:GetEnemyGold()
    return math.random(GOBLIN_CHEF_GOLD.MinGold, GOBLIN_CHEF_GOLD.MaxGold)
end
function GoblinChef:GetMainUnit()
    return self.unit
end
function GoblinChef:CleanupEnemyDied()
    -- Do nothing here...
end
function GoblinChef:IsActive()
    return true
end
function GoblinChef:ForceSetPosition(position)
    return false
end
-- #endregion

-- #region Hob Goblin Enemy
local HobGoblin = {
    -- Units
    room = nil,
    unit = nil,
    
    enemyState = 0, -- 0: Targetting Movement, 1: Attack Waiting, 2: Stunned

    -- Attack
    attackWaitTimer = 0,

    -- Movement
    isMoving = false,

    -- Stunned
    stunTimer = 0
}
HobGoblin.__index = HobGoblin
function HobGoblin:new(room, xPosition, yPosition)
    local hobGoblin = {}
    setmetatable(hobGoblin, HobGoblin)

    local enemyUnit = DCEI.CreateUnit(-1, -1, GOBLIN_HOB, xPosition, yPosition)
    hobGoblin.room = room
    hobGoblin.unit = enemyUnit

    hobGoblin.enemyState = 0

    hobGoblin.attackWaitTimer = 0

    hobGoblin.isMoving = false

    hobGoblin.stunTimer = 0

    return hobGoblin
end
function HobGoblin:Update(deltaTime, playerPosition)
    if self.enemyState == 0 then
        self:TargetPlayer(deltaTime, playerPosition)
    elseif self.enemyState == 1 then
        self:WaitAfterAttack(deltaTime, playerPosition)
    elseif self.enemyState == 2 then
        self:UpdateEnemyStunned(deltaTime)
    end
end
function HobGoblin:CheckAndActivateStunnedState(enemyUnit)
    if self.unit == enemyUnit then
        local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
        DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)

        self.stunTimer = GOBLIN_HOB_STUN_TIME
        self:SetEnemyState(2)

        return true
    end

    return false
end
function HobGoblin:TargetPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer > GOBLIN_HOB_MIN_CLOSEST_DISTANCE then
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
        self.isMoving = true
    else
        if self.isMoving then
            -- Basically stop the enemy when it gets too near
            local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
            DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)
            self.isMoving = false
        end
    end
    
    -- Switch to Attack State only when moving normally
    if distanceFromPlayer <= GOBLIN_HOB_ATTACK_RANGE and self.attackWaitTimer <= 0 then
        self.attackWaitTimer = 0
        self:AttackPlayer(deltaTime, playerPosition)
    end
end
function HobGoblin:WaitAfterAttack(deltaTime, playerPosition)
    self.attackWaitTimer = self.attackWaitTimer - deltaTime
    if self.attackWaitTimer <= 0 then
        self:SetEnemyState(0)
    else
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
    end
end
function HobGoblin:AttackPlayer(deltaTime, playerPosition)
    self:LookAtPlayer(deltaTime, playerPosition) -- This is probably not required

    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    DCEI.CastAbilityAtPosition(GOBLIN_HOB_ATTACK, self.unit, enemyPosition.x, enemyPosition.y)

    self.attackWaitTimer = GOBLIN_HOB_ATTACK_WAIT_TIMER
    self:SetEnemyState(1)
end
function HobGoblin:UpdateEnemyStunned(deltaTime)
    self.stunTimer = self.stunTimer - deltaTime
    if self.stunTimer <= 0 then
        DCEI.RemoveBehavior(self.unit, ENEMY_STUNNED_BEHAVIOUR)

        self.attackWaitTimer = 0
        self:SetEnemyState(0)
    end
end
function HobGoblin:LookAtPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)

    local direction = mod.VectorSubtract(playerPosition, enemyPosition)
    local angle = math.deg(math.atan(direction.x, direction.y))

    DCEI.SetUnitRotationEuler(self.unit, 0, angle, 0)
end
function HobGoblin:SetEnemyState(enemyState)
    self.enemyState = enemyState
end
function HobGoblin:GetEnemyGold()
    return math.random(GOBLIN_HOB_GOLD.MinGold, GOBLIN_HOB_GOLD.MaxGold)
end
function HobGoblin:GetMainUnit()
    return self.unit
end
function HobGoblin:CleanupEnemyDied()
    -- Do nothing here...
end
function HobGoblin:IsActive()
    return true
end
function HobGoblin:ForceSetPosition(position)
    return false
end
-- #endregion

-- #region Goblin Enemy
local Goblin = {
    -- Units
    room = nil,
    unit = nil,
    
    enemyState = 0, -- 0: Targetting Movement, 1: Attack Waiting, 2: Stunned

    -- Attack
    attackWaitTimer = 0,

    -- Movement
    isMoving = false,

    -- Stunned
    stunTimer = 0
}
Goblin.__index = Goblin
function Goblin:new(room, xPosition, yPosition)
    local goblin = {}
    setmetatable(goblin, Goblin)

    local enemyUnit = DCEI.CreateUnit(-1, -1, GOBLIN, xPosition, yPosition)
    goblin.room = room
    goblin.unit = enemyUnit

    goblin.enemyState = 0

    goblin.attackWaitTimer = 0

    goblin.isMoving = false

    goblin.stunTimer = 0

    return goblin
end
function Goblin:Update(deltaTime, playerPosition)
    if self.enemyState == 0 then
        self:TargetPlayer(deltaTime, playerPosition)
    elseif self.enemyState == 1 then
        self:WaitAfterAttack(deltaTime, playerPosition)
    elseif self.enemyState == 2 then
        self:UpdateEnemyStunned(deltaTime)
    end
end
function Goblin:CheckAndActivateStunnedState(enemyUnit)
    if self.unit == enemyUnit then
        local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
        DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)

        self.stunTimer = GOBLIN_STUN_TIME
        self:SetEnemyState(2)

        return true
    end

    return false
end
function Goblin:TargetPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer > GOBLIN_MIN_CLOSEST_DISTANCE then
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
        self.isMoving = true
    else
        if self.isMoving then
            -- Basically stop the enemy when it gets too near
            local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
            DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)
            self.isMoving = false
        end
    end
    
    -- Switch to Attack State only when moving normally
    if distanceFromPlayer <= GOBLIN_ATTACK_RANGE and self.attackWaitTimer <= 0 then
        self.attackWaitTimer = 0
        self:AttackPlayer(deltaTime, playerPosition)
    end
end
function Goblin:WaitAfterAttack(deltaTime, playerPosition)
    self.attackWaitTimer = self.attackWaitTimer - deltaTime
    if self.attackWaitTimer <= 0 then
        self:SetEnemyState(0)
    else
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
    end
end
function Goblin:AttackPlayer(deltaTime, playerPosition)
    self:LookAtPlayer(deltaTime, playerPosition) -- This is probably not required

    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    DCEI.CastAbilityAtPosition(GOBLIN_ATTACK, self.unit, enemyPosition.x, enemyPosition.y)

    self.attackWaitTimer = GOBLIN_ATTACK_WAIT_TIMER
    self:SetEnemyState(1)
end
function Goblin:UpdateEnemyStunned(deltaTime)
    self.stunTimer = self.stunTimer - deltaTime
    if self.stunTimer <= 0 then
        DCEI.RemoveBehavior(self.unit, ENEMY_STUNNED_BEHAVIOUR)

        self.attackWaitTimer = 0
        self:SetEnemyState(0)
    end
end
function Goblin:LookAtPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)

    local direction = mod.VectorSubtract(playerPosition, enemyPosition)
    local angle = math.deg(math.atan(direction.x, direction.y))

    DCEI.SetUnitRotationEuler(self.unit, 0, angle, 0)
end
function Goblin:SetEnemyState(enemyState)
    self.enemyState = enemyState
end
function Goblin:GetEnemyGold()
    return math.random(GOBLIN_GOLD.MinGold, GOBLIN_GOLD.MaxGold)
end
function Goblin:GetMainUnit()
    return self.unit
end
function Goblin:CleanupEnemyDied()
    -- Do nothing here...
end
function Goblin:IsActive()
    return true
end
function Goblin:ForceSetPosition(position)
    return false
end
-- #endregion

-- #region Goblin Sapper Enemy
local GoblinSapper = {
    -- Units
    room = nil,
    unit = nil,
    
    enemyState = 0, -- 0: Targetting Movement, 1: Attack Waiting, 2: Stunned

    stunTimer = 0
}
GoblinSapper.__index = GoblinSapper
function GoblinSapper:new(room, xPosition, yPosition)
    local goblinSapper = {}
    setmetatable(goblinSapper, GoblinSapper)

    local enemyUnit = DCEI.CreateUnit(-1, -1, GOBLIN_SAPPER, xPosition, yPosition)
    goblinSapper.room = room
    goblinSapper.unit = enemyUnit

    goblinSapper.enemyState = 0

    goblinSapper.stunTimer = 0

    return goblinSapper
end
function GoblinSapper:Update(deltaTime, playerPosition)
    if self.enemyState == 0 then
        self:TargetPlayer(deltaTime, playerPosition)
    elseif self.enemyState == 1 then
        -- Do nothing here...
    elseif self.enemyState == 2 then
        self:UpdateEnemyStunned(deltaTime)
    end
end
function GoblinSapper:CheckAndActivateStunnedState(enemyUnit)
    if self.unit == enemyUnit then
        local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
        DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)

        self.stunTimer = GOBLIN_SAPPER_STUN_TIMER
        self:SetEnemyState(2)

        return true
    end

    return false
end
function GoblinSapper:TargetPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer > GOBLIN_SAPPER_MIN_CLOSEST_DISTANCE then
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
    else
        DCEI.CastAbilityAtPosition(GOBLIN_SAPPER_ATTACK, self.unit, enemyPosition.x, enemyPosition.y)
        self:SetEnemyState(1)
    end
end
function GoblinSapper:UpdateEnemyStunned(deltaTime)
    self.stunTimer = self.stunTimer - deltaTime
    if self.stunTimer <= 0 then
        DCEI.RemoveBehavior(self.unit, ENEMY_STUNNED_BEHAVIOUR)

        self:SetEnemyState(0)
    end
end
function GoblinSapper:SetEnemyState(enemyState)
    self.enemyState = enemyState
end
function GoblinSapper:GetEnemyGold()
    return 0
end
function GoblinSapper:GetMainUnit()
    return self.unit
end
function GoblinSapper:CleanupEnemyDied()
    -- Do nothing here...
end
function GoblinSapper:IsActive()
    return true
end
function GoblinSapper:ForceSetPosition(position)
    return false
end
-- #endregion

-- #region Ooze Enemy
local Ooze = {
    -- Units
    room = nil,
    unit = nil,
    
    enemyState = 0, -- 0: Random Movement, 1: Targetting Movement, 2: Attack Anim Timer, 3: Attack Waiting, 4: Idling

    -- Random Movement
    targetPosition = nil,

    -- General
    currentTimer = 0,
}
Ooze.__index = Ooze
function Ooze:new(room, xPosition, yPosition)
    local ooze = {}
    setmetatable(ooze, Ooze)

    local enemyUnit = DCEI.CreateUnit(-1, -1, OOZE, xPosition, yPosition)
    ooze.room = room
    ooze.unit = enemyUnit

    ooze.enemyState = 0

    ooze.targetPosition = nil
    ooze.currentTimer = 0

    return ooze
end
function Ooze:Update(deltaTime, playerPosition)
    if self.enemyState == 0 then
        self:UpdateRandomMovement(deltaTime, playerPosition)
    elseif self.enemyState == 1 then
        self:TargetPlayer(deltaTime, playerPosition)
    elseif self.enemyState == 2 then
        self:UpdateAttackAnimTimer(deltaTime)
    elseif self.enemyState == 3 then
        self:UpdateAttackWaitingState(deltaTime, playerPosition)
    elseif self.enemyState == 4 then
        self:UpdateIdlingState(deltaTime)
    end
end
function Ooze:CheckAndActivateStunnedState(enemyUnit)
    DCEI.RemoveBehavior(self.unit, ENEMY_STUNNED_BEHAVIOUR)
end
function Ooze:UpdateRandomMovement(deltaTime, playerPosition)
    if self.targetPosition == nil then
        self:FindAndSetRandomMovement()
        return
    end

    self.currentTimer = self.currentTimer - deltaTime

    if self.currentTimer <= 0 then
        self:FindAndSetRandomMovement()
    end

    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer <= OOZE_TARGETTING_RANGE then
        self:SetEnemyState(1)
    elseif distanceFromPlayer <= OOZE_ATTACK_RANGE then
        self:AttackPlayer(playerPosition)
        self:SetEnemyState(2)
    else
        DCEI.Move(self.unit, self.targetPosition.x, self.targetPosition.y)
    end
end
function Ooze:TargetPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer <= OOZE_ATTACK_RANGE then
        self:AttackPlayer(playerPosition)
        self:SetEnemyState(2)
    else
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
    end
end
function Ooze:UpdateAttackAnimTimer(deltaTime)
    self.currentTimer = self.currentTimer - deltaTime
    if self.currentTimer <= 0 then
        local behaviourStackCount = DCEI.UnitBehaviorStackCount(self.unit, ENEMY_INVINCIBLE)
        if behaviourStackCount == 0 then
            self.currentTimer = OOZE_IDLING_TIME
            self:SetEnemyState(4)
        else
            -- Surefooted
            local additionalTimer = 0
            local skillStatus = self.room.skillDisplay.hexGenerator:GetSkillStatus(mod.SkillNames.Surefooted)
            
            if skillStatus.isUnlocked then
                local value = mod.GetSkillValue(mod.SkillNames.Surefooted, skillStatus.skillLevel)
                additionalTimer = value
            end

            self.currentTimer = OOZE_ATTACK_TIME - OOZE_ATTACK_TIME * additionalTimer
            self:SetEnemyState(3)
        end
    end
end
function Ooze:UpdateAttackWaitingState(deltaTime, playerPosition)
    DCEI.SetUnitPosition2D(self.unit, playerPosition.x, playerPosition.y)
    self.currentTimer = self.currentTimer - deltaTime

    if self.currentTimer <= 0 then
        DCEI.RemoveBehavior(self.unit, ENEMY_INVINCIBLE)
        DCEI.ApplyBehavior(self.unit, OOZE_RESPAWN)

        local randomPosition = self:FindEmptyPlaceInCircle(playerPosition)
        DCEI.SetUnitPosition2D(self.unit, randomPosition.x, randomPosition.y)
        DCEI.Move(self.unit, randomPosition.x, randomPosition.y)

        self.currentTimer = OOZE_IDLING_TIME
        self:SetEnemyState(4)
    end
end
function Ooze:UpdateIdlingState(deltaTime)
    self.currentTimer = self.currentTimer - deltaTime
    if self.currentTimer <= 0 then
        self:SetEnemyState(0)
    end
end
function Ooze:AttackPlayer(playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)

    DCEI.CastAbilityAtPosition(OOZE_ATTACK, self.unit, enemyPosition.x, enemyPosition.y)
    self.currentTimer = OOZE_ATTACK_ANIM_TIME
end
function Ooze:FindEmptyPlaceInCircle(playerPosition)
    local radius = OOZE_JUMP_RADIUS
    local validPositions = {}

    for i = 0, 360 do
        local xPosition = radius * math.sin(math.rad(i)) + playerPosition.x
        local yPosition = radius * math.cos(math.rad(i)) + playerPosition.y

        if DCEI.IsPointOnNavMesh(xPosition, yPosition) then
            table.insert(validPositions, { x = xPosition, y = yPosition })
        end
    end

    local randomIndex = math.random(1, #validPositions)
    local randomPosition = validPositions[randomIndex]

    return randomPosition
end
function Ooze:FindAndSetRandomMovement()
    local emptyPositions = self.room:GetEmptyPositions()
    local randomEmptyPosition = math.random(1, #emptyPositions)

    local position = emptyPositions[randomEmptyPosition]

    self.targetPosition = { x = position.x, y = position.y }
    self.currentTimer = OOZE_RANDOM_MOVEMENT_TIMER
end
function Ooze:SetEnemyState(enemyState)
    self.enemyState = enemyState
end
function Ooze:GetEnemyGold()
    return 1
end
function Ooze:GetMainUnit()
    return self.unit
end
function Ooze:CleanupEnemyDied()
    -- Do nothing here...
end
function Ooze:IsActive()
    return self.enemyState ~= 3
end
function Ooze:ForceSetPosition(position)
    return false
end
-- #endregion

-- #region Goblin Miner
local GoblinMiner = {
    -- Units
    room = nil,
    unit = nil,
    
    enemyState = 0, -- 0: Random Movement, 1: Rocket Barrage, 2: Leap Attack, 3: Drill Missile

    -- Movement
    targetPosition = nil,

    -- Leap
    fakeLeapUnit = nil,
    leapState = 0, -- -1: Wind Up, 0: Going Up, 1: Air Strafe, 2: Coming Down, 3: End Leap
    leapPosition = nil,

    -- General
    currentTimer = 0,
    attackCounter = 0,
    hasSkyAttackLaunched = false
}
GoblinMiner.__index = GoblinMiner
function GoblinMiner:new(room, xPosition, yPosition)
    local goblinMiner = {}
    setmetatable(goblinMiner, GoblinMiner)

    local enemyUnit = DCEI.CreateUnit(-1, -1, GOBLIN_MINER, xPosition, yPosition)
    goblinMiner.room = room
    goblinMiner.unit = enemyUnit
    
    goblinMiner.enemyState = 0

    goblinMiner.targetPosition = nil

    goblinMiner.fakeLeapUnit = nil
    goblinMiner.leapState = 0
    goblinMiner.leapPosition = nil

    goblinMiner.currentTimer = 0
    goblinMiner.attackCounter = 0
    goblinMiner.hasSkyAttackLaunched = false

    return goblinMiner
end
function GoblinMiner:Update(deltaTime, playerPosition)
    if self.enemyState == 0 then
        self:UpdateRandomMovement(deltaTime, playerPosition)

    elseif self.enemyState == 1 then
        self:UpdateRocketBarrage(deltaTime, playerPosition)

    elseif self.enemyState == 2 then
        self:UpdateLeapAttack(deltaTime, playerPosition)

    elseif self.enemyState == 3 then
        self:UpdateDrillAttack(deltaTime, playerPosition)

    end
end
function GoblinMiner:CheckAndActivateStunnedState(enemyUnit)
    DCEI.RemoveBehavior(self.unit, ENEMY_STUNNED_BEHAVIOUR)
end
function GoblinMiner:UpdateRandomMovement(deltaTime, playerPosition)
    if self.targetPosition == nil then
        self:FindAndSetRandomMovement()
        return
    end

    self.currentTimer = self.currentTimer - deltaTime

    if self.currentTimer <= 0 then
        self:ActivateRandomAtack(playerPosition)
    else
        DCEI.Move(self.unit, self.targetPosition.x, self.targetPosition.y)
    end
end
function GoblinMiner:UpdateRocketBarrage(deltaTime, playerPosition)
    self.currentTimer = self.currentTimer - deltaTime

    if self.currentTimer <= 0 then

        if self.hasSkyAttackLaunched then
            DCEI.CreateEffect(GOBLIN_MINER_ROCKET_EFFECT, self.unit, playerPosition.x, playerPosition.y)
            self.attackCounter = self.attackCounter - 1

            self.currentTimer = GOBLIN_MINER_ROCKET_DELAY
            self.hasSkyAttackLaunched = false

            if self.attackCounter <= 0 then
                self:FindAndSetRandomMovement()
                self:SetEnemyState(0)
            end

        else
            self:LookAtPlayer(playerPosition)
            self:SetupRocketBarrage()
        end
    end
end
function GoblinMiner:UpdateLeapAttack(deltaTime, playerPosition)
    self.currentTimer = self.currentTimer - deltaTime

    if self.currentTimer <= 0 then
        if self.leapState == 0 then
            local position = DCEI.GetUnitPosition2D(self.unit)
            DCEI.CastAbilityAtPosition(GOBLIN_MINER_LEAP, self.unit, position.x, position.y)
            DCEI.RemoveUnit(self.fakeLeapUnit)
            DCEI.ApplyBehavior(self.unit, ENEMY_INVINCIBLE)

            self.leapState = 1
            self.currentTimer = GOBLIN_MINER_LEAP_SKY_DELAY

        elseif self.leapState == 1 then
            self.fakeLeapUnit = DCEI.CreateUnit(1, 1, GOBLIN_MINER_LEAP_AIRSTRAFE, playerPosition.x, playerPosition.y)
            DCEI.SetUnitPosition2D(self.fakeLeapUnit, playerPosition.x, playerPosition.y)
            self.leapState = 2
            self.currentTimer = GOBLIN_MINER_LEAP_AIRSTRAFE_TIME
            
        elseif self.leapState == 2 then
            DCEI.CreateEffect(GOBLIN_MINER_LEAP_EFFECT, self.unit, playerPosition.x, playerPosition.y)

            self.leapState = 3
            self.currentTimer = GOBLIN_MINER_LEAP_LAND_TIME
            self.leapPosition = playerPosition
            
        elseif self.leapState == 3 then
            DCEI.RemoveBehavior(self.unit, GOBLIN_MINER_LEAP_START)
            DCEI.ApplyBehavior(self.unit, GOBLIN_MINER_LEAP_END)
            DCEI.RemoveBehavior(self.unit, ENEMY_INVINCIBLE)
            DCEI.RemoveUnit(self.fakeLeapUnit)

            DCEI.SetUnitPosition2D(self.unit, self.leapPosition.x, self.leapPosition.y)
            DCEI.Move(self.unit, self.leapPosition.x, self.leapPosition.y)

            self:FindAndSetRandomMovement()
            self:SetEnemyState(0)

        else
            DCEI.LogError("Invalid Leap State!?")
        end
    end

    if self.leapState == 2 then
        local position = DCEI.GetUnitPosition2D(self.fakeLeapUnit)
        local targetPosition = mod.VectorLerp(position, playerPosition, GOBLIN_MINER_AIR_STRAFE_LERP * deltaTime)
        DCEI.SetUnitPosition2D(self.fakeLeapUnit, targetPosition.x, targetPosition.y)

    elseif self.leapState == 3 then
        local position = DCEI.GetUnitPosition2D(self.fakeLeapUnit)
        local targetPosition = mod.VectorLerp(position, self.leapPosition, GOBLIN_MINER_AIR_STRAFE_LERP * deltaTime)
        DCEI.SetUnitPosition2D(self.fakeLeapUnit, targetPosition.x, targetPosition.y)
    end
end
function GoblinMiner:UpdateDrillAttack(deltaTime, playerPosition)
    self.currentTimer = self.currentTimer - deltaTime
    
    if self.currentTimer <= 0 then
        if self.attackCounter == -10 then
            self.attackCounter = math.random(GOBLIN_MINER_MIN_DRILL_COUNT, GOBLIN_MINER_MAX_DRILL_COUNT)
        end

        if self.attackCounter > 0 then
            self:LaunchDrillMissile(playerPosition)

            if self.attackCounter == 0 then
                DCEI.ApplyBehavior(self.unit, GOBLIN_MINER_DRILL_END)
                self.currentTimer = GOBLIN_MINER_DRILL_FOLLOW_TIME
            end
        
        elseif self.attackCounter == 0 then
            self:SetEnemyState(0)
            self:FindAndSetRandomMovement()
        end
    end

    self:LookAtPlayer(playerPosition)
end
-- 1: Rocket Barrage, 2: Leap Attack, 3: Drill Missile, 4: Summon Goblins
function GoblinMiner:ActivateRandomAtack(playerPosition)
    local position = DCEI.GetUnitPosition2D(self.unit)
    DCEI.Move(self.unit, position.x, position.y)

    local randomAttack = self:GetValidAttacksForRange(playerPosition, position)

    if randomAttack == 1 then
        self.attackCounter = math.random(GOBLIN_MINER_MIN_ROCKETS, GOBLIN_MINER_MAX_ROCKETS)
        self:LookAtPlayer(playerPosition)
        self:SetupRocketBarrage()
        self:SetEnemyState(1)

    elseif randomAttack == 2 then
        self:LookAtPlayer(playerPosition)
        self:SetupLeap()

    elseif randomAttack == 3 then
        self:SetupDrillMissile()

    else
        self:SpawnGoblinsInCircle()
        self:SetEnemyState(0)
        self:FindAndSetRandomMovement()
    end
end
-- 1: Rocket Barrage, 2: Leap Attack, 3: Drill Missile, 4: Summon Goblins
function GoblinMiner:GetValidAttacksForRange(playerPosition, unitPosition)
    local distance = mod.VectorDistance(playerPosition, unitPosition)
    local validAttacks = {}

    local minRocketDistance = GOBLIN_MINER_ROCKET_RANGE.min or 0
    local maxRocketDistance = GOBLIN_MINER_ROCKET_RANGE.max or 999
    if distance >= minRocketDistance and distance <= maxRocketDistance then
        table.insert(validAttacks, 1)
    end

    local minLeapDist = GOBLIN_MINER_LEAP_RANGE.min or 0
    local maxLeapDist = GOBLIN_MINER_LEAP_RANGE.max or 999
    if distance >= minLeapDist and distance <= maxLeapDist then
        table.insert(validAttacks, 2)
    end

    local minDrillDist = GOBLIN_MINER_DRILL_RANGE.min or 0
    local maxDrillDist = GOBLIN_MINER_DRILL_RANGE.max or 999
    if distance >= minDrillDist and distance <= maxDrillDist then
        table.insert(validAttacks, 3)
    end

    local minGoblinDist = GOBLIN_MINER_GOBLIN_RANGE.min or 0
    local maxGoblinDist = GOBLIN_MINER_GOBLIN_RANGE.max or 999
    if distance >= minGoblinDist and distance <= maxGoblinDist then
        local roomEnemies = self.room:GetRoomEnemies()
        local hasOtherEnemies = false

        for _, enemy in ipairs(roomEnemies) do
            local unitName = DCEI.UnitName(enemy:GetMainUnit())
            if unitName ~= GOBLIN_MINER then
                hasOtherEnemies = true
                break
            end
        end

        if not hasOtherEnemies then
            table.insert(validAttacks, 4)

        else
            DCEI.LogError("Has Other Enemies!!!")

        end
    end

    DCEI.LogMessage("Attacks Length: " .. #validAttacks)

    local randomAttack = math.random(1, #validAttacks)
    return validAttacks[randomAttack]
end
function GoblinMiner:SetupRocketBarrage()
    local position = DCEI.GetUnitPosition2D(self.unit)
    DCEI.CastAbilityAtPosition(GOBLIN_MINER_ROCKET_BARRAGE, self.unit, position.x, position.y)

    self.currentTimer = GOBLIN_MINER_ROCKET_SKY_DELAY
    self.hasSkyAttackLaunched = true
end
function GoblinMiner:SetupLeap()
    local position = DCEI.GetUnitPosition2D(self.unit)
    local rotation = DCEI.GetUnitRotationEuler(self.unit)

    local fakeLeapUnit = DCEI.CreateUnit(1, 1, GOBLIN_MINER_LEAP_UNIT, position.x, position.y)
    DCEI.SetUnitRotationEuler(fakeLeapUnit, rotation.x, rotation.y, rotation.z)
    DCEI.ApplyBehavior(self.unit, GOBLIN_MINER_LEAP_START)

    self.fakeLeapUnit = fakeLeapUnit
    self.leapState = 0
    self.currentTimer = GOBLIN_MINER_LEAP_START_TIME

    self:SetEnemyState(2)
end
function GoblinMiner:SetupDrillMissile()
    DCEI.ApplyBehavior(self.unit, GOBLIN_MINER_DRILL_START)
    self.currentTimer = GOBLIN_MINER_DRILL_WIND_TIME
    self.attackCounter = -10 -- Probably use another variable to indicate another state?

    self:SetEnemyState(3)
end
function GoblinMiner:LaunchDrillMissile(playerPosition)
    DCEI.LogMessage("Launching Drill Missile")

    self.currentTimer = GOBLIN_MINER_DRILL_TIMER
    self.attackCounter = self.attackCounter - 1
    
    self:LookAtPlayer(playerPosition)
    
    DCEI.CastAbilityAtPosition(GOBLIN_MINER_DRILL, self.unit, playerPosition.x, playerPosition.y)
end
function GoblinMiner:SpawnGoblinsInCircle()
    DCEI.LogMessage("Spawning Goblins")
    
    local radius = GOBLIN_MINER_GOBLIN_SPAWN_RADIUS
    local validPositions = {}
    local position = DCEI.GetUnitPosition2D(self.unit)

    for i = 0, 360 do
        local xPosition = radius * math.sin(math.rad(i)) + position.x
        local yPosition = radius * math.cos(math.rad(i)) + position.y

        if DCEI.IsPointOnNavMesh(xPosition, yPosition) then
            table.insert(validPositions, { x = xPosition, y = yPosition })
        end
    end
    
    validPositions = mod.ShuffleTable(validPositions)
    for i = 1, GOBLIN_MINER_GOBLIN_COUNT do
        local spawnPosition = validPositions[i]

        local goblin = Goblin:new(self.room, spawnPosition.x, spawnPosition.y)
        self.room:AddChildEnemy(goblin)
    end
end
function GoblinMiner:LookAtPlayer(playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)

    local direction = mod.VectorSubtract(playerPosition, enemyPosition)
    local angle = math.deg(math.atan(direction.x, direction.y))

    DCEI.SetUnitRotationEuler(self.unit, 0, angle, 0)
end
function GoblinMiner:FindAndSetRandomMovement()
    local emptyPositions = self.room:GetEmptyPositions()
    local randomEmptyPosition = math.random(1, #emptyPositions)

    local position = emptyPositions[randomEmptyPosition]

    self.targetPosition = { x = position.x, y = position.y }
    self.currentTimer = GOBLIN_MINER_RANDOM_MOVEMENT_TIMER
end
function GoblinMiner:SetEnemyState(enemyState)
    DCEI.LogMessage("Enemy State: " .. enemyState)
    self.enemyState = enemyState
end
function GoblinMiner:GetEnemyGold()
    return 1
end
function GoblinMiner:GetMainUnit()
    return self.unit
end
function GoblinMiner:CleanupEnemyDied()
    -- Do nothing here...
end
function GoblinMiner:IsActive()
    return true
end
function GoblinMiner:ForceSetPosition(position)
    DCEI.SetUnitPosition2D(self.unit, position.x, position.y)
    DCEI.Move(self.unit, position.x, position.y)
    return true
end
-- #endregion

mod.EnemyGoblinChef = GoblinChef 
mod.EnemyHobGoblin = HobGoblin
mod.EnemyGoblin = Goblin
mod.EnemyGoblinSapper = GoblinSapper
mod.EnemyOoze = Ooze
mod.EnemyGoblinMiner = GoblinMiner

mod.VectorDistance = nil
mod.VectorSubtract = nil
mod.VectorLerp = nil
mod.LerpAngleDeg = nil
mod.NormalizeUnitRotation = nil
mod.ShuffleTable = nil

mod.WalkableTextureId = nil

mod.GetSkillValue = nil
mod.SkillNames = nil

mod.EnemyInvincible = ENEMY_INVINCIBLE
mod.EnemyFlashBehviour = ENEMY_FLASH_BEHAVIOUR
mod.EnemyFlashDuration = ENEMY_FLASH_DURATION

return mod
