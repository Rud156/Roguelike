local ArcadeCore = GameModules["Arcade/Core"]

-- Constants
-- TODO: Probably put common strings into a Mod and use that?
local ENEMY_STUNNED_BEHAVIOUR = "_Enemy_Stunned"
local ENEMY_INVINCIBLE = "_Unit_Invincible"

local GOBLIN_CHEF = "_Enemy_GoblinChef"
local GOBLIN_CHEF_ATTACK = "_Enemy_GoblinChef_Attack"
local GOBLIN_CHEF_ATTACK_RANGE = 3
local GOBLIN_CHEF_TIME_BETWEEN_ATTACKS = 0.7
local GOBLIN_CHEF_SHOT_COUNT = 3
local GOBLIN_CHEF_ATTACK_COOLDOWN = 5
local GOBLIN_CHEF_ATTACK_RANGE = 7
local GOBLIN_CHEF_MIN_CLOSEST_DISTANCE = 2.5
local GOBLIN_CHEF_MOVEBACK_DISTANCE = 5
local GOBLIN_CHEF_MOVEBACK_TIMER = 3
local GOBLIN_CHEF_STUN_TIME = 3.5
local GOBLIN_CHEF_GOLD = { MinGold = 3, MaxGold = 5 }

local GOBLIN_HOB = "_Enemy_Hobgoblin"
local GOBLIN_HOB_ATTACK = "_Enemy_Hobgoblin_Attack"
local GOBLIN_HOB_ATTACK_RANGE = 1
local GOBLIN_HOB_ATTACK_WAIT_TIMER = 4
local GOBLIN_HOB_MIN_CLOSEST_DISTANCE = 1
local GOBLIN_HOB_STUN_TIME = 2.5
local GOBLIN_HOB_GOLD = { MinGold = 5, MaxGold = 8 }

local GOBLIN = "_Enemy_Goblin"
local GOBLIN_ATTACK = "_Enemy_Goblin_Attack"
local GOBLIN_ATTACK_RANGE = 1
local GOBLIN_ATTACK_WAIT_TIMER = 1.5
local GOBLIN_MIN_CLOSEST_DISTANCE = 1
local GOBLIN_STUN_TIME = 3.5
local GOBLIN_GOLD = { MinGold = 3, MaxGold = 5 }

local GOBLIN_SAPPER = "_Enemy_GoblinSapper"
local GOBLIN_SAPPER_ATTACK = "_Enemy_GoblinSapper_Attack"
local GOBLIN_SAPPER_MIN_CLOSEST_DISTANCE = 1
local GOBLIN_SAPPER_STUN_TIMER = 3.5

local OOZE = "_Enemy_Ooze"
local OOZE_ATTACK = "_Enemy_Ooze_Attack"
local OOZE_RESPAWN = "_Enemy_Ooze_ReSpawn"
local OOZE_ATTACK_ANIM_TIME = 1
local OOZE_TARGETTING_RANGE = 3
local OOZE_ATTACK_RANGE = 0.8
local OOZE_RANDOM_MOVEMENT_TIMER = 3
local OOZE_JUMP_RADIUS = 1
local OOZE_IDLING_TIME = 1
local OOZE_ATTACK_TIME = 4
local OOZE_GOLD = 1

local GOBLIN_MINER = "_Enemy_GoblinMiner"
local GOBLIN_MINER_DRILL = "_Enemy_GoblinMiner_Drill"
local GOBLIN_MINER_DRILL_START = "_Enemy_GoblinMiner_Drill_Start"
local GOBLIN_MINER_DRILL_END  = "_Enemy_GoblinMiner_Drill_End"
local GOBLIN_MINER_LEAP = "_Enemy_GoblinMiner_Leap"
local GOBLIN_MINER_ROCKET = "_Launch_Enemy_GoblinMiner_RocketBarrage"
local GOBLIN_MINER_RANDOM_MOVEMENT_TIMER = 3
local GOBLIN_MINER_GOBLIN_SPAWN_RADIUS = 1
local GOBLIN_MINER_GOBLIN_COUNT = 5
local GOBLIN_MINER_ROCKET_DELAY = 0.7
local GOBLIN_MINER_MIN_ROCKETS = 4
local GOBLIN_MINER_MAX_ROCKETS = 5
local GOBLIN_MINER_DRILL_TIMER = 1
local GOBLIN_MINER_MIN_DRILL_COUNT = 3
local GOBLIN_MINER_MAX_DRILL_COUNT = 5
local GOBLIN_MINER_DRILL_WIND_TIME = 0.55
local GOBLIN_MINER_DRILL_FOLLOW_TIME = 0.35
local GOBLIN_MINER_LEAP_TIMER = 2

local mod = {}

-- #region Goblin Chef Enemy
local GoblinChef = {
    -- Units
    room = nil,
    unit = nil,
    
    enemyState = 0, -- 0: Idle, 1: Targetting Movement, 2: Move Back, 3: Attacking, 4: Stunned

    -- MoveBack
    targetMovebackPoint = nil,
    movebackTimer = 0,

    -- Attack
    attackCooldownTimer = 0,
    currentTimeBetweenAttacks = 0,
    currentShotCount = 0,

    -- Stunned
    stunTimer = 0
}
GoblinChef.__index = GoblinChef
function GoblinChef:new(room, xPosition, yPosition)
    local goblinChef = {}
    setmetatable(goblinChef, GoblinChef)

    local enemyUnit = DCEI.CreateUnit(-1, -1, GOBLIN_CHEF, xPosition, yPosition)
    goblinChef.room = room
    goblinChef.unit = enemyUnit

    goblinChef.enemyState = 0

    goblinChef.targetMovebackPoint = nil

    goblinChef.attackCooldownTimer = 0
    goblinChef.currentTimeBetweenAttacks = 0
    goblinChef.currentShotCount = 0

    goblinChef.stunTimer = 0

    return goblinChef
end
function GoblinChef:Update(deltaTime, playerPosition)
    -- Idle will be the main state switcher...
    if self.enemyState == 0 then
        self:UpdateIdleState(deltaTime, playerPosition)
    elseif self.enemyState == 1 then
        self:TargetPlayer(deltaTime, playerPosition)
    elseif self.enemyState == 2 then
        self:UpdateMoveBackState(deltaTime)
    elseif self.enemyState == 3 then
        self:AttackPlayer(deltaTime, playerPosition)
    elseif self.enemyState == 4 then
        self:UpdateEnemyStunned(deltaTime)
    end

    if self.enemyState ~= 3 then
        self.attackCooldownTimer = self.attackCooldownTimer - deltaTime
    end
end
function GoblinChef:CheckAndActivateStunnedState(enemyUnit)
    if self.unit == enemyUnit then
        local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
        DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)

        self.stunTimer = GOBLIN_CHEF_STUN_TIME
        self:SetEnemyState(4)

        return true
    end

    return false
end
function GoblinChef:UpdateIdleState(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer <= GOBLIN_CHEF_ATTACK_RANGE then
        if self.attackCooldownTimer <= 0 then
            self.currentShotCount = GOBLIN_CHEF_SHOT_COUNT
            self.currentTimeBetweenAttacks = 0
            self.attackCooldownTimer = 0

            local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
            DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)
            self:SetEnemyState(3)
        else
            local randomAwayPoint = self:FindRandomMoveBackPointAroundPlayer(playerPosition)
            self.targetMovebackPoint = randomAwayPoint
            self.movebackTimer = GOBLIN_CHEF_MOVEBACK_TIMER
            self:SetEnemyState(2)    
        end

    elseif distanceFromPlayer < GOBLIN_CHEF_MIN_CLOSEST_DISTANCE then
        local randomAwayPoint = self:FindRandomMoveBackPointAroundPlayer(playerPosition)
        self.targetMovebackPoint = randomAwayPoint
        self.movebackTimer = GOBLIN_CHEF_MOVEBACK_TIMER
        self:SetEnemyState(2)

    else
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
        self:SetEnemyState(1)
    end
end
function GoblinChef:TargetPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer > GOBLIN_CHEF_MIN_CLOSEST_DISTANCE then
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
    end

    -- Switch to Attack State only when moving normally
    if distanceFromPlayer <= GOBLIN_CHEF_ATTACK_RANGE then
        if self.attackCooldownTimer <= 0 then
            self.currentShotCount = GOBLIN_CHEF_SHOT_COUNT
            self.currentTimeBetweenAttacks = 0
            self.attackCooldownTimer = 0

            local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
            DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)
            self:SetEnemyState(3)

        else
            local randomAwayPoint = self:FindRandomMoveBackPointAroundPlayer(playerPosition)
            self.targetMovebackPoint = randomAwayPoint
            self.movebackTimer = GOBLIN_CHEF_MOVEBACK_TIMER
            self:SetEnemyState(2)
        end
    end
end
function GoblinChef:UpdateMoveBackState(deltaTime)
    DCEI.Move(self.unit, self.targetMovebackPoint.x, self.targetMovebackPoint.y)
    self.movebackTimer = self.movebackTimer - deltaTime

    if self.movebackTimer <= 0 then
        self:SetEnemyState(0) -- Reset to Idle State to find a new movement
    end
end
function GoblinChef:AttackPlayer(deltaTime, playerPosition)
    self:LookAtPlayer(playerPosition)

    self.currentTimeBetweenAttacks = self.currentTimeBetweenAttacks - deltaTime
    if self.currentTimeBetweenAttacks <= 0 then
        self:LaunchEnemyAttack(playerPosition)
        self.currentShotCount = self.currentShotCount - 1
        self.currentTimeBetweenAttacks = GOBLIN_CHEF_TIME_BETWEEN_ATTACKS
    end

    if self.currentShotCount < 0 then
        self.attackCooldownTimer = GOBLIN_CHEF_ATTACK_COOLDOWN
        self:SetEnemyState(0)
    end
end
function GoblinChef:LaunchEnemyAttack(playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local direction = mod.VectorSubtract(playerPosition, enemyPosition)
    local yRotation = math.deg(math.atan(direction.x, direction.y))
    
    local xPoint = math.sin(math.rad(yRotation)) * GOBLIN_CHEF_ATTACK_RANGE + enemyPosition.x
    local yPoint = math.cos(math.rad(yRotation)) * GOBLIN_CHEF_ATTACK_RANGE + enemyPosition.y
    DCEI.CastAbilityAtPosition(GOBLIN_CHEF_ATTACK, self.unit, xPoint, yPoint)
end
function GoblinChef:UpdateEnemyStunned(deltaTime)
    self.stunTimer = self.stunTimer - deltaTime
    if self.stunTimer <= 0 then
        DCEI.RemoveBehavior(self.unit, ENEMY_STUNNED_BEHAVIOUR)
        self:SetEnemyState(0)
    end
end
function GoblinChef:LookAtPlayer(playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)

    local direction = mod.VectorSubtract(playerPosition, enemyPosition)
    local angle = math.deg(math.atan(direction.x, direction.y))

    DCEI.SetUnitRotationEuler(self.unit, 0, angle, 0)
end
function GoblinChef:FindRandomMoveBackPointAroundPlayer(playerPosition)
    local radius = GOBLIN_CHEF_MOVEBACK_DISTANCE
    local validPositions = {}

    for i = 0, 360 do
        local xPosition = radius * math.sin(math.rad(i)) + playerPosition.x
        local yPosition = radius * math.cos(math.rad(i)) + playerPosition.y

        if DCEI.IsPointOnNavMesh(xPosition, yPosition) then
            table.insert(validPositions, { x = xPosition, y = yPosition })
        end
    end

    local randomIndex = math.random(1, #validPositions)
    local randomPosition = validPositions[randomIndex]

    return randomPosition
end
function GoblinChef:SetEnemyState(enemyState)
    self.enemyState = enemyState
end
function GoblinChef:GetEnemyGold()
    return math.random(GOBLIN_CHEF_GOLD.MinGold, GOBLIN_CHEF_GOLD.MaxGold)
end
function GoblinChef:GetMainUnit()
    return self.unit
end
function GoblinChef:CleanupEnemyDied()
    -- Do nothing here...
end
function GoblinChef:IsActive()
    return true
end
function GoblinChef:ForceSetPosition(position)
    return false
end
-- #endregion

-- #region Hob Goblin Enemy
local HobGoblin = {
    -- Units
    room = nil,
    unit = nil,
    
    enemyState = 0, -- 0: Targetting Movement, 1: Attack Waiting, 2: Stunned

    -- Attack
    attackWaitTimer = 0,

    -- Movement
    isMoving = false,

    -- Stunned
    stunTimer = 0
}
HobGoblin.__index = HobGoblin
function HobGoblin:new(room, xPosition, yPosition)
    local hobGoblin = {}
    setmetatable(hobGoblin, HobGoblin)

    local enemyUnit = DCEI.CreateUnit(-1, -1, GOBLIN_HOB, xPosition, yPosition)
    hobGoblin.room = room
    hobGoblin.unit = enemyUnit

    hobGoblin.enemyState = 0

    hobGoblin.attackWaitTimer = 0

    hobGoblin.isMoving = false

    hobGoblin.stunTimer = 0

    return hobGoblin
end
function HobGoblin:Update(deltaTime, playerPosition)
    if self.enemyState == 0 then
        self:TargetPlayer(deltaTime, playerPosition)
    elseif self.enemyState == 1 then
        self:WaitAfterAttack(deltaTime, playerPosition)
    elseif self.enemyState == 2 then
        self:UpdateEnemyStunned(deltaTime)
    end
end
function HobGoblin:CheckAndActivateStunnedState(enemyUnit)
    if self.unit == enemyUnit then
        local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
        DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)

        self.stunTimer = GOBLIN_HOB_STUN_TIME
        self:SetEnemyState(2)

        return true
    end

    return false
end
function HobGoblin:TargetPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer > GOBLIN_HOB_MIN_CLOSEST_DISTANCE then
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
        self.isMoving = true
    else
        if self.isMoving then
            -- Basically stop the enemy when it gets too near
            local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
            DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)
            self.isMoving = false
        end
    end
    
    -- Switch to Attack State only when moving normally
    if distanceFromPlayer <= GOBLIN_HOB_ATTACK_RANGE and self.attackWaitTimer <= 0 then
        self.attackWaitTimer = 0
        self:AttackPlayer(deltaTime, playerPosition)
    end
end
function HobGoblin:WaitAfterAttack(deltaTime, playerPosition)
    self.attackWaitTimer = self.attackWaitTimer - deltaTime
    if self.attackWaitTimer <= 0 then
        self:SetEnemyState(0)
    else
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
    end
end
function HobGoblin:AttackPlayer(deltaTime, playerPosition)
    self:LookAtPlayer(deltaTime, playerPosition) -- This is probably not required

    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    DCEI.CastAbilityAtPosition(GOBLIN_HOB_ATTACK, self.unit, enemyPosition.x, enemyPosition.y)

    self.attackWaitTimer = GOBLIN_HOB_ATTACK_WAIT_TIMER
    self:SetEnemyState(1)
end
function HobGoblin:UpdateEnemyStunned(deltaTime)
    self.stunTimer = self.stunTimer - deltaTime
    if self.stunTimer <= 0 then
        DCEI.RemoveBehavior(self.unit, ENEMY_STUNNED_BEHAVIOUR)

        self.attackWaitTimer = 0
        self:SetEnemyState(0)
    end
end
function HobGoblin:LookAtPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)

    local direction = mod.VectorSubtract(playerPosition, enemyPosition)
    local angle = math.deg(math.atan(direction.x, direction.y))

    DCEI.SetUnitRotationEuler(self.unit, 0, angle, 0)
end
function HobGoblin:SetEnemyState(enemyState)
    self.enemyState = enemyState
end
function HobGoblin:GetEnemyGold()
    return math.random(GOBLIN_HOB_GOLD.MinGold, GOBLIN_HOB_GOLD.MaxGold)
end
function HobGoblin:GetMainUnit()
    return self.unit
end
function HobGoblin:CleanupEnemyDied()
    -- Do nothing here...
end
function HobGoblin:IsActive()
    return true
end
function HobGoblin:ForceSetPosition(position)
    return false
end
-- #endregion

-- #region Goblin Enemy
local Goblin = {
    -- Units
    room = nil,
    unit = nil,
    
    enemyState = 0, -- 0: Targetting Movement, 1: Attack Waiting, 2: Stunned

    -- Attack
    attackWaitTimer = 0,

    -- Movement
    isMoving = false,

    -- Stunned
    stunTimer = 0
}
Goblin.__index = Goblin
function Goblin:new(room, xPosition, yPosition)
    local goblin = {}
    setmetatable(goblin, Goblin)

    local enemyUnit = DCEI.CreateUnit(-1, -1, GOBLIN, xPosition, yPosition)
    goblin.room = room
    goblin.unit = enemyUnit

    goblin.enemyState = 0

    goblin.attackWaitTimer = 0

    goblin.isMoving = false

    goblin.stunTimer = 0

    return goblin
end
function Goblin:Update(deltaTime, playerPosition)
    if self.enemyState == 0 then
        self:TargetPlayer(deltaTime, playerPosition)
    elseif self.enemyState == 1 then
        self:WaitAfterAttack(deltaTime, playerPosition)
    elseif self.enemyState == 2 then
        self:UpdateEnemyStunned(deltaTime)
    end
end
function Goblin:CheckAndActivateStunnedState(enemyUnit)
    if self.unit == enemyUnit then
        local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
        DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)

        self.stunTimer = GOBLIN_STUN_TIME
        self:SetEnemyState(2)

        return true
    end

    return false
end
function Goblin:TargetPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer > GOBLIN_MIN_CLOSEST_DISTANCE then
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
        self.isMoving = true
    else
        if self.isMoving then
            -- Basically stop the enemy when it gets too near
            local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
            DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)
            self.isMoving = false
        end
    end
    
    -- Switch to Attack State only when moving normally
    if distanceFromPlayer <= GOBLIN_ATTACK_RANGE and self.attackWaitTimer <= 0 then
        self.attackWaitTimer = 0
        self:AttackPlayer(deltaTime, playerPosition)
    end
end
function Goblin:WaitAfterAttack(deltaTime, playerPosition)
    self.attackWaitTimer = self.attackWaitTimer - deltaTime
    if self.attackWaitTimer <= 0 then
        self:SetEnemyState(0)
    else
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
    end
end
function Goblin:AttackPlayer(deltaTime, playerPosition)
    self:LookAtPlayer(deltaTime, playerPosition) -- This is probably not required

    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    DCEI.CastAbilityAtPosition(GOBLIN_ATTACK, self.unit, enemyPosition.x, enemyPosition.y)

    self.attackWaitTimer = GOBLIN_ATTACK_WAIT_TIMER
    self:SetEnemyState(1)
end
function Goblin:UpdateEnemyStunned(deltaTime)
    self.stunTimer = self.stunTimer - deltaTime
    if self.stunTimer <= 0 then
        DCEI.RemoveBehavior(self.unit, ENEMY_STUNNED_BEHAVIOUR)

        self.attackWaitTimer = 0
        self:SetEnemyState(0)
    end
end
function Goblin:LookAtPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)

    local direction = mod.VectorSubtract(playerPosition, enemyPosition)
    local angle = math.deg(math.atan(direction.x, direction.y))

    DCEI.SetUnitRotationEuler(self.unit, 0, angle, 0)
end
function Goblin:SetEnemyState(enemyState)
    self.enemyState = enemyState
end
function Goblin:GetEnemyGold()
    return math.random(GOBLIN_GOLD.MinGold, GOBLIN_GOLD.MaxGold)
end
function Goblin:GetMainUnit()
    return self.unit
end
function Goblin:CleanupEnemyDied()
    -- Do nothing here...
end
function Goblin:IsActive()
    return true
end
function Goblin:ForceSetPosition(position)
    return false
end
-- #endregion

-- #region Goblin Sapper Enemy
local GoblinSapper = {
    -- Units
    room = nil,
    unit = nil,
    
    enemyState = 0, -- 0: Targetting Movement, 1: Attack Waiting, 2: Stunned

    stunTimer = 0
}
GoblinSapper.__index = GoblinSapper
function GoblinSapper:new(room, xPosition, yPosition)
    local goblinSapper = {}
    setmetatable(goblinSapper, GoblinSapper)

    local enemyUnit = DCEI.CreateUnit(-1, -1, GOBLIN_SAPPER, xPosition, yPosition)
    goblinSapper.room = room
    goblinSapper.unit = enemyUnit

    goblinSapper.enemyState = 0

    goblinSapper.stunTimer = 0

    return goblinSapper
end
function GoblinSapper:Update(deltaTime, playerPosition)
    if self.enemyState == 0 then
        self:TargetPlayer(deltaTime, playerPosition)
    elseif self.enemyState == 1 then
        -- Do nothing here...
    elseif self.enemyState == 2 then
        self:UpdateEnemyStunned(deltaTime)
    end
end
function GoblinSapper:CheckAndActivateStunnedState(enemyUnit)
    if self.unit == enemyUnit then
        local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
        DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)

        self.stunTimer = GOBLIN_SAPPER_STUN_TIMER
        self:SetEnemyState(2)

        return true
    end

    return false
end
function GoblinSapper:TargetPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer > GOBLIN_SAPPER_MIN_CLOSEST_DISTANCE then
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
    else
        DCEI.CastAbilityAtPosition(GOBLIN_SAPPER_ATTACK, self.unit, enemyPosition.x, enemyPosition.y)
        self:SetEnemyState(1)
    end
end
function GoblinSapper:UpdateEnemyStunned(deltaTime)
    self.stunTimer = self.stunTimer - deltaTime
    if self.stunTimer <= 0 then
        DCEI.RemoveBehavior(self.unit, ENEMY_STUNNED_BEHAVIOUR)

        self:SetEnemyState(0)
    end
end
function GoblinSapper:SetEnemyState(enemyState)
    self.enemyState = enemyState
end
function GoblinSapper:GetEnemyGold()
    return 0
end
function GoblinSapper:GetMainUnit()
    return self.unit
end
function GoblinSapper:CleanupEnemyDied()
    -- Do nothing here...
end
function GoblinSapper:IsActive()
    return true
end
function GoblinSapper:ForceSetPosition(position)
    return false
end
-- #endregion

-- #region Ooze Enemy
local Ooze = {
    -- Units
    room = nil,
    unit = nil,
    
    enemyState = 0, -- 0: Random Movement, 1: Targetting Movement, 2: Attack Anim Timer, 3: Attack Waiting, 4: Idling

    -- Random Movement
    targetPosition = nil,

    -- General
    currentTimer = 0,
}
Ooze.__index = Ooze
function Ooze:new(room, xPosition, yPosition)
    local ooze = {}
    setmetatable(ooze, Ooze)

    local enemyUnit = DCEI.CreateUnit(-1, -1, OOZE, xPosition, yPosition)
    ooze.room = room
    ooze.unit = enemyUnit

    ooze.enemyState = 0

    ooze.targetPosition = nil
    ooze.currentTimer = 0

    return ooze
end
function Ooze:Update(deltaTime, playerPosition)
    if self.enemyState == 0 then
        self:UpdateRandomMovement(deltaTime, playerPosition)
    elseif self.enemyState == 1 then
        self:TargetPlayer(deltaTime, playerPosition)
    elseif self.enemyState == 2 then
        self:UpdateAttackAnimTimer(deltaTime)
    elseif self.enemyState == 3 then
        self:UpdateAttackWaitingState(deltaTime, playerPosition)
    elseif self.enemyState == 4 then
        self:UpdateIdlingState(deltaTime)
    end
end
function Ooze:CheckAndActivateStunnedState(enemyUnit)
    -- Do nothing here...
end
function Ooze:UpdateRandomMovement(deltaTime, playerPosition)
    if self.targetPosition == nil then
        self:FindAndSetRandomMovement()
        return
    end

    self.currentTimer = self.currentTimer - deltaTime

    if self.currentTimer <= 0 then
        self:FindAndSetRandomMovement()
    end

    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer <= OOZE_TARGETTING_RANGE then
        self:SetEnemyState(1)
    elseif distanceFromPlayer <= OOZE_ATTACK_RANGE then
        self:AttackPlayer(playerPosition)
        self:SetEnemyState(2)
    else
        DCEI.Move(self.unit, self.targetPosition.x, self.targetPosition.y)
    end
end
function Ooze:TargetPlayer(deltaTime, playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    local distanceFromPlayer = mod.VectorDistance(enemyPosition, playerPosition)

    if distanceFromPlayer <= OOZE_ATTACK_RANGE then
        self:AttackPlayer(playerPosition)
        self:SetEnemyState(2)
    else
        DCEI.Move(self.unit, playerPosition.x, playerPosition.y)
    end
end
function Ooze:UpdateAttackAnimTimer(deltaTime)
    self.currentTimer = self.currentTimer - deltaTime
    if self.currentTimer <= 0 then
        local behaviourStackCount = DCEI.UnitBehaviorStackCount(self.unit, ENEMY_INVINCIBLE)
        if behaviourStackCount == 0 then
            self.currentTimer = OOZE_IDLING_TIME
            self:SetEnemyState(4)
        else
            self.currentTimer = OOZE_ATTACK_TIME
            self:SetEnemyState(3)
        end
    end
end
function Ooze:UpdateAttackWaitingState(deltaTime, playerPosition)
    DCEI.SetUnitPosition2D(self.unit, playerPosition.x, playerPosition.y)
    self.currentTimer = self.currentTimer - deltaTime

    if self.currentTimer <= 0 then
        DCEI.RemoveBehavior(self.unit, ENEMY_INVINCIBLE)
        DCEI.ApplyBehavior(self.unit, OOZE_RESPAWN)

        local randomPosition = self:FindEmptyPlaceInCircle(playerPosition)
        DCEI.SetUnitPosition2D(self.unit, randomPosition.x, randomPosition.y)
        DCEI.Move(self.unit, randomPosition.x, randomPosition.y)

        self.currentTimer = OOZE_IDLING_TIME
        self:SetEnemyState(4)
    end
end
function Ooze:UpdateIdlingState(deltaTime)
    self.currentTimer = self.currentTimer - deltaTime
    if self.currentTimer <= 0 then
        self:SetEnemyState(0)
    end
end
function Ooze:AttackPlayer(playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)
    DCEI.Move(self.unit, enemyPosition.x, enemyPosition.y)

    DCEI.CastAbilityAtPosition(OOZE_ATTACK, self.unit, enemyPosition.x, enemyPosition.y)
    self.currentTimer = OOZE_ATTACK_ANIM_TIME
end
function Ooze:FindEmptyPlaceInCircle(playerPosition)
    local radius = OOZE_JUMP_RADIUS
    local validPositions = {}

    for i = 0, 360 do
        local xPosition = radius * math.sin(math.rad(i)) + playerPosition.x
        local yPosition = radius * math.cos(math.rad(i)) + playerPosition.y

        if DCEI.IsPointOnNavMesh(xPosition, yPosition) then
            table.insert(validPositions, { x = xPosition, y = yPosition })
        end
    end

    local randomIndex = math.random(1, #validPositions)
    local randomPosition = validPositions[randomIndex]

    return randomPosition
end
function Ooze:FindAndSetRandomMovement()
    local emptyPositions = self.room:GetEmptyPositions()
    local randomEmptyPosition = math.random(1, #emptyPositions)

    local position = emptyPositions[randomEmptyPosition]

    self.targetPosition = { x = position.x, y = position.y }
    self.currentTimer = OOZE_RANDOM_MOVEMENT_TIMER
end
function Ooze:SetEnemyState(enemyState)
    self.enemyState = enemyState
end
function Ooze:GetEnemyGold()
    return 1
end
function Ooze:GetMainUnit()
    return self.unit
end
function Ooze:CleanupEnemyDied()
    -- Do nothing here...
end
function Ooze:IsActive()
    return self.enemyState ~= 3
end
function Ooze:ForceSetPosition(position)
    return false
end
-- #endregion

-- #region Goblin Miner
local GoblinMiner = {
    -- Units
    room = nil,
    unit = nil,
    
    enemyState = 0, -- 0: Random Movement, 1: Rocket Barrage, 2: Leap Attack, 3: Drill Missile

    -- Movement
    targetPosition = nil,

    -- General
    currentTimer = 0,
    attackCounter = 0
}
GoblinMiner.__index = GoblinMiner
function GoblinMiner:new(room, xPosition, yPosition)
    local goblinMiner = {}
    setmetatable(goblinMiner, GoblinMiner)

    local enemyUnit = DCEI.CreateUnit(-1, -1, GOBLIN_MINER, xPosition, yPosition)
    goblinMiner.room = room
    goblinMiner.unit = enemyUnit
    
    goblinMiner.enemyState = 0

    goblinMiner.targetPosition = nil

    goblinMiner.attackCounter = 0
    
    goblinMiner.currentTimer = 0

    return goblinMiner
end
function GoblinMiner:Update(deltaTime, playerPosition)
    if self.enemyState == 0 then
        self:UpdateRandomMovement(deltaTime, playerPosition)

    elseif self.enemyState == 1 then
        self:UpdateRocketBarrage(deltaTime, playerPosition)

    elseif self.enemyState == 2 then
        self:UpdateLeapAttack(deltaTime)

    elseif self.enemyState == 3 then
        self:UpdateDrillAttack(deltaTime, playerPosition)

    end
end
function GoblinMiner:CheckAndActivateStunnedState(enemyUnit)
    -- Do nothing here...
end
function GoblinMiner:UpdateRandomMovement(deltaTime, playerPosition)
    if self.targetPosition == nil then
        self:FindAndSetRandomMovement()
        return
    end

    self.currentTimer = self.currentTimer - deltaTime

    if self.currentTimer <= 0 then
        self:ActivateRandomAtack(playerPosition)
    else
        DCEI.Move(self.unit, self.targetPosition.x, self.targetPosition.y)
    end
end
function GoblinMiner:UpdateRocketBarrage(deltaTime, playerPosition)
    self.currentTimer = self.currentTimer - deltaTime

    if self.currentTimer <= 0 then
        self.currentTimer = GOBLIN_MINER_ROCKET_DELAY
        self.attackCounter = self.attackCounter - 1

        DCEI.LogMessage("Spawning Missile")
        ArcadeCore.CreateEffect(GOBLIN_MINER_ROCKET, playerPosition.x, playerPosition.y)
    end

    if self.attackCounter <= 0 then
        self:SetEnemyState(0)
        self:FindAndSetRandomMovement()
    end
end
function GoblinMiner:UpdateLeapAttack(deltaTime)
    self.currentTimer = self.currentTimer - deltaTime
    if self.currentTimer <= 0 then
        self:SetEnemyState(0)
        self:FindAndSetRandomMovement()
    end
end
function GoblinMiner:UpdateDrillAttack(deltaTime, playerPosition)
    self.currentTimer = self.currentTimer - deltaTime
    
    if self.currentTimer <= 0 then
        if self.attackCounter == -10 then
            self.attackCounter = math.random(GOBLIN_MINER_MIN_DRILL_COUNT, GOBLIN_MINER_MAX_DRILL_COUNT)
        end

        if self.attackCounter > 0 then
            self:LaunchDrillMissile(playerPosition)

            if self.attackCounter == 0 then
                DCEI.ApplyBehavior(self.unit, GOBLIN_MINER_DRILL_END)
                self.currentTimer = GOBLIN_MINER_DRILL_FOLLOW_TIME
            end
        
        elseif self.attackCounter == 0 then
            self:SetEnemyState(0)
            self:FindAndSetRandomMovement()
        end
    end

    self:LookAtPlayer(playerPosition)
end
function GoblinMiner:ActivateRandomAtack(playerPosition)
    local position = DCEI.GetUnitPosition2D(self.unit)
    DCEI.Move(self.unit, position.x, position.y)

    -- 1: Rocket Barrage, 2: Leap Attack, 3: Drill Missile, 4: Summon Goblins
    local randomNumber = math.random(1, 4)
    randomNumber = 3

    if randomNumber == 1 then
        self:SetEnemyState(1)
        self.attackCounter = math.random(GOBLIN_MINER_MIN_ROCKETS, GOBLIN_MINER_MAX_ROCKETS)

    elseif randomNumber == 2 then
        self:LeapAtPlayer(playerPosition)

    elseif randomNumber == 3 then
        self:SetupDrillMissile()

    else
        self:SpawnGoblinsInCircle()
        self:SetEnemyState(0)
        self:FindAndSetRandomMovement()
    end
end
function GoblinMiner:LeapAtPlayer(playerPosition)
    DCEI.LogMessage("Leaping At Player")

    self:SetEnemyState(2)

    self.currentTimer = GOBLIN_MINER_LEAP_TIMER
    self:LookAtPlayer(playerPosition)

    DCEI.CastAbilityAtPosition(GOBLIN_MINER_LEAP, self.unit, playerPosition.x, playerPosition.y)
end
function GoblinMiner:SetupDrillMissile()
    DCEI.ApplyBehavior(self.unit, GOBLIN_MINER_DRILL_START)
    self.currentTimer = GOBLIN_MINER_DRILL_WIND_TIME
    self.attackCounter = -10 -- Probably use another variable to indicate another state?

    self:SetEnemyState(3)
end
function GoblinMiner:LaunchDrillMissile(playerPosition)
    DCEI.LogMessage("Launching Drill Missile")

    self.currentTimer = GOBLIN_MINER_DRILL_TIMER
    self.attackCounter = self.attackCounter - 1
    
    self:LookAtPlayer(playerPosition)
    
    DCEI.CastAbilityAtPosition(GOBLIN_MINER_DRILL, self.unit, playerPosition.x, playerPosition.y)
end
function GoblinMiner:SpawnGoblinsInCircle()
    DCEI.LogMessage("Spawning Goblins")
    
    local radius = GOBLIN_MINER_GOBLIN_SPAWN_RADIUS
    local validPositions = {}
    local position = DCEI.GetUnitPosition2D(self.unit)

    for i = 0, 360 do
        local xPosition = radius * math.sin(math.rad(i)) + position.x
        local yPosition = radius * math.cos(math.rad(i)) + position.y

        if DCEI.IsPointOnNavMesh(xPosition, yPosition) then
            table.insert(validPositions, { x = xPosition, y = yPosition })
        end
    end
    
    validPositions = mod.ShuffleTable(validPositions)
    for i = 1, GOBLIN_MINER_GOBLIN_COUNT do
        local spawnPosition = validPositions[i]

        local goblin = Goblin:new(self.room, spawnPosition.x, spawnPosition.y)
        self.room:AddChildEnemy(goblin)
    end
end
function GoblinMiner:LookAtPlayer(playerPosition)
    local enemyPosition = DCEI.GetUnitPosition2D(self.unit)

    local direction = mod.VectorSubtract(playerPosition, enemyPosition)
    local angle = math.deg(math.atan(direction.x, direction.y))

    DCEI.SetUnitRotationEuler(self.unit, 0, angle, 0)
end
function GoblinMiner:FindAndSetRandomMovement()
    local emptyPositions = self.room:GetEmptyPositions()
    local randomEmptyPosition = math.random(1, #emptyPositions)

    local position = emptyPositions[randomEmptyPosition]

    self.targetPosition = { x = position.x, y = position.y }
    self.currentTimer = GOBLIN_MINER_RANDOM_MOVEMENT_TIMER
end
function GoblinMiner:SetEnemyState(enemyState)
    DCEI.LogMessage("Enemy State: " .. enemyState)
    self.enemyState = enemyState
end
function GoblinMiner:GetEnemyGold()
    return 1
end
function GoblinMiner:GetMainUnit()
    return self.unit
end
function GoblinMiner:CleanupEnemyDied()
    -- Do nothing here...
end
function GoblinMiner:IsActive()
    return true
end
function GoblinMiner:ForceSetPosition(position)
    DCEI.SetUnitPosition2D(self.unit, position.x, position.y)
    DCEI.Move(self.unit, position.x, position.y)
    return true
end
-- #endregion

mod.EnemyGoblinChef = GoblinChef 
mod.EnemyHobGoblin = HobGoblin
mod.EnemyGoblin = Goblin
mod.EnemyGoblinSapper = GoblinSapper
mod.EnemyOoze = Ooze
mod.EnemyGoblinMiner = GoblinMiner

mod.VectorDistance = nil
mod.VectorSubtract = nil
mod.LerpAngleDeg = nil
mod.NormalizeUnitRotation = nil
mod.ShuffleTable = nil

mod.WalkableTextureId = nil

return mod