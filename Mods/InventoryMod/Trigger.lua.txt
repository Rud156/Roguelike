local ArcadeCore = GameModules["Arcade/Core"]

local mod = {}

local COLLECTIBLES_TABLE = {
    _Collectible_Speed_Potion = {
        itemName = "_Collectible_Speed_Potion",
        itemDisplayName = "Speed Potion",
        itemImage = "icon_catalyst_main_item5_blue_03",
        itemStackable = -1,
        itemType = 1,
        itemCost = 35,
        itemBehaviourName = "_Collectible_Speed_Potion",
        itemDescription = "Consume to increases the movement speed of the Hero by 30% for 10 seconds",
        itemSmallDescription = "Movement Speed Buff",
        value = 10
    },
    _Collectible_Catalyst_Potion = {
        itemName = "_Collectible_Catalyst_Potion",
        itemDisplayName = "Catalyst Potion",
        itemImage = "icon_catalyst_main_item5_blue_01",
        itemStackable = -1,
        itemType = 1,
        itemCost = 35,
        itemDescription = "Consume to enter Berserk Mode for 10 seconds",
        itemSmallDescription = "consume to enter Berserk Mode\nfor 10 seconds",
        itemBehaviourName = "_Collectible_Catalyst_Potion",
        value = 10
    },
    _Collectible_Potion = {
        itemName = "_Collectible_Potion",
        itemDisplayName = "Potion",
        itemImage = "icon_catalyst_main_item5_orange_02",
        itemStackable = 2,
        itemType = 1,
        itemCost = 30,
        itemDescription = "Consume to instantly regenerate 50 HP",
        itemSmallDescription = "Consume to instantly\nregenerate 50 HP",
        itemBehaviourName = "_Collectible_Potion",
        value = 50
    },
    _Collectible_Bomb = {
        itemName = "_Collectible_Bomb",
        itemDisplayName = "Bomb",
        itemImage = "icon_gear_bomb_01",
        itemStackable = 2,
        itemType = 1,
        itemCost = 15,
        itemDescription = "Place a bomb that will explode 2 seconds after placement from where the Hero is standing. Bomb explosion will deal 30 damage in a radius of 1",
        itemSmallDescription = "Explode after 2 sec",
        itemBombName = "_Collectible_Bomb_Unit"
    }
}

local COLLECTIBLES_LIST = {
    "_Collectible_Speed_Potion",
    "_Collectible_Potion",
    "_Collectible_Potion",
    "_Collectible_Catalyst_Potion"
}

local COLLECTIBLE_NAMES = {
    SpeedPotion = "_Collectible_Speed_Potion",
    HealthPotion = "_Collectible_Potion",
    Bomb = "_Collectible_Potion",
    CatalystPotion = "_Collectible_Catalyst_Potion"
}

local COLLECTIBLE_BASE_STRING = "_Collectible"

local COLLECTIBLES_UI_DISPLAY_DIST = 1
local COLLECTIBLE_DROPPED_BEHAVIOUR = "_Collectible_Dropped"

-- Item  Type
-- -1: Empty
-- 0: Gear
-- 1: Consumable
local InventorySlot = { 
    emptyItemImage = "", 

    itemType = 0,
    itemName = "",
    itemDescription = "",

    stackability = -1,
    currentStack = -1,
    
    inventoryBackground = nil,
    inventoryIcon = nil,
    slotDropButton = nil,
    stackCounter = nil,
    slotRecharge = nil,

    isSlotRechargeActive = false,
    maxRechargeTime = 0,
    currentRechargeTime = 0
}
InventorySlot.__index = InventorySlot
function InventorySlot:new(emptyItemImage, backgroundImage, uiParent, slotClickedFunction, slotDropFunction)
    local inventory = {}
    setmetatable(inventory, InventorySlot)

    local slotItem = DCEI.NewButton(uiParent)
    DCEI.SetMinSize(slotItem, 75, 75)
    DCEI.SetMaxSize(slotItem, 100, 100)
    DCEI.SetBackgroundImage(slotItem, backgroundImage)

    local inventoryIcon = DCEI.NewFrame(slotItem)
    DCEI.SetMinSize(inventoryIcon, 70, 70)
    DCEI.SetBackgroundImage(inventoryIcon, emptyItemImage)

    local slotRecharge = DCEI.NewFrame(slotItem)
    DCEI.SetMinSize(slotRecharge, 95, 95)
    DCEI.SetBackgroundImage(slotRecharge, "ui_squareround")
    DCEI.SetVerticalOffsetInParent(slotRecharge, 2)
    DCEI.SetBackgroundImageColor(slotRecharge, 0, 0, 0, 0)

    local slotDropButton = DCEI.NewButton(slotItem)
    DCEI.SetMinSize(slotDropButton, 20, 20)
    DCEI.SetBackgroundImage(slotDropButton, "ui_cross")
    DCEI.SetTopAlignmentInParent(slotDropButton)
    DCEI.SetRightAlignmentInParent(slotDropButton)
    DCEI.SetHorizontalOffsetInParent(slotDropButton, 14)
    DCEI.SetVerticalOffsetInParent(slotDropButton, 20)
    DCEI.SetBackgroundImageColor(slotDropButton, 0, 0, 0, 0)

    local stackCounter = DCEI.NewText(slotItem)
    DCEI.SetMinSize(stackCounter, 20, 20)
    DCEI.SetBottomAlignmentInParent(stackCounter)
    DCEI.SetRightAlignmentInParent(stackCounter)
    DCEI.SetText(stackCounter, "")
    
    inventory.emptyItemImage = emptyItemImage
    
    inventory.itemType = -1
    inventory.itemName = itemName
    inventory.itemDescription = ""

    inventory.stackability = -1
    inventory.currentStack = -1

    inventory.inventoryBackground = slotItem
    inventory.inventoryIcon = inventoryIcon
    inventory.slotDropButton = slotDropButton
    inventory.stackCounter = stackCounter
    inventory.slotRecharge = slotRecharge

    DCEI.SetOnClickCallback(
        slotDropButton,
        function()
            slotDropFunction(inventory:GetInventoryItemName(), inventory)
        end
    )

    DCEI.SetOnClickCallback(
        slotItem,
        function()
            slotClickedFunction(inventory:GetInventoryItemName(), inventory)
        end
    )

    return inventory
end
function InventorySlot:SaveSlot(index)
    mod.SaveInventorySlotData(
        index,
        self.itemName,
        self.currentStack,
        self.isSlotRechargeActive,
        self.maxRechargeTime,
        self.currentRechargeTime
    )
end
function InventorySlot:LoadSlot(index)
    local itemName, currentStack, isSlotRechargeActive, maxRechargeTime, currentRechargeTime = mod.GetInventorySlotData(index)

    if itemName ~= nil and itemName ~= "" and currentStack ~= -1 and currentStack ~= nil then
        local collectibleItem = COLLECTIBLES_TABLE[itemName]
        
        self:UpdateInventoryItem(
            itemName,
            collectibleItem.itemType,
            collectibleItem.itemDescription,
            
            collectibleItem.itemImage,
            
            collectibleItem.itemStackable,
            currentStack
        )

        self.isSlotRechargeActive = isSlotRechargeActive
        self.maxRechargeTime = maxRechargeTime
        self.currentRechargeTime = currentRechargeTime

        if isSlotRechargeActive then
            DCEI.SetBackgroundImageColor(self.slotRecharge, 0, 0, 0, 0.5)
        end
    end
end
function InventorySlot:ClearSlot(index)
    mod.ClearInventorySlotData(index)
end
function InventorySlot:GetInventoryItemType()
    return self.itemType
end
function InventorySlot:GetInventoryItemName()
    return self.itemName
end
function InventorySlot:UseItem()
    if self.stackability ~= -1 then
        self.currentStack = self.currentStack - 1
        DCEI.SetText(self.stackCounter, "x " .. self.currentStack)

        if self.currentStack <= 0 then
            self:Clear()
        end

    else
        self:Clear()
    end
end
function InventorySlot:UpdateSlotRecharge(deltaTime)
    if not self.isSlotRechargeActive then
        return
    end

    self.currentRechargeTime = self.currentRechargeTime - deltaTime

    if self.currentRechargeTime <= 0 then
        self.isSlotRechargeActive = false
        DCEI.SetBackgroundImageColor(self.slotRecharge, 0, 0, 0, 0)
        
    else
        local rechargeRatio = self.currentRechargeTime / self.maxRechargeTime
        DCEI.SetBackgroundImageFillAmount(self.slotRecharge, rechargeRatio)
    end
end
function InventorySlot:ActivateInventorySlotRecharge(maxRechargeTime)
    self.isSlotRechargeActive = true
    self.maxRechargeTime = maxRechargeTime
    self.currentRechargeTime = maxRechargeTime

    DCEI.SetBackgroundImageColor(self.slotRecharge, 0, 0, 0, 0.5)
end
function InventorySlot:DeActivateInventorySlotRecharge()
    self.isSlotRechargeActive = false
    DCEI.SetBackgroundImageColor(self.slotRecharge, 0, 0, 0, 0)
end
function InventorySlot:UpdateInventoryItem(itemName, itemType, itemDescription, itemImage, stackability, currentStack)
    DCEI.LogMessage("Updating Inventory with new item")

    self.itemType = itemType
    self.itemName = itemName
    self.itemDescription = itemDescription

    self.stackability = stackability
    self.currentStack = currentStack

    if stackability ~= -1 then
        DCEI.SetText(self.stackCounter, "x " .. currentStack)
    else
        DCEI.SetText(self.stackCounter, "")
    end
    
    DCEI.SetBackgroundImage(self.inventoryIcon, itemImage)
    DCEI.SetBackgroundImageColor(self.slotDropButton, 1, 1, 1, 1)
end
function InventorySlot:StackInventoryItem()
    DCEI.LogMessage("Stacking Inventory")

    if self:IsSlotStackable() then
        self.currentStack = self.currentStack + 1
        DCEI.SetText(self.stackCounter, "x " .. self.currentStack)
    else
        DCEI.LogError("Inventory stack is full!!!")
    end
end
function InventorySlot:Clear()
    DCEI.SetBackgroundImage(self.inventoryIcon, self.emptyItemImage)
    
    self.itemType = -1
    self.itemName = ""
    self.itemDescription = ""

    self.stackability = -1
    self.currentStack = -1

    self.isSlotRechargeActive = false
    self.maxRechargeTime = 0
    self.currentRechargeTime = 0

    DCEI.SetBackgroundImageColor(self.slotRecharge, 0, 0, 0, 0)
    DCEI.SetBackgroundImageColor(self.slotDropButton, 0, 0, 0, 0)
    DCEI.SetText(self.stackCounter, "")
end
function InventorySlot:DropInventoryItem()
    if self.stackability ~= -1 then
        if self.currentStack > 1 then
            self.currentStack = self.currentStack - 1
            DCEI.SetText(self.stackCounter, "x " .. self.currentStack)

        else
            self:Clear()
        end

    else
        self:Clear()
    end
end
function InventorySlot:IsEmpty()
    return self.itemType == -1
end
function InventorySlot:IsSlotStackable()
    if self.stackability == -1 or self.currentStack == self.stackability then
        return false
    end

    return true
end
function InventorySlot:Destroy()
    DCEI.Destroy(self.inventoryUi)
end


local Inventory = { inventorySlots = {} }
Inventory.__index = Inventory
function Inventory:new(inventorySlots)
    local inventory = {}
    setmetatable(inventory, Inventory)

    inventory.inventorySlots = inventorySlots

    return inventory
end
function Inventory:SaveInventory()
    for i, slot in ipairs(self.inventorySlots) do
        slot:SaveSlot(i)
    end
end
function Inventory:LoadInventory()
    for i, slot in ipairs(self.inventorySlots) do
        slot:LoadSlot(i)
    end
end
function Inventory:ClearInventorySave()
    for i, slot in ipairs(self.inventorySlots) do
        slot:ClearSlot(i)
    end
end
function Inventory:UpdateSlots(deltaTime)
    for i, slot in ipairs(self.inventorySlots) do
        slot:UpdateSlotRecharge(deltaTime)
    end
end
function Inventory:ActivateInventorySlotRecharge(itemName, maxRechargeTime)
    for i, slot in ipairs(self.inventorySlots) do
        if slot:GetInventoryItemName() == itemName then
            slot:ActivateInventorySlotRecharge(maxRechargeTime)
            break
        end
    end
end
function Inventory:DeActivateInventorySlotRecharge(itemName)
    for i, slot in ipairs(self.inventorySlots) do
        if slot:GetInventoryItemName() == itemName then
            slot:DeActivateInventorySlotRecharge()
            break
        end
    end
end
function Inventory:IsFull()
    for i, slot in ipairs(self.inventorySlots) do
        if slot:IsEmpty() then
            return false
        end
    end

    return true
end
function Inventory:GetEmptySlotIndex()
    for i, slot in ipairs(self.inventorySlots) do
        if slot:IsEmpty() then
            return i
        end
    end

    return -1
end
function Inventory:GetInventorySlotByName(itemName)
    local index = self:GetItemInInventoryIndex(itemName)
    return self.inventorySlots[index]
end
function Inventory:GetItemInInventoryIndex(itemName)
    for i, slot in ipairs(self.inventorySlots) do
        local slotItemName = slot:GetInventoryItemName()
        if slotItemName == itemName then
            return i
        end
    end

    return -1
end
function Inventory:AddNewItemToInventory(slotIndex, collectibleItem)
    local inventorySlot = self.inventorySlots[slotIndex]

    inventorySlot:UpdateInventoryItem(
        collectibleItem.itemName, 
        collectibleItem.itemType,
        collectibleItem.itemDescription,
        collectibleItem.itemImage,
        collectibleItem.itemStackable,
        1
    )
end
function Inventory:CheckAndAddItemToSlot(collectibleName)
    local collectibleItem = COLLECTIBLES_TABLE[collectibleName]
    local itemStackable = collectibleItem.itemStackable

    DCEI.LogMessage("Collectible Item: " .. collectibleName)
    DCEI.LogMessage("Item Stackable: " .. tostring(itemStackable))
    
    if itemStackable == -1 then
        if self:IsFull() then
            return false
        end

        local emptySlotIndex = self:GetEmptySlotIndex()
        self:AddNewItemToInventory(emptySlotIndex, collectibleItem)
        
        return true

    else
        local slotItemIndex = self:GetItemInInventoryIndex(collectibleName)
        if slotItemIndex ~= -1 then
            local inventorySlot = self.inventorySlots[slotItemIndex]
            if inventorySlot:IsSlotStackable() then
                inventorySlot:StackInventoryItem()
                return true
            end

        elseif not self:IsFull() then
            local emptySlotIndex = self:GetEmptySlotIndex()
            self:AddNewItemToInventory(emptySlotIndex, collectibleItem)
            return true

        else
            return false
        end
    end

    return false
end
function Inventory:GetInventorySlots()
    return self.inventorySlots
end


local CollectiblesUI = {
    unit = nil,
    displayHolder = nil,
    priceHolder = nil,

    priceText = nil,
    originalPrice = 0
}
CollectiblesUI.__index = CollectiblesUI
function CollectiblesUI:new(uiRoot, unit, itemName)
    local collectiblesUi = {}
    setmetatable(collectiblesUi, CollectiblesUI)

    collectiblesUi.unit = unit
    collectiblesUi.displayHolder = nil
    collectiblesUi.priceHolder = nil

    collectiblesUi.priceText = nil
    collectiblesUi.originalPrice = 0

    collectiblesUi:CreateUI(uiRoot, unit, itemName)

    return collectiblesUi
end
function CollectiblesUI:CreateUI(uiRoot, unit, itemName)
    local mainFrame = DCEI.NewFrame(uiRoot)
    DCEI.SetBackgroundImage(mainFrame, "shape_square_gradient_32x32")
    DCEI.SetBackgroundImageColor(mainFrame, 0.9, 0.8, 0.467, 1)
    DCEI.SetPadding(mainFrame, 14)

    local hStack = DCEI.NewHStack(mainFrame)
    DCEI.SetSpacing(hStack, 14)

    local backgroundImage = DCEI.NewFrame(hStack)
    DCEI.SetBackgroundImage(backgroundImage, COLLECTIBLES_TABLE[itemName].itemImage)
    DCEI.SetMinSize(backgroundImage, 100, 100)

    local infoFrame = DCEI.NewVStack(hStack)
    DCEI.SetSpacing(infoFrame, 14)

    local itemNameText = DCEI.NewText(infoFrame)
    DCEI.SetText(itemNameText, COLLECTIBLES_TABLE[itemName].itemDisplayName)

    local itemPriceFrame = DCEI.NewHStack(infoFrame)
    DCEI.SetSpacing(itemPriceFrame, 14)

    local itemPriceImage = DCEI.NewFrame(itemPriceFrame)
    DCEI.SetBackgroundImage(itemPriceImage, "ui_ingame_coin")
    DCEI.SetMinSize(itemPriceImage, 30, 30)
    local itemPrice = DCEI.NewText(itemPriceFrame)
    DCEI.SetText(itemPrice, COLLECTIBLES_TABLE[itemName].itemCost)
    
    local itemDestription = DCEI.NewText(infoFrame)
    DCEI.SetText(itemDestription, COLLECTIBLES_TABLE[itemName].itemSmallDescription)

    DCEI.AttachToUnit(mainFrame, unit, { offset = { up = 2 } })
    self.displayHolder = mainFrame
    self.priceHolder = itemPriceFrame

    self.priceText = itemPrice
    self.originalPrice = COLLECTIBLES_TABLE[itemName].itemCost

    DCEI.SetActive(self.displayHolder, false)
    DCEI.TriggerAddUnitRemovedEvent(
        self.unit,
        function()
            DCEI.Destroy(self.displayHolder)
        end
    )
end
function CollectiblesUI:Update(deltaTime, perkDisplay, playerPosition)
    if not self:IsValid() then
        return
    end

    local unitPosition = DCEI.GetUnitPosition2D(self.unit)
    local distance = mod.VectorDistance(unitPosition, playerPosition)

    if distance <= COLLECTIBLES_UI_DISPLAY_DIST then
        if perkDisplay:HasPerk(mod.PerkNames.OldCustomer) then
            local value = mod.Perks[mod.PerkNames.OldCustomer].value
            local discount = self.originalPrice * value

            local newPrice = self.originalPrice - math.floor(discount)
            DCEI.SetText(self.priceText, newPrice)
        end

        DCEI.SetActive(self.displayHolder, true)
    else
        DCEI.SetActive(self.displayHolder, false)
    end

    local behaviourStack = DCEI.UnitBehaviorStackCount(self.unit, COLLECTIBLE_DROPPED_BEHAVIOUR)
    if behaviourStack ~= 0 then
        DCEI.SetActive(self.priceHolder, false)
    else
        DCEI.SetActive(self.priceHolder, true)
    end
end
function CollectiblesUI:IsValid()
    return ArcadeCore.UnitIsAlive(self.unit)
end


local CollectiblesUIManager = {
    collectiblesUi = {}
}
CollectiblesUIManager.__index = CollectiblesUIManager
function CollectiblesUIManager:new(uiRoot)
    local collectiblesUiManager = {}
    setmetatable(collectiblesUiManager, CollectiblesUIManager)

    collectiblesUiManager.collectiblesUi = {}

    for _, itemName in ipairs(COLLECTIBLES_LIST) do
        local units = DCEI.FindUnits(itemName)

        for _, item in ipairs(units) do
            local itemDisplay = CollectiblesUI:new(uiRoot, item, itemName)
            table.insert(collectiblesUiManager.collectiblesUi, itemDisplay)
        end
    end

    return collectiblesUiManager
end
function CollectiblesUIManager:Update(deltaTime, perkDisplay, playerPosition)
    local removalIndex = -1

    for i, collectible in ipairs(self.collectiblesUi) do
        if collectible:IsValid() then
            collectible:Update(deltaTime, perkDisplay, playerPosition)
        else
            removalIndex = i
        end
    end

    if removalIndex ~= -1 then
        table.remove(self.collectiblesUi, removalIndex)
    end
end
function CollectiblesUIManager:AddNewUI(uiRoot, unit, itemName)
    local itemDisplay = CollectiblesUI:new(uiRoot, unit, itemName)
    table.insert(self.collectiblesUi, itemDisplay)
end

mod.Inventory = Inventory
mod.InventorySlot = InventorySlot
mod.CollectiblesUIManager = CollectiblesUIManager
mod.InventoryCollectibles = COLLECTIBLES_TABLE
mod.InventoryCollectiblesList = COLLECTIBLES_LIST
mod.InventoryCollectibleNames = COLLECTIBLE_NAMES
mod.InventoryCollectibleBaseString = COLLECTIBLE_BASE_STRING
mod.CollectibleDropped = COLLECTIBLE_DROPPED_BEHAVIOUR

mod.VectorDistance = nil

mod.Perks = nil
mod.PerkNames = nil

mod.SaveInventorySlotData = nil
mod.GetInventorySlotData = nil
mod.ClearInventorySlotData = nil

return mod